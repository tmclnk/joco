{"id":"clojure-hickey-f5403e9c","diff":" src/clj/clojure/core.clj | 10 ++++++----\n 1 file changed, 6 insertions(+), 4 deletions(-)\n\ndiff --git a/src/clj/clojure/core.clj b/src/clj/clojure/core.clj\nindex 8e98e07..2d709fc 100644\n--- a/src/clj/clojure/core.clj\n+++ b/src/clj/clojure/core.clj\n@@ -1651,10 +1651,12 @@\n   [x \u0026 body]\n   `(let [lockee# ~x]\n      (try\n-      (monitor-enter lockee#)\n-      ~@body\n-      (finally\n-       (monitor-exit lockee#)))))\n+       (let [locklocal# lockee#]\n+         (monitor-enter locklocal#)\n+         (try\n+           ~@body\n+           (finally\n+            (monitor-exit locklocal#)))))))\n \n (defmacro ..\n   \"form \u003d\u003e fieldName-symbol or (instanceMethodName-symbol args*)","expectedMessage":"CLJ-1472 Ensure monitor object is on stack, for verifiers","repository":"clojure-hickey","commitHash":"f5403e9c666f3281fdb880cb2c21303c273eed2d","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-989a3b98","diff":" src/clj/clojure/core.clj | 10 ++++++----\n 1 file changed, 6 insertions(+), 4 deletions(-)\n\ndiff --git a/src/clj/clojure/core.clj b/src/clj/clojure/core.clj\nindex 8e98e07..2d709fc 100644\n--- a/src/clj/clojure/core.clj\n+++ b/src/clj/clojure/core.clj\n@@ -1651,10 +1651,12 @@\n   [x \u0026 body]\n   `(let [lockee# ~x]\n      (try\n-      (monitor-enter lockee#)\n-      ~@body\n-      (finally\n-       (monitor-exit lockee#)))))\n+       (let [locklocal# lockee#]\n+         (monitor-enter locklocal#)\n+         (try\n+           ~@body\n+           (finally\n+            (monitor-exit locklocal#)))))))\n \n (defmacro ..\n   \"form \u003d\u003e fieldName-symbol or (instanceMethodName-symbol args*)","expectedMessage":"CLJ-1472 - Ensure monitor object is on stack so its easier to analyze in the face of locals clearing","repository":"clojure-hickey","commitHash":"989a3b98d468e57e489a11e765f256eab90ec417","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-4d2a7dba","diff":" src/clj/clojure/core/server.clj | 37 ++++++++++++++++++++++++++-----------\n 1 file changed, 26 insertions(+), 11 deletions(-)\n\ndiff --git a/src/clj/clojure/core/server.clj b/src/clj/clojure/core/server.clj\nindex 102dbc7..2529a64 100644\n--- a/src/clj/clojure/core/server.clj\n+++ b/src/clj/clojure/core/server.clj\n@@ -195,6 +195,7 @@\n    :ns ns-name-string\n    :ms long ;;eval time in milliseconds\n    :form string ;;iff successfully read\n+   :clojure.error/phase (:execution et al per clojure.main/ex-triage) ;;iff error occurred\n   }\n   {:tag :out\n    :val string} ;chars from during-eval *out*\n@@ -241,11 +242,15 @@\n                               true)))\n                         (catch Throwable ex\n                           (set! *e ex)\n-                          (out-fn {:tag :ret :val (Throwable-\u003emap ex) :ns (str (.name *ns*)) :form s})\n+                          (out-fn {:tag :ret :val (Throwable-\u003emap ex)\n+                                   :ns (str (.name *ns*)) :form s\n+                                   :clojure.error/phase :execution})\n                           true)))\n                     (catch Throwable ex\n                       (set! *e ex)\n-                      (out-fn {:tag :ret :val (Throwable-\u003emap ex) :ns (str (.name *ns*))})\n+                      (out-fn {:tag :ret :val (Throwable-\u003emap ex)\n+                               :ns (str (.name *ns*))\n+                               :clojure.error/phase :read-source})\n                       true))\n               (recur)))\n           (finally\n@@ -272,11 +277,16 @@\n         out *out*\n         lock (Object.)]\n     (prepl *in*\n-           #(binding [*out* out, *flush-on-newline* true, *print-readably* true]\n-              (locking lock\n-                (prn (cond-\u003e %1\n-                             (#{:ret :tap} (:tag %1))\n-                             (assoc :val (valf (:val %1))))))))))\n+           (fn [m]\n+             (binding [*out* out, *flush-on-newline* true, *print-readably* true]\n+               (locking lock\n+                 (prn (if (#{:ret :tap} (:tag m))\n+                        (try\n+                          (assoc m :val (valf (:val m)))\n+                          (catch Throwable ex\n+                            (assoc m :val (Throwable-\u003emap ex)\n+                                   :clojure.error/phase :print-eval-result)))\n+                        m))))))))\n \n (defn remote-prepl\n   \"Implements a prepl on in-reader and out-fn by forwarding to a\n@@ -290,7 +300,7 @@\n   Alpha, subject to change.\"\n   {:added \"1.10\"}\n   [^String host port ^Reader\n-  in-reader out-fn \u0026 {:keys [valf readf] :or {valf read-string, readf #(read %1 false %2)}}]\n+   in-reader out-fn \u0026 {:keys [valf readf] :or {valf read-string, readf #(read %1 false %2)}}]\n   (let [valf (resolve-fn valf)\n         readf (resolve-fn readf)\n         ^long port (if (string? port) (Integer/valueOf ^String port) port)\n@@ -302,9 +312,14 @@\n             (try (loop []\n                    (let [{:keys [tag val] :as m} (readf rd EOF)]\n                      (when-not (identical? m EOF)\n-                       (out-fn (cond-\u003e m\n-                                       (#{:ret :tap} tag)\n-                                       (assoc :val (try (valf val) (catch Throwable ex val)))))\n+                       (out-fn\n+                        (if (#{:ret :tap} tag)\n+                          (try\n+                            (assoc m :val (valf val))\n+                            (catch Throwable ex\n+                              (assoc m :val (Throwable-\u003emap ex)\n+                                     :clojure.error/phase :read-eval-result)))\n+                          m))\n                        (recur))))\n                  (finally\n                   (.close wr))))","expectedMessage":"add error phases to prepls","repository":"clojure-hickey","commitHash":"4d2a7dbae68036dcc80cb40ca155985ad06aaeb8","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-2cc37bb5","diff":" src/clj/clojure/core/protocols.clj |  6 +++++-\n src/clj/clojure/core_deftype.clj   | 41 ++++++++++++++++++++++++++++----------\n 2 files changed, 35 insertions(+), 12 deletions(-)\n\ndiff --git a/src/clj/clojure/core/protocols.clj b/src/clj/clojure/core/protocols.clj\nindex be72057..10c0229 100644\n--- a/src/clj/clojure/core/protocols.clj\n+++ b/src/clj/clojure/core/protocols.clj\n@@ -180,9 +180,11 @@\n   (kv-reduce [amap f init]))\n \n (defprotocol Datafiable\n+  :extend-via-metadata true\n+\n   (datafy [o] \"return a representation of o as data (default identity)\"))\n \n-(extend-protocol Datafiable\n+(extend-protocol Datafiable  \n   nil\n   (datafy [_] nil)\n \n@@ -190,6 +192,8 @@\n   (datafy [x] x))\n \n (defprotocol Navigable\n+  :extend-via-metadata true\n+  \n   (nav [coll k v] \"return (possibly transformed) v in the context of coll and k (a key/index or nil),\n defaults to returning v.\"))\n \ndiff --git a/src/clj/clojure/core_deftype.clj b/src/clj/clojure/core_deftype.clj\nindex 6df1734..786f0d4 100644\n--- a/src/clj/clojure/core_deftype.clj\n+++ b/src/clj/clojure/core_deftype.clj\n@@ -584,7 +584,7 @@\n     (set! (.__methodImplCache pf) (expand-method-impl-cache cache (class x) f))\n     f))\n \n-(defn- emit-method-builder [on-interface method on-method arglists]\n+(defn- emit-method-builder [on-interface method on-method arglists extend-via-meta]\n   (let [methodk (keyword method)\n         gthis (with-meta (gensym) {:tag \u0027clojure.lang.AFunction})\n         ginterf (gensym)]\n@@ -604,15 +604,23 @@\n                   (fn [args]\n                     (let [gargs (map #(gensym (str \"gf__\" % \"__\")) args)\n                           target (first gargs)]\n-                      `([~@gargs]\n-                          (let [cache# (.__methodImplCache ~gthis)\n-                                f# (.fnFor cache# (clojure.lang.Util/classOf ~target))]\n-                            ((or\n-                              (when (identical? f# ~ginterf) f#)\n-                              (get (meta ~target) (.sym cache#))\n-                              f#\n-                              (-cache-protocol-fn ~gthis ~target ~on-interface ~ginterf))\n-                             ~@gargs)))))\n+                      (if extend-via-meta\n+                        `([~@gargs]\n+                            (let [cache# (.__methodImplCache ~gthis)\n+                                  f# (.fnFor cache# (clojure.lang.Util/classOf ~target))]\n+                              (if (identical? f# ~ginterf)\n+                                (f# ~@gargs)\n+                                (if-let [meta# (when-let [m# (meta ~target)] ((.sym cache#) m#))]\n+                                  (meta# ~@gargs)\n+                                  (if f#\n+                                    (f# ~@gargs)\n+                                    ((-cache-protocol-fn ~gthis ~target ~on-interface ~ginterf) ~@gargs))))))\n+                        `([~@gargs]\n+                            (let [cache# (.__methodImplCache ~gthis)\n+                                  f# (.fnFor cache# (clojure.lang.Util/classOf ~target))]\n+                              (if f#\n+                                (f# ~@gargs)\n+                                ((-cache-protocol-fn ~gthis ~target ~on-interface ~ginterf) ~@gargs)))))))\n                   arglists))]\n          (set! (.__methodImplCache f#) cache#)\n          f#))))\n@@ -687,7 +695,8 @@\n                                 (mapcat \n                                  (fn [s]\n                                    [`(intern *ns* (with-meta \u0027~(:name s) (merge \u0027~s {:protocol (var ~name)})))\n-                                    (emit-method-builder (:on-interface opts) (:name s) (:on s) (:arglists s))])\n+                                    (emit-method-builder (:on-interface opts) (:name s) (:on s) (:arglists s)\n+                                                         (:extend-via-metadata opts))])\n                                  (vals sigs)))))\n      (-reset-methods ~name)\n      \u0027~name)))\n@@ -699,6 +708,9 @@\n     ;optional doc string\n     \\\"A doc string for AProtocol abstraction\\\"\n \n+   ;options\n+   :extend-via-metadata true\n+\n   ;method signatures\n     (bar [this a b] \\\"bar docs\\\")\n     (baz [this a] [this a b] [this a b c] \\\"baz docs\\\"))\n@@ -713,6 +725,13 @@\n   effect, and defines no new types or classes. Implementations of \n   the protocol methods can be provided using extend.\n \n+  When :extend-via-metadata is true, values can extend protocols by\n+  adding metadata where keys are fully-qualified protocol function\n+  symbols and values are function implementations. Protocol\n+  implementations are checked first for direct definitions (defrecord,\n+  deftype, reify), then metadata definitions, then external\n+  extensions (extend, extend-type, extend-protocol)\n+\n   defprotocol will automatically generate a corresponding interface,\n   with the same name as the protocol, i.e. given a protocol:\n   my.ns/Protocol, an interface: my.ns.Protocol. The interface will","expectedMessage":"make :extend-via-metadata explicit option for defprotocol, Datafiable and Navigable opt-in","repository":"clojure-hickey","commitHash":"2cc37bb56a9125a1829c73c505e32995e663059a","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-88eca12e","diff":" src/jvm/clojure/lang/Compiler.java | 18 ++++++++++--------\n 1 file changed, 10 insertions(+), 8 deletions(-)\n\ndiff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java\nindex 0fe38c8..e03876d 100644\n--- a/src/jvm/clojure/lang/Compiler.java\n+++ b/src/jvm/clojure/lang/Compiler.java\n@@ -6875,19 +6875,21 @@ static public class CompilerException extends RuntimeException implements IExcep\n \t\t\t\tline + \":\" + column + \").\";\n \t}\n \n+\tprivate static boolean isSpecError(Throwable t) {\n+\t\treturn (t instanceof IExceptionInfo) \u0026\u0026 RT.get(((IExceptionInfo) t).getData(), SPEC_PROBLEMS) !\u003d null;\n+\t}\n+\n \tpublic String toString(){\n \t\tThrowable cause \u003d getCause();\n \t\tif(cause !\u003d null) {\n-\t\t\tif (cause instanceof IExceptionInfo) {\n-\t\t\t\tIPersistentMap data \u003d (IPersistentMap)((IExceptionInfo)cause).getData();\n-\t\t\t\tif(PHASE_MACRO_SYNTAX_CHECK.equals(data.valAt(ERR_PHASE)) \u0026\u0026 data.valAt(SPEC_PROBLEMS) !\u003d null) {\n-\t\t\t\t\treturn String.format(\"%s\", getMessage());\n-\t\t\t\t} else {\n-\t\t\t\t\treturn String.format(\"%s%n%s\", getMessage(), cause.getMessage());\n-\t\t\t\t}\n+\t\t\tif(RT.get(data, ERR_PHASE) \u003d\u003d PHASE_MACRO_SYNTAX_CHECK \u0026\u0026 isSpecError(cause)) {\n+\t\t\t\treturn String.format(\"%s\", getMessage());\n+\t\t\t} else {\n+\t\t\t\treturn String.format(\"%s%n%s\", getMessage(), cause.getMessage());\n \t\t\t}\n+\t\t} else {\n+\t\t\treturn getMessage();\n \t\t}\n-\t\treturn getMessage();\n \t}\n }\n ","expectedMessage":"Revert \"CLJ-2427 CompilerException toString() throws when RT not yet initialized\"","repository":"clojure-hickey","commitHash":"88eca12e37d086e015e559a3adb6f0c9ea127878","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-35956188","diff":" src/clj/clojure/core_deftype.clj          | 23 +++++++++++++----------\n src/clj/clojure/datafy.clj                | 19 +++++++++----------\n src/jvm/clojure/lang/MethodImplCache.java | 11 +++++++----\n 3 files changed, 29 insertions(+), 24 deletions(-)\n\ndiff --git a/src/clj/clojure/core_deftype.clj b/src/clj/clojure/core_deftype.clj\nindex 73a4787..6df1734 100644\n--- a/src/clj/clojure/core_deftype.clj\n+++ b/src/clj/clojure/core_deftype.clj\n@@ -508,7 +508,7 @@\n (defn- expand-method-impl-cache [^clojure.lang.MethodImplCache cache c f]\n   (if (.map cache)\n     (let [cs (assoc (.map cache) c (clojure.lang.MethodImplCache$Entry. c f))]\n-      (clojure.lang.MethodImplCache. (.protocol cache) (.methodk cache) cs))\n+      (clojure.lang.MethodImplCache. (.sym cache) (.protocol cache) (.methodk cache) cs))\n     (let [cs (into1 {} (remove (fn [[c e]] (nil? e)) (map vec (partition 2 (.table cache)))))\n           cs (assoc cs c (clojure.lang.MethodImplCache$Entry. c f))]\n       (if-let [[shift mask] (maybe-min-hash (map hash (keys cs)))]\n@@ -519,8 +519,8 @@\n                                  (aset t (inc i) e)\n                                  t))\n                              table cs)]\n-          (clojure.lang.MethodImplCache. (.protocol cache) (.methodk cache) shift mask table))\n-        (clojure.lang.MethodImplCache. (.protocol cache) (.methodk cache) cs)))))\n+          (clojure.lang.MethodImplCache. (.sym cache) (.protocol cache) (.methodk cache) shift mask table))\n+        (clojure.lang.MethodImplCache. (.sym cache) (.protocol cache) (.methodk cache) cs)))))\n \n (defn- super-chain [^Class c]\n   (when c\n@@ -575,11 +575,11 @@\n (defn -cache-protocol-fn [^clojure.lang.AFunction pf x ^Class c ^clojure.lang.IFn interf]\n   (let [cache  (.__methodImplCache pf)\n         f (if (.isInstance c x)\n-            interf \n+            interf\n             (find-protocol-method (.protocol cache) (.methodk cache) x))]\n     (when-not f\n-      (throw (IllegalArgumentException. (str \"No implementation of method: \" (.methodk cache) \n-                                             \" of protocol: \" (:var (.protocol cache)) \n+            (throw (IllegalArgumentException. (str \"No implementation of method: \" (.methodk cache) \n+                                                   \" of protocol: \" (:var (.protocol cache)) \n                                              \" found for class: \" (if (nil? x) \"nil\" (.getName (class x)))))))\n     (set! (.__methodImplCache pf) (expand-method-impl-cache cache (class x) f))\n     f))\n@@ -607,16 +607,19 @@\n                       `([~@gargs]\n                           (let [cache# (.__methodImplCache ~gthis)\n                                 f# (.fnFor cache# (clojure.lang.Util/classOf ~target))]\n-                            (if f# \n-                              (f# ~@gargs)\n-                              ((-cache-protocol-fn ~gthis ~target ~on-interface ~ginterf) ~@gargs))))))\n+                            ((or\n+                              (when (identical? f# ~ginterf) f#)\n+                              (get (meta ~target) (.sym cache#))\n+                              f#\n+                              (-cache-protocol-fn ~gthis ~target ~on-interface ~ginterf))\n+                             ~@gargs)))))\n                   arglists))]\n          (set! (.__methodImplCache f#) cache#)\n          f#))))\n \n (defn -reset-methods [protocol]\n   (doseq [[^clojure.lang.Var v build] (:method-builders protocol)]\n-    (let [cache (clojure.lang.MethodImplCache. protocol (keyword (.sym v)))]\n+    (let [cache (clojure.lang.MethodImplCache. (symbol v) protocol (keyword (.sym v)))]\n       (.bindRoot v (build cache)))))\n \n (defn- assert-same-protocol [protocol-var method-syms]\ndiff --git a/src/clj/clojure/datafy.clj b/src/clj/clojure/datafy.clj\nindex fb5ca7f..f7dea11 100644\n--- a/src/clj/clojure/datafy.clj\n+++ b/src/clj/clojure/datafy.clj\n@@ -14,14 +14,14 @@\n (set! *warn-on-reflection* true)\n \n (defn datafy\n-  \"Attempts to return x as data. If :clojure.datafy/datafy is present\n-  as metadata of x, it will be called with x as an argument, else\n-  datafy will return the value of clojure.protocols/datafy. If the\n-  value has been transformed and the result supports\n+  \"Attempts to return x as data.\n+  datafy will return the value of clojure.core.protocols/datafy. If\n+  the value has been transformed and the result supports\n   metadata, :clojure.datafy/obj will be set on the metadata to the\n-  original value of x.\"\n+  original value of x, and :clojure.datafy/class to the name of the\n+  class of x, as a symbol.\"\n   [x]\n-  (let [v ((or (-\u003e x meta ::datafy) p/datafy) x)]\n+  (let [v (p/datafy x)]\n     (if (identical? v x)\n       v\n       (if (instance? clojure.lang.IObj v)\n@@ -32,11 +32,10 @@\n   \"Returns (possibly transformed) v in the context of coll and k (a\n   key/index or nil). Callers should attempt to provide the key/index\n   context k for Indexed/Associative/ILookup colls if possible, but not\n-  to fabricate one e.g. for sequences (pass nil). If :clojure.datafy/nav is\n-  present as metadata on coll, it will be called with coll, k and v as\n-  arguments, else nav will call :clojure.protocols/nav.\"\n+  to fabricate one e.g. for sequences (pass nil). nav returns the\n+  value of clojure.core.protocols/nav.\"\n   [coll k v]\n-  ((or (-\u003e coll meta ::nav) p/nav) coll k v))\n+  (p/nav coll k v))\n \n (defn- sortmap [m]\n   (into (sorted-map) m))\ndiff --git a/src/jvm/clojure/lang/MethodImplCache.java b/src/jvm/clojure/lang/MethodImplCache.java\nindex c445ef3..1599ed6 100644\n--- a/src/jvm/clojure/lang/MethodImplCache.java\n+++ b/src/jvm/clojure/lang/MethodImplCache.java\n@@ -27,6 +27,7 @@ static public class Entry{\n }\n \n public final IPersistentMap protocol;\n+public final Symbol sym;\n public final Keyword methodk;\n public final int shift;\n public final int mask;\n@@ -35,11 +36,12 @@ public final Map map;\n \n Entry mre \u003d null;\n \n-public MethodImplCache(IPersistentMap protocol, Keyword methodk){\n-\tthis(protocol, methodk, 0, 0, RT.EMPTY_ARRAY);\n+public MethodImplCache(Symbol sym,IPersistentMap protocol, Keyword methodk){\n+\tthis(sym, protocol, methodk, 0, 0, RT.EMPTY_ARRAY);\n }\n \n-public MethodImplCache(IPersistentMap protocol, Keyword methodk, int shift, int mask, Object[] table){\n+public MethodImplCache(Symbol sym, IPersistentMap protocol, Keyword methodk, int shift, int mask, Object[] table){\n+    this.sym \u003d sym;\n     this.protocol \u003d protocol;\n     this.methodk \u003d methodk;\n     this.shift \u003d shift;\n@@ -48,7 +50,8 @@ public MethodImplCache(IPersistentMap protocol, Keyword methodk, int shift, int\n     this.map \u003d null;\n }\n \n-public MethodImplCache(IPersistentMap protocol, Keyword methodk, Map map){\n+public MethodImplCache(Symbol sym, IPersistentMap protocol, Keyword methodk, Map map){\n+    this.sym \u003d sym;\n     this.protocol \u003d protocol;\n     this.methodk \u003d methodk;\n     this.shift \u003d 0;","expectedMessage":"initial protocols via metadata support. datafy no longer needs special metadata handling, use e.g. \u0027clojure.core.protocols/datafy as meta key","repository":"clojure-hickey","commitHash":"359561886c53252a07c7105fcd1189f3b7a52571","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-d29219f7","diff":" src/clj/clojure/core.clj | 40 ++++++++++++++++++++++++----------------\n 1 file changed, 24 insertions(+), 16 deletions(-)\n\ndiff --git a/src/clj/clojure/core.clj b/src/clj/clojure/core.clj\nindex 7885e1e..1b14f20 100644\n--- a/src/clj/clojure/core.clj\n+++ b/src/clj/clojure/core.clj\n@@ -571,12 +571,34 @@\n    :static true}\n   [x] (instance? clojure.lang.Keyword x))\n \n+(defmacro cond\n+  \"Takes a set of test/expr pairs. It evaluates each test one at a\n+  time.  If a test returns logical true, cond evaluates and returns\n+  the value of the corresponding expr and doesn\u0027t evaluate any of the\n+  other tests or exprs. (cond) returns nil.\"\n+  {:added \"1.0\"}\n+  [\u0026 clauses]\n+    (when clauses\n+      (list \u0027if (first clauses)\n+            (if (next clauses)\n+                (second clauses)\n+                (throw (IllegalArgumentException.\n+                         \"cond requires an even number of forms\")))\n+            (cons \u0027clojure.core/cond (next (next clauses))))))\n+\n (defn symbol\n-  \"Returns a Symbol with the given namespace and name.\"\n+  \"Returns a Symbol with the given namespace and name. Arity-1 works\n+  on strings, keywords, and vars.\"\n   {:tag clojure.lang.Symbol\n    :added \"1.0\"\n    :static true}\n-  ([name] (if (symbol? name) name (clojure.lang.Symbol/intern name)))\n+  ([name]\n+     (cond\n+      (symbol? name) name\n+      (instance? String name) (clojure.lang.Symbol/intern name)\n+      (instance? clojure.lang.Var name) (.toSymbol ^clojure.lang.Var name)\n+      (instance? clojure.lang.Keyword name) (.sym ^clojure.lang.Keyword name)\n+      :else (throw (IllegalArgumentException. \"no conversion to symbol\"))))\n   ([ns name] (clojure.lang.Symbol/intern ns name)))\n \n (defn gensym\n@@ -588,20 +610,6 @@\n   ([] (gensym \"G__\"))\n   ([prefix-string] (. clojure.lang.Symbol (intern (str prefix-string (str (. clojure.lang.RT (nextID))))))))\n \n-(defmacro cond\n-  \"Takes a set of test/expr pairs. It evaluates each test one at a\n-  time.  If a test returns logical true, cond evaluates and returns\n-  the value of the corresponding expr and doesn\u0027t evaluate any of the\n-  other tests or exprs. (cond) returns nil.\"\n-  {:added \"1.0\"}\n-  [\u0026 clauses]\n-    (when clauses\n-      (list \u0027if (first clauses)\n-            (if (next clauses)\n-                (second clauses)\n-                (throw (IllegalArgumentException.\n-                         \"cond requires an even number of forms\")))\n-            (cons \u0027clojure.core/cond (next (next clauses))))))\n \n (defn keyword\n   \"Returns a Keyword with the given namespace and name.  Do not use :","expectedMessage":"make \u0027symbol\u0027 work on keywords and vars","repository":"clojure-hickey","commitHash":"d29219f78e51da66daf1c66108ebebb97c68442f","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-c85182d0","diff":" src/clj/clojure/datafy.clj | 25 ++++++++++++++++---------\n 1 file changed, 16 insertions(+), 9 deletions(-)","expectedMessage":"Merge branch \u0027datafy\u0027","repository":"clojure-hickey","commitHash":"c85182d0bc18b33221a0fab9b059a985356311c9","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-ff081f08","diff":" src/clj/clojure/datafy.clj | 25 ++++++++++++++++---------\n 1 file changed, 16 insertions(+), 9 deletions(-)\n\ndiff --git a/src/clj/clojure/datafy.clj b/src/clj/clojure/datafy.clj\nindex ae53eab..fb5ca7f 100644\n--- a/src/clj/clojure/datafy.clj\n+++ b/src/clj/clojure/datafy.clj\n@@ -11,6 +11,8 @@\n   (:require [clojure.core.protocols :as p]\n             [clojure.reflect :as refl]))\n \n+(set! *warn-on-reflection* true)\n+\n (defn datafy\n   \"Attempts to return x as data. If :clojure.datafy/datafy is present\n   as metadata of x, it will be called with x as an argument, else\n@@ -23,7 +25,7 @@\n     (if (identical? v x)\n       v\n       (if (instance? clojure.lang.IObj v)\n-        (vary-meta v assoc ::obj x)\n+        (vary-meta v assoc ::obj x ::class (-\u003e x class .getName symbol))\n         v))))\n \n (defn nav\n@@ -41,17 +43,22 @@\n \n (extend-protocol p/Datafiable\n   Throwable\n-  (datafy [x] (Throwable-\u003emap x))\n+  (datafy [x]\n+          (Throwable-\u003emap x))\n   \n   clojure.lang.IRef\n-  (datafy [r] (with-meta [(deref r)] (meta r)))\n+  (datafy [r]\n+          (with-meta [(deref r)] (meta r)))\n \n   clojure.lang.Namespace\n-  (datafy [n] (with-meta {:publics (-\u003e n ns-publics sortmap)\n-                          :imports (-\u003e n ns-imports sortmap)\n-                          :interns (-\u003e n ns-interns sortmap)}\n-                (meta n)))\n+  (datafy [n]\n+          (with-meta {:name (.getName n)\n+                      :publics (-\u003e n ns-publics sortmap)\n+                      :imports (-\u003e n ns-imports sortmap)\n+                      :interns (-\u003e n ns-interns sortmap)}\n+            (meta n)))\n \n   java.lang.Class\n-  (datafy [c] (let [{:keys [members] :as ret} (refl/reflect c)]\n-                (assoc ret :members (-\u003e\u003e members (group-by :name) sortmap)))))\n\\ No newline at end of file\n+  (datafy [c]\n+          (let [{:keys [members] :as ret} (refl/reflect c)]\n+            (assoc ret :name (-\u003e c .getName symbol) :members (-\u003e\u003e members (group-by :name) sortmap)))))\n\\ No newline at end of file","expectedMessage":"add :name to datafied classes and nses, :class to meta of all datafied","repository":"clojure-hickey","commitHash":"ff081f0810b6a54cb9fc2fa726ae06a3c0ade7f4","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-00d03ba6","diff":" src/clj/clojure/datafy.clj | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/src/clj/clojure/datafy.clj b/src/clj/clojure/datafy.clj\nindex 7aee705..ae53eab 100644\n--- a/src/clj/clojure/datafy.clj\n+++ b/src/clj/clojure/datafy.clj\n@@ -40,6 +40,9 @@\n   (into (sorted-map) m))\n \n (extend-protocol p/Datafiable\n+  Throwable\n+  (datafy [x] (Throwable-\u003emap x))\n+  \n   clojure.lang.IRef\n   (datafy [r] (with-meta [(deref r)] (meta r)))\n ","expectedMessage":"datafy Throwables","repository":"clojure-hickey","commitHash":"00d03ba6be2b52ada993ea2d45d31a315789d453","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-93841c0d","diff":" build.xml                          |  1 +\n src/clj/clojure/core/protocols.clj | 18 +++++++++++++\n src/clj/clojure/datafy.clj         | 54 ++++++++++++++++++++++++++++++++++++++\n 3 files changed, 73 insertions(+)\n\ndiff --git a/build.xml b/build.xml\nindex 4a3291b..4d29bbf 100644\n--- a/build.xml\n+++ b/build.xml\n@@ -81,6 +81,7 @@\n       \u003carg value\u003d\"clojure.string\"/\u003e\n       \u003carg value\u003d\"clojure.data\"/\u003e\n       \u003carg value\u003d\"clojure.reflect\"/\u003e\n+      \u003carg value\u003d\"clojure.datafy\"/\u003e\n     \u003c/java\u003e\n   \u003c/target\u003e\n \ndiff --git a/src/clj/clojure/core/protocols.clj b/src/clj/clojure/core/protocols.clj\nindex e3bedb2..be72057 100644\n--- a/src/clj/clojure/core/protocols.clj\n+++ b/src/clj/clojure/core/protocols.clj\n@@ -178,3 +178,21 @@\n    entries. Called by clojure.core/reduce-kv, and has same\n    semantics (just different arg order).\"\n   (kv-reduce [amap f init]))\n+\n+(defprotocol Datafiable\n+  (datafy [o] \"return a representation of o as data (default identity)\"))\n+\n+(extend-protocol Datafiable\n+  nil\n+  (datafy [_] nil)\n+\n+  Object\n+  (datafy [x] x))\n+\n+(defprotocol Navigable\n+  (nav [coll k v] \"return (possibly transformed) v in the context of coll and k (a key/index or nil),\n+defaults to returning v.\"))\n+\n+(extend-protocol Navigable\n+  Object\n+  (nav [_ _ x] x))\ndiff --git a/src/clj/clojure/datafy.clj b/src/clj/clojure/datafy.clj\nnew file mode 100644\nindex 0000000..7aee705\n--- /dev/null\n+++ b/src/clj/clojure/datafy.clj\n@@ -0,0 +1,54 @@\n+;   Copyright (c) Rich Hickey. All rights reserved.\n+;   The use and distribution terms for this software are covered by the\n+;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n+;   which can be found in the file epl-v10.html at the root of this distribution.\n+;   By using this software in any fashion, you are agreeing to be bound by\n+;   the terms of this license.\n+;   You must not remove this notice, or any other, from this software.\n+\n+(ns clojure.datafy\n+  ^{:doc \"Functions to turn objects into data. Alpha, subject to change\"}\n+  (:require [clojure.core.protocols :as p]\n+            [clojure.reflect :as refl]))\n+\n+(defn datafy\n+  \"Attempts to return x as data. If :clojure.datafy/datafy is present\n+  as metadata of x, it will be called with x as an argument, else\n+  datafy will return the value of clojure.protocols/datafy. If the\n+  value has been transformed and the result supports\n+  metadata, :clojure.datafy/obj will be set on the metadata to the\n+  original value of x.\"\n+  [x]\n+  (let [v ((or (-\u003e x meta ::datafy) p/datafy) x)]\n+    (if (identical? v x)\n+      v\n+      (if (instance? clojure.lang.IObj v)\n+        (vary-meta v assoc ::obj x)\n+        v))))\n+\n+(defn nav\n+  \"Returns (possibly transformed) v in the context of coll and k (a\n+  key/index or nil). Callers should attempt to provide the key/index\n+  context k for Indexed/Associative/ILookup colls if possible, but not\n+  to fabricate one e.g. for sequences (pass nil). If :clojure.datafy/nav is\n+  present as metadata on coll, it will be called with coll, k and v as\n+  arguments, else nav will call :clojure.protocols/nav.\"\n+  [coll k v]\n+  ((or (-\u003e coll meta ::nav) p/nav) coll k v))\n+\n+(defn- sortmap [m]\n+  (into (sorted-map) m))\n+\n+(extend-protocol p/Datafiable\n+  clojure.lang.IRef\n+  (datafy [r] (with-meta [(deref r)] (meta r)))\n+\n+  clojure.lang.Namespace\n+  (datafy [n] (with-meta {:publics (-\u003e n ns-publics sortmap)\n+                          :imports (-\u003e n ns-imports sortmap)\n+                          :interns (-\u003e n ns-interns sortmap)}\n+                (meta n)))\n+\n+  java.lang.Class\n+  (datafy [c] (let [{:keys [members] :as ret} (refl/reflect c)]\n+                (assoc ret :members (-\u003e\u003e members (group-by :name) sortmap)))))\n\\ No newline at end of file","expectedMessage":"first cut of datafy","repository":"clojure-hickey","commitHash":"93841c0dbf9db2f358474408d5e21530f49ef8b3","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-08e592f4","diff":" src/clj/clojure/core.clj | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/clj/clojure/core.clj b/src/clj/clojure/core.clj\nindex 7f25cc4..dc6d29f 100644\n--- a/src/clj/clojure/core.clj\n+++ b/src/clj/clojure/core.clj\n@@ -3763,7 +3763,7 @@\n   \"Like read, and taking the same args. stream must be a LineNumberingPushbackReader.\n   Returns a vector containing the object read and the (whitespace-trimmed) string read.\"\n   {:added \"1.10\"}\n-  ([] (read+string *out*))\n+  ([] (read+string *in*))\n   ([^clojure.lang.LineNumberingPushbackReader stream \u0026 args]\n      (try\n        (.captureString stream)","expectedMessage":"*in*","repository":"clojure-hickey","commitHash":"08e592f4decbaa08de570ded9ac169785b1608f9","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-86a158d0","diff":" src/clj/clojure/core.clj                           |  55 ++++++++\n src/clj/clojure/core/server.clj                    | 139 ++++++++++++++++++++-\n src/clj/clojure/core_print.clj                     |  24 ++++\n .../clojure/lang/LineNumberingPushbackReader.java  |   2 +-\n 4 files changed, 214 insertions(+), 6 deletions(-)\n\ndiff --git a/src/clj/clojure/core.clj b/src/clj/clojure/core.clj\nindex 5fe3b1b..7f25cc4 100644\n--- a/src/clj/clojure/core.clj\n+++ b/src/clj/clojure/core.clj\n@@ -3759,6 +3759,21 @@\n   ([opts stream]\n    (. clojure.lang.LispReader (read stream opts))))\n \n+(defn read+string\n+  \"Like read, and taking the same args. stream must be a LineNumberingPushbackReader.\n+  Returns a vector containing the object read and the (whitespace-trimmed) string read.\"\n+  {:added \"1.10\"}\n+  ([] (read+string *out*))\n+  ([^clojure.lang.LineNumberingPushbackReader stream \u0026 args]\n+     (try\n+       (.captureString stream)\n+       (let [o (apply read stream args)\n+             s (.trim (.getString stream))]\n+         [o s])       \n+       (catch Throwable ex\n+         (.getString stream)\n+         (throw ex)))))\n+\n (defn read-line\n   \"Reads the next line from stream that is the current value of *in* .\"\n   {:added \"1.0\"\n@@ -7766,3 +7781,43 @@\n   \"Return true if x is a java.net.URI\"\n   {:added \"1.9\"}\n   [x] (instance? java.net.URI x))\n+\n+(defonce ^:private tapset (atom #{}))\n+(defonce ^:private ^java.util.concurrent.ArrayBlockingQueue tapq (java.util.concurrent.ArrayBlockingQueue. 1024))\n+\n+(defn add-tap\n+  \"adds f, a fn of one argument, to the tap set. This function will be called with anything sent via tap\u003e.\n+  This function may (briefly) block (e.g. for streams), and will never impede calls to tap\u003e,\n+  but blocking indefinitely may cause tap values to be dropped.\n+  Remember f in order to remove-tap\"\n+  {:added \"1.10\"}\n+  [f]\n+  (swap! tapset conj f)\n+  nil)\n+\n+(defn remove-tap\n+  \"remove f from the tap set the tap set.\"\n+  {:added \"1.10\"}\n+  [f]\n+  (swap! tapset disj f)\n+  nil)\n+\n+(defn tap\u003e\n+  \"sends x to any taps. Will not block. Returns true if there was room in the queue,\n+  false if not (dropped).\"\n+  {:added \"1.10\"}\n+  [x]\n+  (.offer tapq x))\n+\n+(defonce ^:private tap-loop\n+  (doto (Thread.\n+         #(let [x (.take tapq)\n+                taps @tapset]\n+            (doseq [tap taps]\n+              (try\n+                (tap x)\n+                (catch Throwable ex)))\n+            (recur))\n+         \"clojure.core/tap-loop\")\n+    (.setDaemon true)\n+    (.start)))\ndiff --git a/src/clj/clojure/core/server.clj b/src/clj/clojure/core/server.clj\nindex 8bcf362..72f5385 100644\n--- a/src/clj/clojure/core/server.clj\n+++ b/src/clj/clojure/core/server.clj\n@@ -12,8 +12,11 @@\n   (:require [clojure.string :as str]\n             [clojure.edn :as edn]\n             [clojure.main :as m])\n-  (:import [java.net InetAddress Socket ServerSocket SocketException]\n-           [java.util.concurrent.locks ReentrantLock]))\n+  (:import\n+   [clojure.lang LineNumberingPushbackReader]\n+   [java.net InetAddress Socket ServerSocket SocketException]\n+   [java.io Reader Writer PrintWriter BufferedWriter BufferedReader InputStreamReader OutputStreamWriter]\n+   [java.util.concurrent.locks ReentrantLock]))\n \n (set! *warn-on-reflection* true)\n \n@@ -106,8 +109,8 @@\n           (when (not (.isClosed socket))\n             (try\n               (let [conn (.accept socket)\n-                    in (clojure.lang.LineNumberingPushbackReader. (java.io.InputStreamReader. (.getInputStream conn)))\n-                    out (java.io.BufferedWriter. (java.io.OutputStreamWriter. (.getOutputStream conn)))\n+                    in (LineNumberingPushbackReader. (InputStreamReader. (.getInputStream conn)))\n+                    out (BufferedWriter. (OutputStreamWriter. (.getOutputStream conn)))\n                     client-id (str client-counter)]\n                 (thread\n                   (str \"Clojure Connection \" name \" \" client-id) client-daemon\n@@ -179,4 +182,130 @@\n   []\n   (m/repl\n     :init repl-init\n-    :read repl-read))\n\\ No newline at end of file\n+    :read repl-read))\n+\n+(defn prepl\n+  \"a REPL with structured output (for programs)\n+  reads forms to eval from in-reader (a LineNumberingPushbackReader)\n+  Closing the input or passing the form :repl/quit will cause it to return\n+\n+  Calls out-fn with data, one of:\n+  {:tag :ret\n+   :val val ;;eval result\n+   :ns ns-name-string\n+   :ms long ;;eval time in milliseconds\n+   :form string ;;iff successfully read\n+  }\n+  {:tag :out\n+   :val string} ;chars from during-eval *out*\n+  {:tag :err\n+   :val string} ;chars from during-eval *err*\n+  {:tag :tap\n+   :val val} ;values from tap\u003e\n+\n+  You might get more than one :out or :err per eval, but exactly one :ret\n+  tap output can happen at any time (i.e. between evals)\n+  If during eval an attempt is made to read *in* it will read from in-reader unless :stdin is supplied\n+\"\n+  [in-reader out-fn \u0026 {:keys [stdin]}]\n+  (let [EOF (Object.)\n+        tapfn #(out-fn {:tag :tap :val %1})]\n+    (m/with-bindings\n+      (in-ns \u0027user)\n+      (binding [*in* (or stdin in-reader)\n+                *out* (PrintWriter-on #(out-fn {:tag :out :val %1}) nil)\n+                *err* (PrintWriter-on #(out-fn {:tag :err :val %1}) nil)]\n+        (try\n+          (add-tap tapfn)\n+          (loop []\n+            (when (try\n+                    (let [[form s] (read+string in-reader false EOF)]\n+                      (try\n+                        (when-not (identical? form EOF)\n+                          (let [start (System/nanoTime)\n+                                ret (eval form)\n+                                ms (quot (- (System/nanoTime) start) 1000000)]\n+                            (when-not (\u003d :repl/quit ret)\n+                              (set! *3 *2)\n+                              (set! *2 *1)\n+                              (set! *1 ret)\n+                              (out-fn {:tag :ret\n+                                       :val (if (instance? Throwable ret)\n+                                              (Throwable-\u003emap ret)\n+                                              ret)\n+                                       :ns (str (.name *ns*))\n+                                       :ms ms\n+                                       :form s})\n+                              true)))\n+                        (catch Throwable ex\n+                          (set! *e ex)\n+                          (out-fn {:tag :ret :val (Throwable-\u003emap ex) :ns (str (.name *ns*)) :form s})\n+                          true)))\n+                    (catch Throwable ex\n+                      (set! *e ex)\n+                      (out-fn {:tag :ret :val (Throwable-\u003emap ex) :ns (str (.name *ns*))})\n+                      true))\n+              (recur)))\n+          (finally\n+           (remove-tap tapfn)))))))\n+\n+(defn- resolve-fn [valf]\n+  (if (symbol? valf)\n+    (or (resolve valf)\n+        (when-let [nsname (namespace valf)]\n+          (require (symbol nsname))\n+          (resolve valf))\n+        (throw (Exception. (str \"can\u0027t resolve: \" valf))))\n+    valf))\n+\n+(defn io-prepl\n+  \"prepl bound to *in* and *out*, suitable for use with e.g. server/repl (socket-repl).\n+  :ret and :tap vals will be processed by valf, a fn of one argument\n+  or a symbol naming same (default pr-str)\"\n+  [\u0026 {:keys [valf] :or {valf pr-str}}]\n+  (let [valf (resolve-fn valf)\n+        out *out*\n+        lock (Object.)]\n+    (prepl *in*\n+           #(binding [*out* out, *flush-on-newline* true, *print-readably* true]\n+              (locking lock\n+                (prn (cond-\u003e %1\n+                             (#{:ret :tap} (:tag %1))\n+                             (assoc :val (valf (:val %1))))))))))\n+\n+(defn remote-prepl\n+  \"Implements a prepl on in-reader and out-fn by forwarding to a\n+  remote [io-]prepl over a socket.  Messages will be read by readf, a\n+  fn of a LineNumberingPushbackReader and EOF value or a symbol naming\n+  same (default #(read %1 false %2)),\n+  :ret and :tap vals will be processed by valf, a fn of one argument\n+  or a symbol naming same (default read-string). If that function\n+  throws, :val will be unprocessed.\"\n+  [^String host port ^Reader\n+  in-reader out-fn \u0026 {:keys [valf readf] :or {valf read-string, readf #(read %1 false %2)}}]\n+  (let [valf (resolve-fn valf)\n+        readf (resolve-fn readf)\n+        ^long port (if (string? port) (Integer/valueOf ^String port) port)\n+        socket (Socket. host port)\n+        rd (-\u003e socket .getInputStream InputStreamReader. BufferedReader. LineNumberingPushbackReader.)\n+        wr (-\u003e socket .getOutputStream OutputStreamWriter.)\n+        EOF (Object.)]\n+    (thread \"clojure.core.server/remote-prepl\" true\n+            (try (loop []\n+                   (let [{:keys [tag val] :as m} (readf rd EOF)]\n+                     (when-not (identical? m EOF)\n+                       (out-fn (cond-\u003e m\n+                                       (#{:ret :tap} tag)\n+                                       (assoc :val (try (valf val) (catch Throwable ex val)))))\n+                       (recur))))\n+                 (finally\n+                  (.close wr))))\n+    (let [buf (char-array 1024)]\n+      (try (loop []\n+             (let [n (.read in-reader buf)]\n+               (when-not (\u003d n -1)\n+                 (.write wr buf 0 n)\n+                 (.flush wr)\n+                 (recur))))\n+           (finally\n+            (.close rd))))))\ndiff --git a/src/clj/clojure/core_print.clj b/src/clj/clojure/core_print.clj\nindex 1b2b7a5..45d27da 100644\n--- a/src/clj/clojure/core_print.clj\n+++ b/src/clj/clojure/core_print.clj\n@@ -545,3 +545,27 @@\n   (print-method (:form o) w))\n \n (def ^{:private true} print-initialized true)\n+\n+(defn ^java.io.PrintWriter PrintWriter-on\n+  \"implements java.io.PrintWriter given flush-fn, which will be called\n+  when .flush() is called, with a string built up since the last call to .flush().\n+  if not nil, close-fn will be called with no arguments when .close is called\"\n+  {:added \"1.10\"}\n+  [flush-fn close-fn]\n+  (let [sb (StringBuilder.)]\n+    (-\u003e (proxy [Writer] []\n+          (flush []\n+                 (when (pos? (.length sb))\n+                   (flush-fn (.toString sb)))\n+                 (.setLength sb 0))\n+          (close []\n+                 (.flush ^Writer this)\n+                 (when close-fn (close-fn))\n+                 nil)\n+          (write [str-cbuf off len]\n+                 (when (pos? len)\n+                   (if (instance? String str-cbuf)\n+                     (.append sb ^String str-cbuf ^int off ^int len)\n+                     (.append sb ^chars str-cbuf ^int off ^int len)))))\n+        java.io.BufferedWriter.\n+        java.io.PrintWriter.)))\ndiff --git a/src/jvm/clojure/lang/LineNumberingPushbackReader.java b/src/jvm/clojure/lang/LineNumberingPushbackReader.java\nindex 37640cf..a761c44 100644\n--- a/src/jvm/clojure/lang/LineNumberingPushbackReader.java\n+++ b/src/jvm/clojure/lang/LineNumberingPushbackReader.java\n@@ -75,7 +75,7 @@ public int read() throws IOException{\n         _atLineStart \u003d false;\n         _columnNumber++;\n         }\n-    if(sb !\u003d null)\n+    if(sb !\u003d null \u0026\u0026 c !\u003d -1)\n         sb.append((char)c);\n     return c;\n }","expectedMessage":"first cut of prepl","repository":"clojure-hickey","commitHash":"86a158d0e0718f5c93f9f2bb71e26bc794e7d58e","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-537d5ebd","diff":" .../clojure/lang/LineNumberingPushbackReader.java  | 67 ++++++++++++++--------\n 1 file changed, 43 insertions(+), 24 deletions(-)\n\ndiff --git a/src/jvm/clojure/lang/LineNumberingPushbackReader.java b/src/jvm/clojure/lang/LineNumberingPushbackReader.java\nindex 47067e9..a774f00 100644\n--- a/src/jvm/clojure/lang/LineNumberingPushbackReader.java\n+++ b/src/jvm/clojure/lang/LineNumberingPushbackReader.java\n@@ -27,46 +27,65 @@ private static final int newline \u003d (int) \u0027\\n\u0027;\n \n private boolean _atLineStart \u003d true;\n private boolean _prev;\n-private int _columnNumber \u003d 1;\n+private int _columnNumber \u003d 1;\n+private StringBuilder sb \u003d null;\n \n public LineNumberingPushbackReader(Reader r){\n \tsuper(new LineNumberReader(r));\n }\n \n-public LineNumberingPushbackReader(Reader r, int size){\n-\tsuper(new LineNumberReader(r, size));\n-}\n-\n+public LineNumberingPushbackReader(Reader r, int size){\n+\tsuper(new LineNumberReader(r, size));\n+}\n+\n public int getLineNumber(){\n \treturn ((LineNumberReader) in).getLineNumber() + 1;\n }\n-\n-public void setLineNumber(int line) { ((LineNumberReader) in).setLineNumber(line - 1); }\n-\n-public int getColumnNumber(){\n-\treturn _columnNumber;\n-}\n-\n+\n+public void setLineNumber(int line) { ((LineNumberReader) in).setLineNumber(line - 1); }\n+\n+public void captureString(){\n+    this.sb \u003d new StringBuilder();\n+}\n+\n+public String getString(){\n+    if(sb !\u003d null)\n+        {\n+        String ret \u003d sb.toString();\n+        sb \u003d null;\n+        return ret;\n+        }\n+    return null;\n+}\n+\n+public int getColumnNumber(){\n+\treturn _columnNumber;\n+}\n+\n public int read() throws IOException{\n     int c \u003d super.read();\n     _prev \u003d _atLineStart;\n-    if((c \u003d\u003d newline) || (c \u003d\u003d -1))\n-        {\n-        _atLineStart \u003d true;\n-        _columnNumber \u003d 1;\n-        }\n-    else\n-        {\n-        _atLineStart \u003d false;\n-        _columnNumber++;\n-        }\n+    if((c \u003d\u003d newline) || (c \u003d\u003d -1))\n+        {\n+        _atLineStart \u003d true;\n+        _columnNumber \u003d 1;\n+        }\n+    else\n+        {\n+        _atLineStart \u003d false;\n+        _columnNumber++;\n+        }\n+    if(sb !\u003d null)\n+        sb.append((char)c);\n     return c;\n }\n \n public void unread(int c) throws IOException{\n     super.unread(c);\n     _atLineStart \u003d _prev;\n-    _columnNumber--;\n+    _columnNumber--;\n+    if(sb !\u003d null)\n+        sb.deleteCharAt(sb.length()-1);\n }\n \n public String readLine() throws IOException{\n@@ -85,7 +104,7 @@ public String readLine() throws IOException{\n         line \u003d (rest \u003d\u003d null) ? first : first + rest;\n         _prev \u003d false;\n         _atLineStart \u003d true;\n-        _columnNumber \u003d 1;\n+        _columnNumber \u003d 1;\n         break;\n     }\n     return line;","expectedMessage":"added string capture mode to LNPReader","repository":"clojure-hickey","commitHash":"537d5ebd20174cc7249af5b6d0c42d75ed48d381","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-b7756a64","diff":" src/jvm/clojure/lang/RT.java | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/jvm/clojure/lang/RT.java b/src/jvm/clojure/lang/RT.java\nindex 6723298..e044e88 100644\n--- a/src/jvm/clojure/lang/RT.java\n+++ b/src/jvm/clojure/lang/RT.java\n@@ -36,7 +36,7 @@ static final public Boolean F \u003d Boolean.FALSE;//Keyword.intern(Symbol.intern(nul\n static final public String LOADER_SUFFIX \u003d \"__init\";\n \n //simple-symbol-\u003eclass\n-final static IPersistentMap DEFAULT_IMPORTS \u003d map(\n+final static public IPersistentMap DEFAULT_IMPORTS \u003d map(\n //\t\t\t\t\t\t\t\t\t\t\t\t  Symbol.intern(\"RT\"), \"clojure.lang.RT\",\n //                                                  Symbol.intern(\"Num\"), \"clojure.lang.Num\",\n //                                                  Symbol.intern(\"Symbol\"), \"clojure.lang.Symbol\",","expectedMessage":"make default imports public","repository":"clojure-hickey","commitHash":"b7756a64b0707b2a8f4ce23ef7d994410083faa9","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-c569e587","diff":" src/jvm/clojure/lang/LispReader.java | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/jvm/clojure/lang/LispReader.java b/src/jvm/clojure/lang/LispReader.java\nindex 82c1074..588dcd6 100644\n--- a/src/jvm/clojure/lang/LispReader.java\n+++ b/src/jvm/clojure/lang/LispReader.java\n@@ -1009,7 +1009,7 @@ public static class SyntaxQuoteReader extends AFn{\n             else if(resolver !\u003d null)\n                 {\n                 Symbol nsym \u003d null;\n-                if(sym.ns !\u003d null \u0026\u0026 sym.ns.indexOf(\u0027.\u0027) \u003d\u003d -1){\n+                if(sym.ns !\u003d null){\n                     Symbol alias \u003d Symbol.intern(null, sym.ns);\n                     nsym \u003d resolver.resolveClass(alias);\n                     if(nsym \u003d\u003d null)","expectedMessage":"don\u0027t preclude \u0027.\u0027 in alias","repository":"clojure-hickey","commitHash":"c569e5874c298a18ca9ce5fbe5133c963bf0f6b3","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
{"id":"clojure-hickey-cfe6d14b","diff":" src/jvm/clojure/lang/LispReader.java | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a/src/jvm/clojure/lang/LispReader.java b/src/jvm/clojure/lang/LispReader.java\nindex c331ac8..82c1074 100644\n--- a/src/jvm/clojure/lang/LispReader.java\n+++ b/src/jvm/clojure/lang/LispReader.java\n@@ -1025,8 +1025,10 @@ public static class SyntaxQuoteReader extends AFn{\n                         rsym \u003d resolver.resolveVar(sym);\n                     if(rsym !\u003d null)\n                         sym \u003d rsym;\n+                    else\n+                        sym \u003d Symbol.intern(resolver.currentNS().name,sym.name);\n                 }\n-                //leave alone if no resolution\n+                //leave alone if qualified\n                 }\n \t\t\telse\n \t\t\t\t{","expectedMessage":"default qualify with resovler.currentNS() in syntax quote","repository":"clojure-hickey","commitHash":"cfe6d14be41f47c91f63955910709c10f487f39e","metadata":{"author":"Rich Hickey \u003crichhickey@gmail.com\u003e"}}
