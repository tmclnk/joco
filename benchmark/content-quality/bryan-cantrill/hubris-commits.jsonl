{"id":"hubris-cantrill-12f3b213","diff":" app/gimlet/base.toml              |   2 +-\n app/gimletlet/app.toml            |  25 ++++\n drv/i2c-devices/src/adm1272.rs    |   6 +-\n drv/i2c-devices/src/adt7420.rs    |   2 +-\n drv/i2c-devices/src/bmr491.rs     |  13 +-\n drv/i2c-devices/src/isl68224.rs   |  13 +-\n drv/i2c-devices/src/lib.rs        |   2 +\n drv/i2c-devices/src/lm5066.rs     | 246 ++++++++++++++++++++++++++++++++++++++\n drv/i2c-devices/src/raa229618.rs  |  13 +-\n drv/i2c-devices/src/sbrmi.rs      |   1 +\n task/power/src/bsp/gimletlet_2.rs |  12 +-\n task/power/src/main.rs            |  38 +++++-\n 12 files changed, 360 insertions(+), 13 deletions(-)\n\ndiff --git a/app/gimlet/base.toml b/app/gimlet/base.toml\nindex 31f4cdb..64f19d4 100644\n--- a/app/gimlet/base.toml\n+++ b/app/gimlet/base.toml\n@@ -147,7 +147,7 @@ max-sizes \u003d {flash \u003d 65536, ram \u003d 16384 }\n stacksize \u003d 3800\n start \u003d true\n task-slots \u003d [\"i2c_driver\", \"sensor\", \"gimlet_seq\"]\n-notifications \u003d [\"timer\", \"external_badness\"]\n+notifications \u003d [\"timer\"]\n \n [tasks.hiffy]\n name \u003d \"task-hiffy\"\ndiff --git a/app/gimletlet/app.toml b/app/gimletlet/app.toml\nindex 5d00583..d2b57de 100644\n--- a/app/gimletlet/app.toml\n+++ b/app/gimletlet/app.toml\n@@ -259,3 +259,28 @@ pins \u003d [\n     # SPI6 CS repurposed for debugging\n     { name \u003d \"DEBUG\", pin \u003d { port \u003d \"G\", pin \u003d 8, af \u003d 0, direction \u003d \"output\"}}\n ]\n+\n+#\n+# This device definition is only provided as a way to test this driver absent\n+# a larger board that has it; unless your Gimletlet is in a basement known\n+# to be roamed by a certain board-killing cat, it\u0027s unlikely to have this\n+# device attached!  (But other than the `power` task reporting it as being\n+# absent, there should be no harm to it being missing.)\n+#\n+[[config.i2c.devices]]\n+device \u003d \"lm5066\"\n+controller \u003d 4\n+address \u003d 0x16\n+description \u003d \"LM5066 evaluation board\"\n+power \u003d { rails \u003d [ \"LM5066_EVL_VOUT\" ] }\n+sensors \u003d { voltage \u003d 1, current \u003d 1, temperature \u003d 1 }\n+\n+[tasks.power]\n+name \u003d \"task-power\"\n+priority \u003d 6\n+max-sizes \u003d {flash \u003d 65536, ram \u003d 16384 }\n+stacksize \u003d 3800\n+start \u003d true\n+task-slots \u003d [\"i2c_driver\", \"sensor\"]\n+notifications \u003d [\"timer\"]\n+\ndiff --git a/drv/i2c-devices/src/adm1272.rs b/drv/i2c-devices/src/adm1272.rs\nindex 9fdb3d2..b2d05dc 100644\n--- a/drv/i2c-devices/src/adm1272.rs\n+++ b/drv/i2c-devices/src/adm1272.rs\n@@ -47,7 +47,9 @@ impl From\u003cError\u003e for ResponseCode {\n             Error::BadRead { code, .. } \u003d\u003e code,\n             Error::BadWrite { code, .. } \u003d\u003e code,\n             Error::BadValidation { code, .. } \u003d\u003e code,\n-            _ \u003d\u003e panic!(),\n+            Error::BadData { .. }\n+            | Error::InvalidData { .. }\n+            | Error::InvalidConfig \u003d\u003e ResponseCode::BadDeviceState,\n         }\n     }\n }\n@@ -85,7 +87,7 @@ enum Trace {\n     None,\n }\n \n-ringbuf!(Trace, 32, Trace::None);\n+ringbuf!(Trace, 8, Trace::None);\n \n impl Adm1272 {\n     pub fn new(device: \u0026I2cDevice, rsense: Ohms) -\u003e Self {\ndiff --git a/drv/i2c-devices/src/adt7420.rs b/drv/i2c-devices/src/adt7420.rs\nindex 1c72ad6..f4dc69c 100644\n--- a/drv/i2c-devices/src/adt7420.rs\n+++ b/drv/i2c-devices/src/adt7420.rs\n@@ -39,7 +39,7 @@ impl From\u003cError\u003e for ResponseCode {\n         match err {\n             Error::BadValidate { code } \u003d\u003e code,\n             Error::BadTempRead { code } \u003d\u003e code,\n-            _ \u003d\u003e panic!(),\n+            Error::BadID { .. } \u003d\u003e ResponseCode::BadDeviceState,\n         }\n     }\n }\ndiff --git a/drv/i2c-devices/src/bmr491.rs b/drv/i2c-devices/src/bmr491.rs\nindex a6470b5..defbcd6 100644\n--- a/drv/i2c-devices/src/bmr491.rs\n+++ b/drv/i2c-devices/src/bmr491.rs\n@@ -21,10 +21,19 @@ pub struct Bmr491 {\n \n #[derive(Debug)]\n pub enum Error {\n+    /// I2C error on PMBus read from device\n     BadRead { cmd: u8, code: ResponseCode },\n+\n+    /// I2C error on PMBus write to device\n     BadWrite { cmd: u8, code: ResponseCode },\n+\n+    /// Failed to parse PMBus data from device\n     BadData { cmd: u8 },\n+\n+    /// I2C error attempting to validate device\n     BadValidation { cmd: u8, code: ResponseCode },\n+\n+    /// PMBus data returned from device is invalid\n     InvalidData { err: pmbus::Error },\n }\n \n@@ -49,7 +58,9 @@ impl From\u003cError\u003e for ResponseCode {\n             Error::BadRead { code, .. } \u003d\u003e code,\n             Error::BadWrite { code, .. } \u003d\u003e code,\n             Error::BadValidation { code, .. } \u003d\u003e code,\n-            _ \u003d\u003e panic!(),\n+            Error::BadData { .. } | Error::InvalidData { .. } \u003d\u003e {\n+                ResponseCode::BadDeviceState\n+            }\n         }\n     }\n }\ndiff --git a/drv/i2c-devices/src/isl68224.rs b/drv/i2c-devices/src/isl68224.rs\nindex 8be08db..dbc4c97 100644\n--- a/drv/i2c-devices/src/isl68224.rs\n+++ b/drv/i2c-devices/src/isl68224.rs\n@@ -34,10 +34,19 @@ impl core::fmt::Display for Isl68224 {\n \n #[derive(Debug)]\n pub enum Error {\n+    /// I2C error on PMBus read from device\n     BadRead { cmd: u8, code: ResponseCode },\n+\n+    /// I2C error on PMBus write to device\n     BadWrite { cmd: u8, code: ResponseCode },\n+\n+    /// Failed to parse PMBus data from device\n     BadData { cmd: u8 },\n+\n+    /// I2C error attempting to validate device\n     BadValidation { cmd: u8, code: ResponseCode },\n+\n+    /// PMBus data returned from device is invalid\n     InvalidData { err: pmbus::Error },\n }\n \n@@ -56,7 +65,9 @@ impl From\u003cError\u003e for ResponseCode {\n             Error::BadRead { code, .. } \u003d\u003e code,\n             Error::BadWrite { code, .. } \u003d\u003e code,\n             Error::BadValidation { code, .. } \u003d\u003e code,\n-            _ \u003d\u003e panic!(),\n+            Error::BadData { .. } | Error::InvalidData { .. } \u003d\u003e {\n+                ResponseCode::BadDeviceState\n+            }\n         }\n     }\n }\ndiff --git a/drv/i2c-devices/src/lib.rs b/drv/i2c-devices/src/lib.rs\nindex a9b2d26..f35c4c3 100644\n--- a/drv/i2c-devices/src/lib.rs\n+++ b/drv/i2c-devices/src/lib.rs\n@@ -12,6 +12,7 @@\n //! - [`ds2482`]: DS2482-100 1-wire initiator\n //! - [`emc2305`]: EMC2305 fan driver\n //! - [`isl68224`]: ISL68224 power controller\n+//! - [`lm5066`]: LM5066 hot swap controller\n //! - [`ltc4282`]: LTC4282 high current hot swap controller\n //! - [`m24c02`]: M24C02 EEPROM, used in MWOCP68 power shelf\n //! - [`m2_hp_only`]: M.2 drive; identical to `nvme_bmc`, with the limitation\n@@ -238,6 +239,7 @@ pub mod bmr491;\n pub mod ds2482;\n pub mod emc2305;\n pub mod isl68224;\n+pub mod lm5066;\n pub mod ltc4282;\n pub mod m24c02;\n pub mod m2_hp_only;\ndiff --git a/drv/i2c-devices/src/lm5066.rs b/drv/i2c-devices/src/lm5066.rs\nnew file mode 100644\nindex 0000000..91654a1\n--- /dev/null\n+++ b/drv/i2c-devices/src/lm5066.rs\n@@ -0,0 +1,246 @@\n+// This Source Code Form is subject to the terms of the Mozilla Public\n+// License, v. 2.0. If a copy of the MPL was not distributed with this\n+// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n+\n+//! Driver for the LM5066 hot-swap controller\n+\n+use core::cell::Cell;\n+\n+use crate::{\n+    pmbus_validate, BadValidation, CurrentSensor, TempSensor, Validate,\n+    VoltageSensor,\n+};\n+use drv_i2c_api::*;\n+use num_traits::float::FloatCore;\n+use pmbus::commands::*;\n+use ringbuf::*;\n+use userlib::units::*;\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum Error {\n+    /// I2C error on PMBus read from device\n+    BadRead { cmd: u8, code: ResponseCode },\n+\n+    /// I2C error on PMBus write to device\n+    BadWrite { cmd: u8, code: ResponseCode },\n+\n+    /// Failed to parse PMBus data from device\n+    BadData { cmd: u8 },\n+\n+    /// I2C error attempting to validate device\n+    BadValidation { cmd: u8, code: ResponseCode },\n+\n+    /// PMBus data returned from device is invalid\n+    InvalidData { err: pmbus::Error },\n+\n+    /// Device setup is invalid\n+    InvalidDeviceSetup,\n+}\n+\n+impl From\u003cBadValidation\u003e for Error {\n+    fn from(value: BadValidation) -\u003e Self {\n+        Self::BadValidation {\n+            cmd: value.cmd,\n+            code: value.code,\n+        }\n+    }\n+}\n+\n+impl From\u003cpmbus::Error\u003e for Error {\n+    fn from(err: pmbus::Error) -\u003e Self {\n+        Error::InvalidData { err }\n+    }\n+}\n+\n+impl From\u003cError\u003e for ResponseCode {\n+    fn from(err: Error) -\u003e Self {\n+        match err {\n+            Error::BadRead { code, .. } \u003d\u003e code,\n+            Error::BadWrite { code, .. } \u003d\u003e code,\n+            Error::BadValidation { code, .. } \u003d\u003e code,\n+            Error::BadData { .. }\n+            | Error::InvalidData { .. }\n+            | Error::InvalidDeviceSetup \u003d\u003e ResponseCode::BadDeviceState,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+#[allow(dead_code)]\n+struct Coefficients {\n+    current: pmbus::Coefficients,\n+    power: pmbus::Coefficients,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum CurrentLimitStrap {\n+    /// CL pin is strapped to VDD, denoting the Low setting\n+    VDD,\n+    /// CL pin is strapped to GND (or left floating), denoting the high setting\n+    GND,\n+}\n+\n+pub struct Lm5066 {\n+    /// Underlying I2C device\n+    device: I2cDevice,\n+    /// Value of the rsense resistor, in milliohms\n+    rsense: i32,\n+    /// Sense of current limit pin\n+    cl: CurrentLimitStrap,\n+    /// Our (cached) coefficients\n+    coefficients: Cell\u003cOption\u003cCoefficients\u003e\u003e,\n+    /// Our (cached) device setup\n+    device_setup: Cell\u003cOption\u003clm5066::DEVICE_SETUP::CommandData\u003e\u003e,\n+}\n+\n+impl core::fmt::Display for Lm5066 {\n+    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c\u0027_\u003e) -\u003e core::fmt::Result {\n+        write!(f, \"lm5066: {}\", \u0026self.device)\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+enum Trace {\n+    CurrentCoefficients(pmbus::Coefficients),\n+    PowerCoefficients(pmbus::Coefficients),\n+    DeviceSetup(lm5066::DEVICE_SETUP::CommandData),\n+    None,\n+}\n+\n+ringbuf!(Trace, 8, Trace::None);\n+\n+impl Lm5066 {\n+    pub fn new(\n+        device: \u0026I2cDevice,\n+        rsense: Ohms,\n+        cl: CurrentLimitStrap,\n+    ) -\u003e Self {\n+        Self {\n+            device: *device,\n+            rsense: (rsense.0 * 1000.0).round() as i32,\n+            cl,\n+            coefficients: Cell::new(None),\n+            device_setup: Cell::new(None),\n+        }\n+    }\n+\n+    fn read_device_setup(\n+        \u0026self,\n+    ) -\u003e Result\u003clm5066::DEVICE_SETUP::CommandData, Error\u003e {\n+        if let Some(ref device_setup) \u003d self.device_setup.get() {\n+            return Ok(*device_setup);\n+        }\n+\n+        let device_setup \u003d pmbus_read!(self.device, lm5066::DEVICE_SETUP)?;\n+        ringbuf_entry!(Trace::DeviceSetup(device_setup));\n+        self.device_setup.set(Some(device_setup));\n+\n+        Ok(device_setup)\n+    }\n+\n+    ///\n+    /// The coefficients for the LM5066 depend on the value of the current\n+    /// sense resistor and the sense of the current limit (CL) strap.\n+    /// Unfortunately, DEVICE_SETUP will not tell us the physical sense of\n+    /// this strap; we rely on this information to be provided when the\n+    /// device is initialized.\n+    ///\n+    fn load_coefficients(\u0026self) -\u003e Result\u003cCoefficients, Error\u003e {\n+        use lm5066::DEVICE_SETUP::*;\n+\n+        if let Some(coefficients) \u003d self.coefficients.get() {\n+            return Ok(coefficients);\n+        }\n+\n+        let device_setup \u003d self.read_device_setup()?;\n+\n+        let setting \u003d device_setup\n+            .get_current_setting()\n+            .ok_or(Error::InvalidDeviceSetup)?;\n+\n+        let config \u003d device_setup\n+            .get_current_config()\n+            .ok_or(Error::InvalidDeviceSetup)?;\n+\n+        let cl \u003d match config {\n+            CurrentConfig::Pin \u003d\u003e self.cl,\n+            CurrentConfig::SMBus \u003d\u003e match setting {\n+                CurrentSetting::Low \u003d\u003e CurrentLimitStrap::VDD,\n+                CurrentSetting::High \u003d\u003e CurrentLimitStrap::GND,\n+            },\n+        };\n+\n+        //\n+        // From Table 43 of the LM5066 datasheet.  Note that the datasheet has\n+        // an admonishment about adjusting R to keep m to within a signed\n+        // 16-bit quantity (that is, no larger than 32767), but we actually\n+        // treat m as a 32-bit quantity so there is no need to clamp it here.\n+        // (At the maximum of 200 mΩ, m is well within a 32-bit quantity.)\n+        //\n+        let current \u003d match cl {\n+            CurrentLimitStrap::GND \u003d\u003e pmbus::Coefficients {\n+                m: 5405 * self.rsense,\n+                b: -600,\n+                R: -2,\n+            },\n+            CurrentLimitStrap::VDD \u003d\u003e pmbus::Coefficients {\n+                m: 10753 * self.rsense,\n+                b: -1200,\n+                R: -2,\n+            },\n+        };\n+\n+        ringbuf_entry!(Trace::CurrentCoefficients(current));\n+\n+        let power \u003d match cl {\n+            CurrentLimitStrap::GND \u003d\u003e pmbus::Coefficients {\n+                m: 605 * self.rsense,\n+                b: -8000,\n+                R: -3,\n+            },\n+            CurrentLimitStrap::VDD \u003d\u003e pmbus::Coefficients {\n+                m: 1204 * self.rsense,\n+                b: -6000,\n+                R: -3,\n+            },\n+        };\n+\n+        ringbuf_entry!(Trace::PowerCoefficients(power));\n+\n+        self.coefficients.set(Some(Coefficients { current, power }));\n+        Ok(self.coefficients.get().unwrap())\n+    }\n+\n+    pub fn i2c_device(\u0026self) -\u003e \u0026I2cDevice {\n+        \u0026self.device\n+    }\n+}\n+\n+impl Validate\u003cError\u003e for Lm5066 {\n+    fn validate(device: \u0026I2cDevice) -\u003e Result\u003cbool, Error\u003e {\n+        let expected \u003d b\"LM5066\\0\\0\";\n+        pmbus_validate(device, CommandCode::MFR_MODEL, expected)\n+            .map_err(Into::into)\n+    }\n+}\n+\n+impl TempSensor\u003cError\u003e for Lm5066 {\n+    fn read_temperature(\u0026self) -\u003e Result\u003cCelsius, Error\u003e {\n+        let temp \u003d pmbus_read!(self.device, lm5066::READ_TEMPERATURE_1)?;\n+        Ok(Celsius(temp.get()?.0))\n+    }\n+}\n+\n+impl CurrentSensor\u003cError\u003e for Lm5066 {\n+    fn read_iout(\u0026self) -\u003e Result\u003cAmperes, Error\u003e {\n+        let iout \u003d pmbus_read!(self.device, lm5066::MFR_READ_IIN)?;\n+        Ok(Amperes(iout.get(\u0026self.load_coefficients()?.current)?.0))\n+    }\n+}\n+\n+impl VoltageSensor\u003cError\u003e for Lm5066 {\n+    fn read_vout(\u0026self) -\u003e Result\u003cVolts, Error\u003e {\n+        let vout \u003d pmbus_read!(self.device, lm5066::READ_VOUT)?;\n+        Ok(Volts(vout.get()?.0))\n+    }\n+}\ndiff --git a/drv/i2c-devices/src/raa229618.rs b/drv/i2c-devices/src/raa229618.rs\nindex c4a47fa..adb30b4 100644\n--- a/drv/i2c-devices/src/raa229618.rs\n+++ b/drv/i2c-devices/src/raa229618.rs\n@@ -34,10 +34,19 @@ impl core::fmt::Display for Raa229618 {\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Error {\n+    /// I2C error on PMBus read from device\n     BadRead { cmd: u8, code: ResponseCode },\n+\n+    /// I2C error on PMBus write to device\n     BadWrite { cmd: u8, code: ResponseCode },\n+\n+    /// Failed to parse PMBus data from device\n     BadData { cmd: u8 },\n+\n+    /// I2C error attempting to validate device\n     BadValidation { cmd: u8, code: ResponseCode },\n+\n+    /// PMBus data returned from device is invalid\n     InvalidData { err: pmbus::Error },\n }\n \n@@ -56,7 +65,9 @@ impl From\u003cError\u003e for ResponseCode {\n             Error::BadRead { code, .. } \u003d\u003e code,\n             Error::BadWrite { code, .. } \u003d\u003e code,\n             Error::BadValidation { code, .. } \u003d\u003e code,\n-            _ \u003d\u003e panic!(),\n+            Error::BadData { .. } | Error::InvalidData { .. } \u003d\u003e {\n+                ResponseCode::BadDeviceState\n+            }\n         }\n     }\n }\ndiff --git a/drv/i2c-devices/src/sbrmi.rs b/drv/i2c-devices/src/sbrmi.rs\nindex ffab24a..a857708 100644\n--- a/drv/i2c-devices/src/sbrmi.rs\n+++ b/drv/i2c-devices/src/sbrmi.rs\n@@ -77,6 +77,7 @@ impl From\u003cError\u003e for ResponseCode {\n         match err {\n             Error::BadRegisterRead { code, .. } \u003d\u003e code,\n             Error::BadCpuidRead { code } \u003d\u003e code,\n+            Error::BadRdmsr { code } \u003d\u003e code,\n             _ \u003d\u003e ResponseCode::BadResponse,\n         }\n     }\ndiff --git a/task/power/src/bsp/gimletlet_2.rs b/task/power/src/bsp/gimletlet_2.rs\nindex 088b205..d0a762f 100644\n--- a/task/power/src/bsp/gimletlet_2.rs\n+++ b/task/power/src/bsp/gimletlet_2.rs\n@@ -9,11 +9,13 @@ use crate::{\n \n pub(crate) const CONTROLLER_CONFIG_LEN: usize \u003d 1;\n pub(crate) static CONTROLLER_CONFIG: [PowerControllerConfig;\n-    CONTROLLER_CONFIG_LEN] \u003d [\n-    // The DC2024 has 10 3mΩ current sense resistors in parallel (5 on each\n-    // channel), given a total current sense resistance of 300µΩ\n-    ltc4282_controller!(HotSwapQSFP, v12_out_100a, A2, Ohms(0.003 / 10.0)),\n-];\n+    CONTROLLER_CONFIG_LEN] \u003d [lm5066_controller!(\n+    HotSwap,\n+    lm5066_evl_vout,\n+    A2,\n+    Ohms(0.003),\n+    drv_i2c_devices::lm5066::CurrentLimitStrap::VDD\n+)];\n \n pub(crate) fn get_state() -\u003e PowerState {\n     PowerState::A2\ndiff --git a/task/power/src/main.rs b/task/power/src/main.rs\nindex 1bb578f..b80dbf6 100644\n--- a/task/power/src/main.rs\n+++ b/task/power/src/main.rs\n@@ -13,6 +13,7 @@\n use drv_i2c_devices::adm1272::*;\n use drv_i2c_devices::bmr491::*;\n use drv_i2c_devices::isl68224::*;\n+use drv_i2c_devices::lm5066::*;\n use drv_i2c_devices::ltc4282::*;\n use drv_i2c_devices::max5970::*;\n use drv_i2c_devices::mwocp68::*;\n@@ -87,6 +88,7 @@ enum DeviceChip {\n     Max5970(Ohms),\n     Mwocp68,\n     Ltc4282(Ohms),\n+    Lm5066(Ohms, CurrentLimitStrap),\n }\n \n struct PowerControllerConfig {\n@@ -113,6 +115,7 @@ enum Device {\n     Max5970(Max5970),\n     Mwocp68(Mwocp68),\n     Ltc4282(Ltc4282),\n+    Lm5066(Lm5066),\n }\n \n impl Device {\n@@ -124,6 +127,7 @@ impl Device {\n             Device::Isl68224(dev) \u003d\u003e dev.read_temperature()?,\n             Device::Tps546B24A(dev) \u003d\u003e dev.read_temperature()?,\n             Device::Adm1272(dev) \u003d\u003e dev.read_temperature()?,\n+            Device::Lm5066(dev) \u003d\u003e dev.read_temperature()?,\n             Device::Mwocp68(..) \u003d\u003e {\n                 // The MWOCP68 actually has three temperature sensors, but they\n                 // aren\u0027t associated with power rails, so we don\u0027t read them\n@@ -148,6 +152,7 @@ impl Device {\n             Device::Max5970(dev) \u003d\u003e dev.read_iout()?,\n             Device::Mwocp68(dev) \u003d\u003e dev.read_iout()?,\n             Device::Ltc4282(dev) \u003d\u003e dev.read_iout()?,\n+            Device::Lm5066(dev) \u003d\u003e dev.read_iout()?,\n         };\n         Ok(r)\n     }\n@@ -163,6 +168,7 @@ impl Device {\n             Device::Max5970(dev) \u003d\u003e dev.read_vout()?,\n             Device::Mwocp68(dev) \u003d\u003e dev.read_vout()?,\n             Device::Ltc4282(dev) \u003d\u003e dev.read_vout()?,\n+            Device::Lm5066(dev) \u003d\u003e dev.read_vout()?,\n         };\n         Ok(r)\n     }\n@@ -211,6 +217,7 @@ impl Device {\n             | Device::Tps546B24A(_)\n             | Device::Adm1272(_)\n             | Device::Ltc4282(_)\n+            | Device::Lm5066(_)\n             | Device::Max5970(_) \u003d\u003e {\n                 return Err(ResponseCode::OperationNotSupported)\n             }\n@@ -226,7 +233,10 @@ impl Device {\n             Device::Raa229620A(dev) \u003d\u003e dev.read_mode()?,\n             Device::Isl68224(dev) \u003d\u003e dev.read_mode()?,\n             Device::Tps546B24A(dev) \u003d\u003e dev.read_mode()?,\n-            Device::Adm1272(..) | Device::Ltc4282(..) | Device::Max5970(..) \u003d\u003e {\n+            Device::Adm1272(..)\n+            | Device::Ltc4282(..)\n+            | Device::Max5970(..)\n+            | Device::Lm5066(..) \u003d\u003e {\n                 return Err(ResponseCode::OperationNotSupported)\n             }\n         };\n@@ -244,6 +254,7 @@ impl Device {\n             Device::Adm1272(dev) \u003d\u003e dev.i2c_device(),\n             Device::Ltc4282(dev) \u003d\u003e dev.i2c_device(),\n             Device::Max5970(dev) \u003d\u003e dev.i2c_device(),\n+            Device::Lm5066(dev) \u003d\u003e dev.i2c_device(),\n         }\n     }\n }\n@@ -273,6 +284,9 @@ impl PowerControllerConfig {\n             DeviceChip::Ltc4282(sense) \u003d\u003e {\n                 Device::Ltc4282(Ltc4282::new(\u0026dev, *sense))\n             }\n+            DeviceChip::Lm5066(sense, strap) \u003d\u003e {\n+                Device::Lm5066(Lm5066::new(\u0026dev, *sense, *strap))\n+            }\n         }\n     }\n }\n@@ -361,6 +375,28 @@ macro_rules! ltc4282_controller {\n     };\n }\n \n+#[allow(unused_macros)]\n+macro_rules! lm5066_controller {\n+    ($which:ident, $rail:ident, $state:ident, $rsense:expr, $strap:expr) \u003d\u003e {\n+        paste::paste! {\n+            PowerControllerConfig {\n+                state: $crate::PowerState::$state,\n+                device: $crate::DeviceType::$which,\n+                chip: $crate::DeviceChip::Lm5066($rsense, $strap),\n+                builder: i2c_config::pmbus::$rail,\n+                voltage: sensors::[\u003cLM5066_ $rail:upper _VOLTAGE_SENSOR\u003e],\n+                input_voltage: None,\n+                current: sensors::[\u003cLM5066_ $rail:upper _CURRENT_SENSOR\u003e],\n+                input_current: None,\n+                temperature: Some(\n+                    sensors::[\u003cLM5066_ $rail:upper _TEMPERATURE_SENSOR\u003e]\n+                ),\n+                phases: None,\n+            }\n+        }\n+    };\n+}\n+\n #[allow(unused_macros)]\n macro_rules! max5970_controller {\n     ($which:ident, $rail:ident, $state:ident, $rsense:expr) \u003d\u003e {","expectedMessage":"add LM5066 support (#2000)","repository":"hubris-cantrill","commitHash":"12f3b213205aee0b1e5218d371040c83cfed5a51","metadata":{"author":"Bryan Cantrill \u003cbryan@oxide.computer\u003e"}}
{"id":"hubris-cantrill-33193579","diff":" Cargo.lock                              |  27 ++-\n Cargo.toml                              |   1 +\n app/psc/base.toml                       |   9 +-\n drv/i2c-devices/src/mwocp68.rs          | 416 +++++++++++++++++++++++++++++++-\n drv/psc-psu-update/Cargo.toml           |  27 +++\n drv/psc-psu-update/build.rs             |   9 +\n drv/psc-psu-update/src/main.rs          | 390 ++++++++++++++++++++++++++++++\n drv/psc-psu-update/src/mwocp68-0701.bin | Bin 0 -\u003e 32768 bytes\n drv/psc-psu-update/src/mwocp68-0762.bin | Bin 0 -\u003e 32768 bytes\n task/sensor-polling/src/main.rs         |   1 +\n 10 files changed, 871 insertions(+), 9 deletions(-)\n\ndiff --git a/Cargo.lock b/Cargo.lock\nindex 3bf1cf0..5e16476 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -143,6 +143,12 @@ dependencies \u003d [\n  \"nodrop\",\n ]\n \n+[[package]]\n+name \u003d \"array-init\"\n+version \u003d \"2.1.0\"\n+source \u003d \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum \u003d \"3d62b7694a562cdf5a74227903507c56ab2cc8bdd1f781ed5cb4cf9c9f810bfc\"\n+\n [[package]]\n name \u003d \"arrayvec\"\n version \u003d \"0.7.4\"\n@@ -1753,6 +1759,21 @@ dependencies \u003d [\n  \"userlib\",\n ]\n \n+[[package]]\n+name \u003d \"drv-psc-psu-update\"\n+version \u003d \"0.1.0\"\n+dependencies \u003d [\n+ \"array-init 2.1.0\",\n+ \"build-i2c\",\n+ \"build-util\",\n+ \"counters\",\n+ \"drv-i2c-api\",\n+ \"drv-i2c-devices\",\n+ \"ringbuf\",\n+ \"static-cell\",\n+ \"userlib\",\n+]\n+\n [[package]]\n name \u003d \"drv-psc-seq-api\"\n version \u003d \"0.1.0\"\n@@ -3875,8 +3896,8 @@ checksum \u003d \"b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6\"\n \n [[package]]\n name \u003d \"pmbus\"\n-version \u003d \"0.1.1\"\n-source \u003d \"git+https://github.com/oxidecomputer/pmbus#735a70bbc90707a963ec1731c8a0fa427a013f21\"\n+version \u003d \"0.1.4\"\n+source \u003d \"git+https://github.com/oxidecomputer/pmbus#44568ce7eb86fe0b03dd088a75ad76ea0d8529bb\"\n dependencies \u003d [\n  \"anyhow\",\n  \"convert_case\",\n@@ -4342,7 +4363,7 @@ version \u003d \"0.1.0\"\n source \u003d \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum \u003d \"ca37e3e4d1b39afd7ff11ee4e947efae85adfddf4841787bfa47c470e96dc26d\"\n dependencies \u003d [\n- \"array-init\",\n+ \"array-init 0.0.4\",\n  \"serde\",\n  \"smallvec 0.6.14\",\n ]\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 1c37605..80a83aa 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -31,6 +31,7 @@ path \u003d \"lib/counters\"\n \n [workspace.dependencies]\n anyhow \u003d { version \u003d \"1.0.31\", default-features \u003d false, features \u003d [\"std\"] }\n+array-init \u003d { version \u003d \"2.1.0\" }\n arrayvec \u003d { version \u003d \"0.7.4\", default-features \u003d false }\n atty \u003d { version \u003d \"0.2\", default-features \u003d false }\n bitfield \u003d { version \u003d \"0.13\", default-features \u003d false }\ndiff --git a/app/psc/base.toml b/app/psc/base.toml\nindex 55396ba..9a303fa 100644\n--- a/app/psc/base.toml\n+++ b/app/psc/base.toml\n@@ -6,7 +6,7 @@ fwid \u003d true\n \n [kernel]\n name \u003d \"psc\"\n-requires \u003d {flash \u003d 32868, ram \u003d 5216}\n+requires \u003d {flash \u003d 32868, ram \u003d 6000}\n features \u003d [\"dump\"]\n \n [caboose]\n@@ -298,6 +298,13 @@ max-sizes \u003d {flash \u003d 16384, ram \u003d 2048 }\n start \u003d true\n task-slots \u003d [\"i2c_driver\", \"sensor\"]\n \n+[tasks.psu_update]\n+name \u003d \"drv-psc-psu-update\"\n+priority \u003d 4\n+max-sizes \u003d {flash \u003d 65536, ram \u003d 8192 }\n+start \u003d true\n+task-slots \u003d [\"i2c_driver\"]\n+\n [tasks.dump_agent]\n name \u003d \"task-dump-agent\"\n priority \u003d 5\ndiff --git a/drv/i2c-devices/src/mwocp68.rs b/drv/i2c-devices/src/mwocp68.rs\nindex 5dccabb..5166120 100644\n--- a/drv/i2c-devices/src/mwocp68.rs\n+++ b/drv/i2c-devices/src/mwocp68.rs\n@@ -27,13 +27,68 @@ pub struct Mwocp68 {\n     mode: Cell\u003cOption\u003cpmbus::VOutModeCommandData\u003e\u003e,\n }\n \n+#[derive(Copy, Clone, PartialEq)]\n+pub struct FirmwareRev(pub [u8; 4]);\n+\n+#[derive(Copy, Clone, PartialEq, Default)]\n+pub struct SerialNumber(pub [u8; 12]);\n+\n+//\n+// The boot loader command -- sent via BOOT_LOADER_CMD -- is unfortunately odd\n+// in that its command code is overloaded with BOOT_LOADER_STATUS.  (That is,\n+// a read to the command code is BOOT_LOADER_STATUS, a write is\n+// BOOT_LOADER_CMD.)  This is behavior that the PMBus crate didn\u0027t necessarily\n+// envision, so it can\u0027t necessarily help us out; we define the single-byte\n+// payload codes here rather than declaratively in the PMBus crate.\n+//\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[repr(u8)]\n+pub enum BootLoaderCommand {\n+    ClearStatus \u003d 0x00,\n+    RestartProgramming \u003d 0x01,\n+    BootPrimary \u003d 0x12,\n+    BootSecondary \u003d 0x02,\n+    BootPSUFirmware \u003d 0x03,\n+}\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum Error {\n-    BadRead { cmd: u8, code: ResponseCode },\n-    BadWrite { cmd: u8, code: ResponseCode },\n-    BadData { cmd: u8 },\n-    BadValidation { cmd: u8, code: ResponseCode },\n-    InvalidData { err: pmbus::Error },\n+    BadRead {\n+        cmd: u8,\n+        code: ResponseCode,\n+    },\n+    BadWrite {\n+        cmd: u8,\n+        code: ResponseCode,\n+    },\n+    BadData {\n+        cmd: u8,\n+    },\n+    BadValidation {\n+        cmd: u8,\n+        code: ResponseCode,\n+    },\n+    InvalidData {\n+        err: pmbus::Error,\n+    },\n+    BadFirmwareRevRead {\n+        code: ResponseCode,\n+    },\n+    BadFirmwareRev {\n+        index: u8,\n+    },\n+    BadFirmwareRevLength,\n+    UpdateInBootLoader,\n+    UpdateNotInBootLoader,\n+    UpdateAlreadySuccessful,\n+    BadBootLoaderStatus {\n+        data: u8,\n+    },\n+    BadBootLoaderCommand {\n+        cmd: BootLoaderCommand,\n+        code: ResponseCode,\n+    },\n+    ChecksumNotSuccessful,\n }\n \n impl From\u003cBadValidation\u003e for Error {\n@@ -62,6 +117,66 @@ impl From\u003cpmbus::Error\u003e for Error {\n     }\n }\n \n+///\n+/// Defines the state of the firmware update.  Once `UpdateSuccessful`\n+/// has been returned, the update is complete.\n+///\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum UpdateState {\n+    /// The boot loader key has been written\n+    WroteBootLoaderKey,\n+\n+    /// The product key has been written\n+    WroteProductKey,\n+\n+    /// The boot loader has been booted\n+    BootedBootLoader,\n+\n+    /// Programming of firmware has been indicated to have started\n+    StartedProgramming,\n+\n+    /// A block has been written; the next offset is at [`offset`], and the\n+    /// running checksum is in [`checksum`]\n+    WroteBlock { offset: usize, checksum: u64 },\n+\n+    /// The last block has been written; the checksum is in [`checksum`]\n+    WroteLastBlock { checksum: u64 },\n+\n+    /// The checksum has been sent for verification\n+    SentChecksum,\n+\n+    /// The checksum has been verified\n+    VerifiedChecksum,\n+\n+    /// The PSU has been rebooted\n+    RebootedPSU,\n+\n+    /// The entire update is complete and successful\n+    UpdateSuccessful,\n+}\n+\n+impl UpdateState {\n+    ///\n+    /// Return the milliseconds of delay associated with the current state.\n+    /// Note that some of these values differ slightly from Murata\u0027s \"PSU\n+    /// Firmware Update Process\" document in that they reflect revised\n+    /// guidance from Murata.\n+    ///\n+    fn delay_ms(\u0026self) -\u003e u64 {\n+        match self {\n+            Self::WroteBootLoaderKey \u003d\u003e 3_000,\n+            Self::WroteProductKey \u003d\u003e 3_000,\n+            Self::BootedBootLoader \u003d\u003e 1_000,\n+            Self::StartedProgramming \u003d\u003e 2_000,\n+            Self::WroteBlock { .. } | Self::WroteLastBlock { .. } \u003d\u003e 100,\n+            Self::SentChecksum \u003d\u003e 2_000,\n+            Self::VerifiedChecksum \u003d\u003e 4_000,\n+            Self::RebootedPSU \u003d\u003e 5_000,\n+            Self::UpdateSuccessful \u003d\u003e 0,\n+        }\n+    }\n+}\n+\n impl Mwocp68 {\n     pub fn new(device: \u0026I2cDevice, index: u8) -\u003e Self {\n         Mwocp68 {\n@@ -350,6 +465,297 @@ impl Mwocp68 {\n         Ok(val)\n     }\n \n+    /// Will return true if the device is present and valid -- false otherwise\n+    pub fn present(\u0026self) -\u003e bool {\n+        Mwocp68::validate(\u0026self.device).unwrap_or_default()\n+    }\n+\n+    pub fn power_good(\u0026self) -\u003e Result\u003cbool, Error\u003e {\n+        use commands::mwocp68::STATUS_WORD::*;\n+\n+        let status \u003d pmbus_read!(self.device, STATUS_WORD)?;\n+        Ok(status.get_power_good_status() \u003d\u003d Some(PowerGoodStatus::PowerGood))\n+    }\n+\n+    ///\n+    /// Returns the firmware revision of the primary MCU (AC input side).\n+    ///\n+    pub fn firmware_revision(\u0026self) -\u003e Result\u003cFirmwareRev, Error\u003e {\n+        const REVISION_LEN: usize \u003d 14;\n+\n+        let mut data \u003d [0u8; REVISION_LEN];\n+        let expected \u003d b\"XXXX-YYYY-0000\";\n+\n+        let len \u003d self\n+            .device\n+            .read_block(CommandCode::MFR_REVISION as u8, \u0026mut data)\n+            .map_err(|code| Error::BadFirmwareRevRead { code })?;\n+\n+        //\n+        // Per ACAN-114, we are expecting this to be of the format:\n+        //\n+        //    XXXX-YYYY-0000\n+        //\n+        // Where XXXX is the firmware revision on the primary MCU (AC input\n+        // side) and YYYY is the firmware revision on the secondary MCU (DC\n+        // output side).  We aren\u0027t going to be rigid about the format of\n+        // either revision, but we will be rigid about the rest of the format.\n+        //\n+        if len !\u003d REVISION_LEN {\n+            return Err(Error::BadFirmwareRevLength);\n+        }\n+\n+        for index in 0..len {\n+            if expected[index] \u003d\u003d b\u0027X\u0027 || expected[index] \u003d\u003d b\u0027Y\u0027 {\n+                continue;\n+            }\n+\n+            if data[index] !\u003d expected[index] {\n+                return Err(Error::BadFirmwareRev { index: index as u8 });\n+            }\n+        }\n+\n+        //\n+        // Return the primary MCU version\n+        //\n+        Ok(FirmwareRev([data[0], data[1], data[2], data[3]]))\n+    }\n+\n+    ///\n+    /// Returns the serial number of the PSU.\n+    ///\n+    pub fn serial_number(\u0026self) -\u003e Result\u003cSerialNumber, Error\u003e {\n+        let mut serial \u003d SerialNumber::default();\n+\n+        let _ \u003d self\n+            .device\n+            .read_block(CommandCode::MFR_SERIAL as u8, \u0026mut serial.0)\n+            .map_err(|code| Error::BadFirmwareRevRead { code })?;\n+\n+        Ok(serial)\n+    }\n+\n+    fn get_boot_loader_status(\n+        \u0026self,\n+    ) -\u003e Result\u003cBOOT_LOADER_STATUS::CommandData, Error\u003e {\n+        use pmbus::commands::mwocp68::CommandCode;\n+        let cmd \u003d CommandCode::BOOT_LOADER_STATUS as u8;\n+        let mut data \u003d [0u8];\n+\n+        match self.device.read_block(cmd, \u0026mut data) {\n+            Ok(1) \u003d\u003e Ok(()),\n+            Ok(len) \u003d\u003e Err(Error::BadBootLoaderStatus { data: len as u8 }),\n+            Err(code) \u003d\u003e Err(Error::BadRead { cmd, code }),\n+        }?;\n+\n+        match BOOT_LOADER_STATUS::CommandData::from_slice(\u0026data[0..]) {\n+            Some(status) \u003d\u003e Ok(status),\n+            None \u003d\u003e Err(Error::BadBootLoaderStatus { data: data[0] }),\n+        }\n+    }\n+\n+    fn get_boot_loader_mode(\u0026self) -\u003e Result\u003cBOOT_LOADER_STATUS::Mode, Error\u003e {\n+        //\n+        // This unwrap is safe because the boot loader mode is a single bit.\n+        //\n+        Ok(self.get_boot_loader_status()?.get_mode().unwrap())\n+    }\n+\n+    fn boot_loader_command(\u0026self, cmd: BootLoaderCommand) -\u003e Result\u003c(), Error\u003e {\n+        use pmbus::commands::mwocp68::CommandCode;\n+\n+        //\n+        // The great unfortunateness: BOOT_LOADER_STATUS is overloaded to\n+        // be BOOT_LOADER_CMD on a write.\n+        //\n+        let data \u003d [CommandCode::BOOT_LOADER_STATUS as u8, 1, cmd as u8];\n+\n+        self.device\n+            .write(\u0026data)\n+            .map_err(|code| Error::BadBootLoaderCommand { cmd, code })?;\n+\n+        Ok(())\n+    }\n+\n+    ///\n+    /// Perform a firmware update, implementating the procedure contained\n+    /// within Murata\u0027s \"PSU Firmware Update Process\" document.  Note that\n+    /// this function must be called initially with a state of `None`; it will\n+    /// return either an error, or the next state in the update process,\n+    /// along with a specified delay in milliseconds.  It is up to the caller\n+    /// to assure that the returned delay has been observed before calling\n+    /// back into continue the update.\n+    ///\n+    pub fn update(\n+        \u0026self,\n+        state: Option\u003cUpdateState\u003e,\n+        payload: \u0026[u8],\n+    ) -\u003e Result\u003c(UpdateState, u64), Error\u003e {\n+        use pmbus::commands::mwocp68::CommandCode;\n+        use BOOT_LOADER_STATUS::Mode;\n+\n+        let write_boot_loader_key \u003d || -\u003e Result\u003cUpdateState, Error\u003e {\n+            const MWOCP68_BOOT_LOADER_KEY: \u0026[u8] \u003d b\"InVe\";\n+            let mut data \u003d [0u8; MWOCP68_BOOT_LOADER_KEY.len() + 2];\n+\n+            data[0] \u003d CommandCode::BOOT_LOADER_KEY as u8;\n+            data[1] \u003d MWOCP68_BOOT_LOADER_KEY.len() as u8;\n+            data[2..].copy_from_slice(MWOCP68_BOOT_LOADER_KEY);\n+\n+            self.device\n+                .write(\u0026data)\n+                .map_err(|code| Error::BadWrite { cmd: data[0], code })?;\n+\n+            Ok(UpdateState::WroteBootLoaderKey)\n+        };\n+\n+        let write_product_key \u003d || -\u003e Result\u003cUpdateState, Error\u003e {\n+            const MWOCP68_PRODUCT_KEY: \u0026[u8] \u003d b\"M5813-0000000000\";\n+            let mut data \u003d [0u8; MWOCP68_PRODUCT_KEY.len() + 1];\n+\n+            data[0] \u003d CommandCode::BOOT_LOADER_PRODUCT_KEY as u8;\n+            data[1..].copy_from_slice(MWOCP68_PRODUCT_KEY);\n+\n+            self.device\n+                .write(\u0026data)\n+                .map_err(|code| Error::BadWrite { cmd: data[0], code })?;\n+\n+            Ok(UpdateState::WroteProductKey)\n+        };\n+\n+        let boot_boot_loader \u003d || -\u003e Result\u003cUpdateState, Error\u003e {\n+            self.boot_loader_command(BootLoaderCommand::BootPrimary)?;\n+            Ok(UpdateState::BootedBootLoader)\n+        };\n+\n+        let start_programming \u003d || -\u003e Result\u003cUpdateState, Error\u003e {\n+            self.boot_loader_command(BootLoaderCommand::RestartProgramming)?;\n+            Ok(UpdateState::StartedProgramming)\n+        };\n+\n+        let write_block \u003d || -\u003e Result\u003cUpdateState, Error\u003e {\n+            const BLOCK_LEN: usize \u003d 32;\n+\n+            let (mut offset, mut checksum) \u003d match state {\n+                Some(UpdateState::WroteBlock { offset, checksum }) \u003d\u003e {\n+                    (offset, checksum)\n+                }\n+                Some(UpdateState::StartedProgramming) \u003d\u003e (0, 0),\n+                _ \u003d\u003e panic!(),\n+            };\n+\n+            let mut data \u003d [0u8; BLOCK_LEN + 1];\n+            data[0] \u003d CommandCode::BOOT_LOADER_MEMORY_BLOCK as u8;\n+            data[1..].copy_from_slice(\u0026payload[offset..offset + BLOCK_LEN]);\n+\n+            self.device\n+                .write(\u0026data)\n+                .map_err(|code| Error::BadWrite { cmd: data[0], code })?;\n+\n+            checksum \u003d data[1..]\n+                .iter()\n+                .fold(checksum, |c, \u0026d| c.wrapping_add(d.into()));\n+            offset +\u003d BLOCK_LEN;\n+\n+            if offset \u003e\u003d payload.len() {\n+                Ok(UpdateState::WroteLastBlock { checksum })\n+            } else {\n+                Ok(UpdateState::WroteBlock { offset, checksum })\n+            }\n+        };\n+\n+        let send_checksum \u003d || -\u003e Result\u003cUpdateState, Error\u003e {\n+            let Some(UpdateState::WroteLastBlock { checksum }) \u003d state else {\n+                panic!();\n+            };\n+\n+            let data \u003d [\n+                CommandCode::IMAGE_CHECKSUM as u8,\n+                2,\n+                (checksum \u0026 0xff) as u8,\n+                ((checksum \u003e\u003e 8) \u0026 0xff) as u8,\n+            ];\n+\n+            self.device\n+                .write(\u0026data)\n+                .map_err(|code| Error::BadWrite { cmd: data[0], code })?;\n+\n+            Ok(UpdateState::SentChecksum)\n+        };\n+\n+        let verify_checksum \u003d || -\u003e Result\u003cUpdateState, Error\u003e {\n+            use BOOT_LOADER_STATUS::ChecksumSuccessful;\n+\n+            let status \u003d self.get_boot_loader_status()?;\n+\n+            match status.get_checksum_successful() {\n+                Some(ChecksumSuccessful::Successful) \u003d\u003e {\n+                    Ok(UpdateState::VerifiedChecksum)\n+                }\n+                Some(ChecksumSuccessful::NotSuccessful) | None \u003d\u003e {\n+                    Err(Error::ChecksumNotSuccessful)\n+                }\n+            }\n+        };\n+\n+        let reboot_psu \u003d || -\u003e Result\u003cUpdateState, Error\u003e {\n+            self.boot_loader_command(BootLoaderCommand::BootPSUFirmware)?;\n+            Ok(UpdateState::RebootedPSU)\n+        };\n+\n+        let verify_success \u003d || -\u003e Result\u003cUpdateState, Error\u003e {\n+            Ok(UpdateState::UpdateSuccessful)\n+        };\n+\n+        //\n+        // We want to confirm that our boot loader is in the state that\n+        // we think it should be in.  On the one hand, this will fail in\n+        // a non-totally-unreasonable fashion if we don\u0027t check this -- but\n+        // we have an opportunity to assert our in-device state and fail\n+        // cleanly if it doesn\u0027t match, and it feels like we should take it.\n+        //\n+        let expected \u003d match state {\n+            None\n+            | Some(UpdateState::WroteBootLoaderKey)\n+            | Some(UpdateState::WroteProductKey)\n+            | Some(UpdateState::RebootedPSU) \u003d\u003e Mode::NotBootLoader,\n+\n+            Some(UpdateState::BootedBootLoader)\n+            | Some(UpdateState::StartedProgramming)\n+            | Some(UpdateState::WroteBlock { .. })\n+            | Some(UpdateState::WroteLastBlock { .. })\n+            | Some(UpdateState::SentChecksum)\n+            | Some(UpdateState::VerifiedChecksum) \u003d\u003e Mode::BootLoader,\n+\n+            Some(UpdateState::UpdateSuccessful) \u003d\u003e {\n+                return Err(Error::UpdateAlreadySuccessful);\n+            }\n+        };\n+\n+        if self.get_boot_loader_mode()? !\u003d expected {\n+            return Err(match expected {\n+                Mode::BootLoader \u003d\u003e Error::UpdateNotInBootLoader,\n+                Mode::NotBootLoader \u003d\u003e Error::UpdateInBootLoader,\n+            });\n+        }\n+\n+        let next \u003d match state {\n+            None \u003d\u003e write_boot_loader_key()?,\n+            Some(UpdateState::WroteBootLoaderKey) \u003d\u003e write_product_key()?,\n+            Some(UpdateState::WroteProductKey) \u003d\u003e boot_boot_loader()?,\n+            Some(UpdateState::BootedBootLoader) \u003d\u003e start_programming()?,\n+            Some(UpdateState::StartedProgramming)\n+            | Some(UpdateState::WroteBlock { .. }) \u003d\u003e write_block()?,\n+            Some(UpdateState::WroteLastBlock { .. }) \u003d\u003e send_checksum()?,\n+            Some(UpdateState::SentChecksum) \u003d\u003e verify_checksum()?,\n+            Some(UpdateState::VerifiedChecksum) \u003d\u003e reboot_psu()?,\n+            Some(UpdateState::RebootedPSU) \u003d\u003e verify_success()?,\n+            Some(UpdateState::UpdateSuccessful) \u003d\u003e panic!(),\n+        };\n+\n+        Ok((next, next.delay_ms()))\n+    }\n+\n     pub fn i2c_device(\u0026self) -\u003e \u0026I2cDevice {\n         \u0026self.device\n     }\ndiff --git a/drv/psc-psu-update/Cargo.toml b/drv/psc-psu-update/Cargo.toml\nnew file mode 100644\nindex 0000000..bfc2b02\n--- /dev/null\n+++ b/drv/psc-psu-update/Cargo.toml\n@@ -0,0 +1,27 @@\n+[package]\n+name \u003d \"drv-psc-psu-update\"\n+description \u003d \"Task for PSU firmware update\"\n+version \u003d \"0.1.0\"\n+edition \u003d \"2021\"\n+\n+[dependencies]\n+drv-i2c-api \u003d { path \u003d \"../i2c-api\" }\n+drv-i2c-devices \u003d { path \u003d \"../i2c-devices\" }\n+counters \u003d { path \u003d \"../../lib/counters\" }\n+ringbuf \u003d { path \u003d \"../../lib/ringbuf\", features \u003d [\"counters\"] }\n+userlib \u003d { path \u003d \"../../sys/userlib\", features \u003d [\"panic-messages\"] }\n+static-cell \u003d { path \u003d \"../../lib/static-cell\" }\n+array-init.workspace \u003d true\n+\n+[build-dependencies]\n+build-util \u003d {path \u003d \"../../build/util\"}\n+build-i2c \u003d { path \u003d \"../../build/i2c\" }\n+\n+[[bin]]\n+name \u003d \"drv-psc-psu-update\"\n+test \u003d false\n+doctest \u003d false\n+bench \u003d false\n+\n+[lints]\n+workspace \u003d true\ndiff --git a/drv/psc-psu-update/build.rs b/drv/psc-psu-update/build.rs\nnew file mode 100644\nindex 0000000..660f92b\n--- /dev/null\n+++ b/drv/psc-psu-update/build.rs\n@@ -0,0 +1,9 @@\n+// This Source Code Form is subject to the terms of the Mozilla Public\n+// License, v. 2.0. If a copy of the MPL was not distributed with this\n+// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n+\n+fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n+    build_util::expose_target_board();\n+    build_i2c::codegen(build_i2c::Disposition::Devices)?;\n+    Ok(())\n+}\ndiff --git a/drv/psc-psu-update/src/main.rs b/drv/psc-psu-update/src/main.rs\nnew file mode 100644\nindex 0000000..5584d66\n--- /dev/null\n+++ b/drv/psc-psu-update/src/main.rs\n@@ -0,0 +1,390 @@\n+// This Source Code Form is subject to the terms of the Mozilla Public\n+// License, v. 2.0. If a copy of the MPL was not distributed with this\n+// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n+\n+//! Server for updating all PSUs to the contained binary payload.\n+//!\n+//! We have the capacity to dynamically update the MWOCP68 power supply units\n+//! connected to the PSC.  This update does not involve any interruption of the\n+//! PSU while it is being performed, but necessitates a reset of the PSU once\n+//! completed.  We want these updates to be automatic and autonomous; there is\n+//! little that the control plane can know that we do not know -- and even less\n+//! for the operator.\n+//!\n+//! This task contains within it a payload that is the desired firmware image\n+//! (`MWOCP68_FIRMWARE_PAYLOAD`), along with the `MFR_REVISION` that that\n+//! pyaload represents (`MWOCP68_FIRMWARE_VERSION`).  This task will check\n+//! every PSU periodically to see if the PSU\u0027s firmware revision matches the\n+//! revision specified as corresponding to the payload; if they don\u0027t match (or\n+//! rather, until they do), an attempt will be made to update the PSU.  Each\n+//! PSU will be updated sequentially: while we can expect a properly configured\n+//! and operating rack to support the loss of any one PSU, we do not want to\n+//! induce the loss of more than one simultaneously due to update.  If an\n+//! update fails, the update of that PSU will be exponentially backed off and\n+//! repeated (up to a backoff of about once per day).  Note that we will\n+//! continue to check PSUs that we have already updated should they be replaced\n+//! with a PSU with downrev firmware.  The state of this task can be\n+//! ascertained by looking at the `PSU` variable (which contains all of the\n+//! per-PSU state) as well as the ring buffer.\n+//!\n+\n+#![no_std]\n+#![no_main]\n+\n+use drv_i2c_api::*;\n+use drv_i2c_devices::mwocp68::{\n+    Error as Mwocp68Error, FirmwareRev, Mwocp68, SerialNumber, UpdateState,\n+};\n+use ringbuf::*;\n+use static_cell::ClaimOnceCell;\n+use userlib::*;\n+\n+use core::ops::Add;\n+\n+task_slot!(I2C, i2c_driver);\n+\n+const TIMER_INTERVAL_MS: u64 \u003d 10_000;\n+\n+use i2c_config::devices;\n+\n+#[cfg(any(target_board \u003d \"psc-b\", target_board \u003d \"psc-c\"))]\n+static DEVICES: [fn(TaskId) -\u003e I2cDevice; 6] \u003d [\n+    devices::mwocp68_psu0mcu,\n+    devices::mwocp68_psu1mcu,\n+    devices::mwocp68_psu2mcu,\n+    devices::mwocp68_psu3mcu,\n+    devices::mwocp68_psu4mcu,\n+    devices::mwocp68_psu5mcu,\n+];\n+\n+static PSU: ClaimOnceCell\u003c[Psu; 6]\u003e \u003d ClaimOnceCell::new(\n+    [Psu {\n+        last_checked: None,\n+        present: None,\n+        power_good: None,\n+        serial_number: None,\n+        firmware_matches: None,\n+        firmware_revision: None,\n+        update_started: None,\n+        update_succeeded: None,\n+        update_failure: None,\n+        update_backoff: None,\n+    }; 6],\n+);\n+\n+#[derive(Copy, Clone, Debug, PartialEq, counters::Count)]\n+enum Trace {\n+    #[count(skip)]\n+    None,\n+    PowerGoodFailed(u8, drv_i2c_devices::mwocp68::Error),\n+    FirmwareRevFailed(u8, drv_i2c_devices::mwocp68::Error),\n+    AttemptingUpdate(u8),\n+    BackingOff(u8),\n+    UpdateFailed,\n+    UpdateFailedState(Option\u003cUpdateState\u003e),\n+    UpdateFailure(Mwocp68Error),\n+    UpdateState(UpdateState),\n+    WroteBlock,\n+    UpdateSucceeded(u8),\n+    UpdateDelay(u64),\n+    PSUReplaced(u8),\n+    SerialNumberError(u8, drv_i2c_devices::mwocp68::Error),\n+    PGError(u8, drv_i2c_devices::mwocp68::Error),\n+    PowerNotGood(u8),\n+}\n+\n+//\n+// The actual firmware revision and payload. It is very important that the\n+// revision match the revision contained within the payload, lest we will\n+// believe that the update has failed when it has in fact succeeded!\n+//\n+const MWOCP68_FIRMWARE_REV: FirmwareRev \u003d FirmwareRev(*b\"0762\");\n+const MWOCP68_FIRMWARE_PAYLOAD: \u0026[u8] \u003d include_bytes!(\"mwocp68-0762.bin\");\n+\n+counted_ringbuf!(Trace, 64, Trace::None);\n+\n+#[derive(Copy, Clone, PartialOrd, PartialEq)]\n+struct Ticks(u64);\n+\n+impl Ticks {\n+    fn now() -\u003e Self {\n+        Self(sys_get_timer().now)\n+    }\n+}\n+\n+impl Add for Ticks {\n+    type Output \u003d Self;\n+\n+    fn add(self, other: Self) -\u003e Self {\n+        Self(self.0 + other.0)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Default)]\n+struct Psu {\n+    /// When did we last check this device?\n+    last_checked: Option\u003cTicks\u003e,\n+\n+    /// Is the device physically present?\n+    present: Option\u003cbool\u003e,\n+\n+    /// Is the device on and with POWER_GOOD set?\n+    power_good: Option\u003cbool\u003e,\n+\n+    /// The last serial number read\n+    serial_number: Option\u003cSerialNumber\u003e,\n+\n+    /// The last firmware revision read\n+    firmware_revision: Option\u003cFirmwareRev\u003e,\n+\n+    /// Does the firmware we have match the firmware here?\n+    firmware_matches: Option\u003cbool\u003e,\n+\n+    /// What time did we start an update?\n+    update_started: Option\u003cTicks\u003e,\n+\n+    /// What time did the update complete?\n+    update_succeeded: Option\u003cTicks\u003e,\n+\n+    /// What time did the update last fail, if any?\n+    update_failure: Option\u003c(Ticks, Option\u003cUpdateState\u003e, Option\u003cMwocp68Error\u003e)\u003e,\n+\n+    /// How long should the next update backoff, if at all? (In ticks.)\n+    update_backoff: Option\u003cTicks\u003e,\n+}\n+\n+impl Psu {\n+    fn update_should_be_attempted(\u0026mut self, dev: \u0026Mwocp68, ndx: u8) -\u003e bool {\n+        let now \u003d Ticks::now();\n+\n+        self.last_checked \u003d Some(now);\n+        self.power_good \u003d None;\n+        self.firmware_matches \u003d None;\n+        self.firmware_revision \u003d None;\n+\n+        if !dev.present() {\n+            self.present \u003d Some(false);\n+\n+            //\n+            // If we are seeing our device as not present, we will clear our\n+            // backoff value: if/when a PSU is plugged back in, we want to\n+            // attempt to update it immediately if the firmware revision\n+            // doesn\u0027t match our payload.\n+            //\n+            self.update_backoff \u003d None;\n+            return false;\n+        }\n+\n+        self.present \u003d Some(true);\n+\n+        //\n+        // If we can read the serial number, we\u0027re going to store it -- and\n+        // if we previously stored one and it DOESN\u0027T match, we want to\n+        // clear our backoff value so we don\u0027t delay at all in potentially\n+        // trying to update the firmware of the (replaced) PSU.  (If we can\u0027t\n+        // read the serial number at all, we want to continue to potentially\n+        // update the firmware.)\n+        //\n+        match (dev.serial_number(), self.serial_number) {\n+            (Ok(read), Some(stored)) if read !\u003d stored \u003d\u003e {\n+                ringbuf_entry!(Trace::PSUReplaced(ndx));\n+                self.update_backoff \u003d None;\n+                self.serial_number \u003d Some(read);\n+            }\n+            (Ok(_), Some(_)) \u003d\u003e {}\n+            (Ok(read), None) \u003d\u003e {\n+                self.serial_number \u003d Some(read);\n+            }\n+            (Err(code), _) \u003d\u003e {\n+                ringbuf_entry!(Trace::SerialNumberError(ndx, code));\n+            }\n+        }\n+\n+        match dev.power_good() {\n+            Ok(power_good) \u003d\u003e {\n+                self.power_good \u003d Some(power_good);\n+\n+                if !power_good {\n+                    return false;\n+                }\n+            }\n+            Err(err) \u003d\u003e {\n+                ringbuf_entry!(Trace::PowerGoodFailed(ndx, err));\n+                return false;\n+            }\n+        }\n+\n+        match dev.firmware_revision() {\n+            Ok(revision) \u003d\u003e {\n+                self.firmware_revision \u003d Some(revision);\n+\n+                if revision \u003d\u003d MWOCP68_FIRMWARE_REV {\n+                    self.firmware_matches \u003d Some(true);\n+                    return false;\n+                }\n+\n+                self.firmware_matches \u003d Some(false);\n+            }\n+            Err(err) \u003d\u003e {\n+                ringbuf_entry!(Trace::FirmwareRevFailed(ndx, err));\n+                return false;\n+            }\n+        }\n+\n+        if let (Some(started), Some(backoff)) \u003d\n+            (self.update_started, self.update_backoff)\n+        {\n+            if started + backoff \u003e now {\n+                //\n+                // Indicate we are backing off, but in a way that won\u0027t flood\n+                // the ring buffer with the backing off of a single PSU.\n+                //\n+                ringbuf_entry!(Trace::BackingOff(ndx));\n+                return false;\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    fn update_firmware(\u0026mut self, dev: \u0026Mwocp68, ndx: u8) {\n+        ringbuf_entry!(Trace::AttemptingUpdate(ndx));\n+        self.update_started \u003d Some(Ticks::now());\n+\n+        //\n+        // Before we start, update our backoff.  We\u0027ll double our backoff, up\n+        // to a cap of around a day.\n+        //\n+        self.update_backoff \u003d match self.update_backoff {\n+            Some(backoff) if backoff.0 \u003c 86_400_000 \u003d\u003e {\n+                Some(Ticks(backoff.0 * 2))\n+            }\n+            Some(backoff) \u003d\u003e Some(backoff),\n+            None \u003d\u003e Some(Ticks(75_000)),\n+        };\n+\n+        let mut state \u003d None;\n+\n+        let mut update_failed \u003d |state, err| {\n+            //\n+            // We failed.  Record everything we can!\n+            //\n+            if let Some(err) \u003d err {\n+                ringbuf_entry!(Trace::UpdateFailure(err));\n+            }\n+\n+            ringbuf_entry!(Trace::UpdateFailed);\n+            ringbuf_entry!(Trace::UpdateFailedState(state));\n+            self.update_failure \u003d Some((Ticks::now(), state, err));\n+        };\n+\n+        loop {\n+            match dev.update(state, MWOCP68_FIRMWARE_PAYLOAD) {\n+                Err(err) \u003d\u003e {\n+                    update_failed(state, Some(err));\n+                    break;\n+                }\n+\n+                Ok((UpdateState::UpdateSuccessful, _)) \u003d\u003e {\n+                    let state \u003d Some(UpdateState::UpdateSuccessful);\n+\n+                    //\n+                    // We should be back up!  As a final measure, we are going\n+                    // to check that the firmware revision matches the\n+                    // revision we think we just wrote.  If it doesn\u0027t, there\n+                    // is something amiss:  it may be that the image is\n+                    // corrupt or that the version doesn\u0027t otherwise match.\n+                    // Regardless, we consider that to be an update failure.\n+                    //\n+                    match dev.firmware_revision() {\n+                        Ok(revision) if revision !\u003d MWOCP68_FIRMWARE_REV \u003d\u003e {\n+                            update_failed(state, None);\n+                            break;\n+                        }\n+\n+                        Err(err) \u003d\u003e {\n+                            update_failed(state, Some(err));\n+                            break;\n+                        }\n+\n+                        Ok(_) \u003d\u003e {}\n+                    }\n+\n+                    //\n+                    // We\u0027re on the new firmware!  And now, a final final\n+                    // check: make sure that we are power-good.  It is very\n+                    // unclear what to do here if are NOT power-good:  we know\n+                    // that we WERE power-good before we started, so it\n+                    // certainly seems possible that we have put a firmware\n+                    // update on this PSU which has somehow incapacitated it.\n+                    // We would rather not put the system in a compromised\n+                    // state by continuing to potentially brick PSUs -- but we\n+                    // also want to assure that we make progress should this\n+                    // ever resolve (e.g., by pulling the bricked PSU). We will\n+                    // remain here until we see the updated PSU go power-good;\n+                    // if it never does, we will at least not attempt to put\n+                    // the (potentially) bad update anywhere else!\n+                    //\n+                    loop {\n+                        match dev.power_good() {\n+                            Ok(power_good) if power_good \u003d\u003e break,\n+                            Ok(_) \u003d\u003e {\n+                                ringbuf_entry!(Trace::PowerNotGood(ndx));\n+                            }\n+                            Err(err) \u003d\u003e {\n+                                ringbuf_entry!(Trace::PGError(ndx, err));\n+                            }\n+                        }\n+\n+                        hl::sleep_for(TIMER_INTERVAL_MS);\n+                    }\n+\n+                    ringbuf_entry!(Trace::UpdateSucceeded(ndx));\n+                    self.update_succeeded \u003d Some(Ticks::now());\n+                    self.update_backoff \u003d None;\n+                    break;\n+                }\n+\n+                Ok((next, delay)) \u003d\u003e {\n+                    match next {\n+                        UpdateState::WroteBlock { .. } \u003d\u003e {\n+                            ringbuf_entry!(Trace::WroteBlock);\n+                        }\n+                        _ \u003d\u003e {\n+                            ringbuf_entry!(Trace::UpdateState(next));\n+                            ringbuf_entry!(Trace::UpdateDelay(delay));\n+                        }\n+                    }\n+\n+                    hl::sleep_for(delay);\n+                    state \u003d Some(next);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[export_name \u003d \"main\"]\n+fn main() -\u003e ! {\n+    let i2c_task \u003d I2C.get_task_id();\n+\n+    let psus \u003d PSU.claim();\n+\n+    let devs: [Mwocp68; 6] \u003d array_init::array_init(|ndx: usize| {\n+        Mwocp68::new(\u0026DEVICES[ndx](i2c_task), 0)\n+    });\n+\n+    loop {\n+        hl::sleep_for(TIMER_INTERVAL_MS);\n+\n+        for (ndx, psu) in psus.iter_mut().enumerate() {\n+            let dev \u003d \u0026devs[ndx];\n+\n+            if psu.update_should_be_attempted(dev, ndx as u8) {\n+                psu.update_firmware(dev, ndx as u8);\n+            }\n+        }\n+    }\n+}\n+\n+include!(concat!(env!(\"OUT_DIR\"), \"/i2c_config.rs\"));\ndiff --git a/drv/psc-psu-update/src/mwocp68-0701.bin b/drv/psc-psu-update/src/mwocp68-0701.bin\nnew file mode 100644\nindex 0000000..c22f31d\nBinary files /dev/null and b/drv/psc-psu-update/src/mwocp68-0701.bin differ\ndiff --git a/drv/psc-psu-update/src/mwocp68-0762.bin b/drv/psc-psu-update/src/mwocp68-0762.bin\nnew file mode 100644\nindex 0000000..baa93ca\nBinary files /dev/null and b/drv/psc-psu-update/src/mwocp68-0762.bin differ\ndiff --git a/task/sensor-polling/src/main.rs b/task/sensor-polling/src/main.rs\nindex aef3d21..9da0ce0 100644\n--- a/task/sensor-polling/src/main.rs\n+++ b/task/sensor-polling/src/main.rs\n@@ -36,6 +36,7 @@ impl From\u003cError\u003e for task_sensor_api::NoData {\n                 | Mwocp68Error::BadValidation { code, .. } \u003d\u003e code.into(),\n                 Mwocp68Error::BadData { .. }\n                 | Mwocp68Error::InvalidData { .. } \u003d\u003e Self::DeviceError,\n+                _ \u003d\u003e Self::DeviceError,\n             },\n         }\n     }","expectedMessage":"add support for PSU firmware update (#1934)","repository":"hubris-cantrill","commitHash":"331935799299ec286d695c9fed24af4766727572","metadata":{"author":"Bryan Cantrill \u003cbryan@oxide.computer\u003e"}}
{"id":"hubris-cantrill-d165a642","diff":" lib/host-sp-messages/src/lib.rs | 11 ++++-------\n task/host-sp-comms/src/main.rs  | 11 +++++++----\n 2 files changed, 11 insertions(+), 11 deletions(-)\n\ndiff --git a/lib/host-sp-messages/src/lib.rs b/lib/host-sp-messages/src/lib.rs\nindex 5d04472..41b0f90 100644\n--- a/lib/host-sp-messages/src/lib.rs\n+++ b/lib/host-sp-messages/src/lib.rs\n@@ -92,10 +92,7 @@ pub enum HostToSp {\n     HostBootFailure {\n         reason: u8,\n     },\n-    HostPanic {\n-        code: u16,\n-        // Followed by a binary data blob (panic message?)\n-    },\n+    HostPanic, // Followed by a binary data blob (panic data)\n     GetStatus,\n     // Host ack\u0027ing SP task startup.\n     AckSpStart,\n@@ -810,7 +807,7 @@ mod tests {\n             (0x04, HostToSp::GetIdentity),\n             (0x05, HostToSp::GetMacAddresses),\n             (0x06, HostToSp::HostBootFailure { reason: 0 }),\n-            (0x07, HostToSp::HostPanic { code: 0 }),\n+            (0x07, HostToSp::HostPanic),\n             (0x08, HostToSp::GetStatus),\n             (0x09, HostToSp::AckSpStart),\n             (0x0a, HostToSp::GetAlert),\n@@ -1199,7 +1196,7 @@ mod tests {\n             version: 123,\n             sequence: 456,\n         };\n-        let host_to_sp \u003d HostToSp::HostPanic { code: 78 };\n+        let host_to_sp \u003d HostToSp::HostPanic;\n         let data_blob \u003d \u0026[1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n         let mut buf \u003d [0; MAX_MESSAGE_SIZE];\n@@ -1224,7 +1221,7 @@ mod tests {\n             version: 123,\n             sequence: 456,\n         };\n-        let host_to_sp \u003d HostToSp::HostPanic { code: 78 };\n+        let host_to_sp \u003d HostToSp::HostPanic;\n         let data_blob \u003d (0_u32..)\n             .into_iter()\n             .map(|x| x as u8)\ndiff --git a/task/host-sp-comms/src/main.rs b/task/host-sp-comms/src/main.rs\nindex 26231ad..89186c9 100644\n--- a/task/host-sp-comms/src/main.rs\n+++ b/task/host-sp-comms/src/main.rs\n@@ -185,6 +185,7 @@ const MAX_DTRACE_CONF_LEN: usize \u003d 4096;\n // data for later read back (either by the host itself or by the control plane\n // via MGS).\n struct HostKeyValueStorage {\n+    last_boot_fail_reason: u8,\n     last_boot_fail: \u0026\u0027static mut [u8; MAX_HOST_FAIL_MESSAGE_LEN],\n     last_panic: \u0026\u0027static mut [u8; MAX_HOST_FAIL_MESSAGE_LEN],\n     etc_system: \u0026\u0027static mut [u8; MAX_ETC_SYSTEM_LEN],\n@@ -298,6 +299,7 @@ impl ServerImpl {\n             packrat: Packrat::from(PACKRAT.get_task_id()),\n             reboot_state: None,\n             host_kv_storage: HostKeyValueStorage {\n+                last_boot_fail_reason: 0,\n                 last_boot_fail,\n                 last_panic,\n                 etc_system,\n@@ -783,11 +785,11 @@ impl ServerImpl {\n                 };\n                 Some(response)\n             }\n-            HostToSp::HostBootFailure { .. } \u003d\u003e {\n+            HostToSp::HostBootFailure { reason } \u003d\u003e {\n                 // TODO forward to MGS\n                 //\n                 // For now, copy it into a static var we can pull out via\n-                // `humility readvar LAST_HOST_BOOT_FAIL`.\n+                // `humility host boot-fail`.\n                 let n \u003d usize::min(\n                     data.len(),\n                     self.host_kv_storage.last_boot_fail.len(),\n@@ -797,13 +799,14 @@ impl ServerImpl {\n                 for b in \u0026mut self.host_kv_storage.last_boot_fail[n..] {\n                     *b \u003d 0;\n                 }\n+                self.host_kv_storage.last_boot_fail_reason \u003d reason;\n                 Some(SpToHost::Ack)\n             }\n-            HostToSp::HostPanic { .. } \u003d\u003e {\n+            HostToSp::HostPanic \u003d\u003e {\n                 // TODO forward to MGS\n                 //\n                 // For now, copy it into a static var we can pull out via\n-                // `humility readvar LAST_HOST_PANIC`.\n+                // `humility host last-panic`.\n                 let n \u003d usize::min(\n                     data.len(),\n                     self.host_kv_storage.last_panic.len(),","expectedMessage":"`HostPanic` and `HostBootFailure` discard bytes (#1846)","repository":"hubris-cantrill","commitHash":"d165a64286f415cd38b849190c4981fc2138d917","metadata":{"author":"Bryan Cantrill \u003cbryan@oxide.computer\u003e"}}
{"id":"hubris-cantrill-37ab11a6","diff":" app/demo-stm32h7-nucleo/app-h743.toml |  8 ++++----\n app/demo-stm32h7-nucleo/app-h753.toml |  8 ++++----\n app/gimlet/base.toml                  |  8 ++++----\n app/gimletlet/app-mgmt.toml           |  4 ++--\n app/gimletlet/app.toml                |  8 ++++----\n app/grapefruit/app.toml               |  8 ++++----\n app/medusa/base.toml                  |  6 +++---\n app/psc/base.toml                     |  8 ++++----\n app/sidecar/base.toml                 |  8 ++++----\n chips/stm32h7/memory-large.toml       | 15 ++++++++++++---\n chips/stm32h7/memory.toml             | 15 ++++++++++++---\n task/dumper/src/main.rs               |  7 ++++++-\n 12 files changed, 63 insertions(+), 40 deletions(-)\n\ndiff --git a/app/demo-stm32h7-nucleo/app-h743.toml b/app/demo-stm32h7-nucleo/app-h743.toml\nindex 3fefa54..71be0a9 100644\n--- a/app/demo-stm32h7-nucleo/app-h743.toml\n+++ b/app/demo-stm32h7-nucleo/app-h743.toml\n@@ -17,7 +17,7 @@ start \u003d true\n features \u003d [\"dump\"]\n stacksize \u003d 1536\n notifications \u003d [\"fault\", \"timer\"]\n-extern-regions \u003d [ \"sram2\", \"sram3\", \"sram4\" ]\n+extern-regions \u003d [ \"sram1\", \"sram2\", \"sram3\", \"sram4\" ]\n \n [tasks.jefe.config.allowed-callers]\n set_reset_reason \u003d [\"sys\"]\n@@ -82,9 +82,9 @@ task-slots \u003d [\"sys\"]\n name \u003d \"task-net\"\n stacksize \u003d 4000\n priority \u003d 2\n-max-sizes \u003d {flash \u003d 65536, ram \u003d 8192, sram1 \u003d 32768}\n+max-sizes \u003d {flash \u003d 65536, ram \u003d 8192, sram1_mac \u003d 32768}\n features \u003d [\"h743\"]\n-sections \u003d {eth_bulk \u003d \"sram1\"}\n+sections \u003d {eth_bulk \u003d \"sram1_mac\"}\n uses \u003d [\"eth\", \"tim16\"]\n start \u003d true\n notifications \u003d [\"eth-irq\", \"mdio-timer-irq\", \"wake-timer\"]\n@@ -152,7 +152,7 @@ max-sizes \u003d {flash \u003d 32768, ram \u003d 2048 }\n start \u003d true\n task-slots \u003d [\"jefe\"]\n stacksize \u003d 1200\n-extern-regions \u003d [ \"sram2\", \"sram3\", \"sram4\" ]\n+extern-regions \u003d [ \"sram1\", \"sram2\", \"sram3\", \"sram4\" ]\n \n [tasks.fmc_demo]\n name \u003d \"drv-stm32h7-fmc-demo-server\"\ndiff --git a/app/demo-stm32h7-nucleo/app-h753.toml b/app/demo-stm32h7-nucleo/app-h753.toml\nindex 0909520..91ebe97 100644\n--- a/app/demo-stm32h7-nucleo/app-h753.toml\n+++ b/app/demo-stm32h7-nucleo/app-h753.toml\n@@ -17,7 +17,7 @@ start \u003d true\n features \u003d [\"dump\"]\n stacksize \u003d 1536\n notifications \u003d [\"fault\", \"timer\"]\n-extern-regions \u003d [ \"sram2\", \"sram3\", \"sram4\" ]\n+extern-regions \u003d [ \"sram1\", \"sram2\", \"sram3\", \"sram4\" ]\n \n [tasks.jefe.config.allowed-callers]\n set_reset_reason \u003d [\"sys\"]\n@@ -91,9 +91,9 @@ task-slots \u003d [\"sys\"]\n name \u003d \"task-net\"\n stacksize \u003d 4000\n priority \u003d 2\n-max-sizes \u003d {flash \u003d 131072, ram \u003d 16384, sram1 \u003d 32768}\n+max-sizes \u003d {flash \u003d 131072, ram \u003d 16384, sram1_mac \u003d 32768}\n features \u003d [\"h753\"]\n-sections \u003d {eth_bulk \u003d \"sram1\"}\n+sections \u003d {eth_bulk \u003d \"sram1_mac\"}\n uses \u003d [\"eth\", \"tim16\"]\n start \u003d true\n notifications \u003d [\"eth-irq\", \"mdio-timer-irq\", \"wake-timer\"]\n@@ -203,7 +203,7 @@ max-sizes \u003d {flash \u003d 32768, ram \u003d 2048 }\n start \u003d true\n task-slots \u003d [\"jefe\"]\n stacksize \u003d 1200\n-extern-regions \u003d [ \"sram2\", \"sram3\", \"sram4\" ]\n+extern-regions \u003d [ \"sram1\", \"sram2\", \"sram3\", \"sram4\" ]\n \n [tasks.fmc_demo]\n name \u003d \"drv-stm32h7-fmc-demo-server\"\ndiff --git a/app/gimlet/base.toml b/app/gimlet/base.toml\nindex 779344a..c9b4c82 100644\n--- a/app/gimlet/base.toml\n+++ b/app/gimlet/base.toml\n@@ -23,7 +23,7 @@ start \u003d true\n features \u003d [\"dump\"]\n stacksize \u003d 1536\n notifications \u003d [\"fault\", \"timer\"]\n-extern-regions \u003d [\"sram2\", \"sram3\", \"sram4\"]\n+extern-regions \u003d [\"sram1\", \"sram2\", \"sram3\", \"sram4\"]\n \n [tasks.jefe.config.on-state-change]\n net \u003d \"jefe-state-change\"\n@@ -40,8 +40,8 @@ name \u003d \"task-net\"\n stacksize \u003d 8000\n priority \u003d 5\n features \u003d [\"mgmt\", \"h753\", \"gimlet\", \"vlan\", \"vpd-mac\"]\n-max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1 \u003d 16384}\n-sections \u003d {eth_bulk \u003d \"sram1\"}\n+max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1_mac \u003d 16384}\n+sections \u003d {eth_bulk \u003d \"sram1_mac\"}\n uses \u003d [\"eth\", \"tim16\"]\n start \u003d true\n interrupts \u003d {\"eth.irq\" \u003d \"eth-irq\", \"tim16.irq\" \u003d \"mdio-timer-irq\"}\n@@ -333,7 +333,7 @@ max-sizes \u003d {flash \u003d 32768, ram \u003d 16384 }\n start \u003d true\n task-slots \u003d [\"sprot\", \"jefe\", \"net\"]\n stacksize \u003d 2400\n-extern-regions \u003d [\"sram2\", \"sram3\", \"sram4\"]\n+extern-regions \u003d [\"sram1\", \"sram2\", \"sram3\", \"sram4\"]\n notifications \u003d [\"socket\"]\n features \u003d [\"net\", \"vlan\"]\n \ndiff --git a/app/gimletlet/app-mgmt.toml b/app/gimletlet/app-mgmt.toml\nindex 39509fa..7dd5019 100644\n--- a/app/gimletlet/app-mgmt.toml\n+++ b/app/gimletlet/app-mgmt.toml\n@@ -52,8 +52,8 @@ name \u003d \"task-net\"\n stacksize \u003d 3000\n priority \u003d 3\n features \u003d [\"mgmt\", \"h753\", \"use-spi-core\", \"spi2\"]\n-max-sizes \u003d {flash \u003d 131072, ram \u003d 16384, sram1 \u003d 16384}\n-sections \u003d {eth_bulk \u003d \"sram1\"}\n+max-sizes \u003d {flash \u003d 131072, ram \u003d 16384, sram1_mac \u003d 16384}\n+sections \u003d {eth_bulk \u003d \"sram1_mac\"}\n uses \u003d [\"eth\", \"tim16\", \"spi2\"]\n start \u003d true\n notifications \u003d [\"eth-irq\", \"mdio-timer-irq\", \"spi-irq\", \"wake-timer\"]\ndiff --git a/app/gimletlet/app.toml b/app/gimletlet/app.toml\nindex eb33a10..65bb19c 100644\n--- a/app/gimletlet/app.toml\n+++ b/app/gimletlet/app.toml\n@@ -10,7 +10,7 @@ task-slots \u003d [\"hash_driver\", \"hf\", \"i2c_driver\", \"sprot\", \"sys\", \"update_server\"\n \n [tasks.jefe]\n features \u003d [\"dump\"]\n-extern-regions \u003d [\"sram2\", \"sram3\", \"sram4\"]\n+extern-regions \u003d [\"sram1\", \"sram2\", \"sram3\", \"sram4\"]\n \n [tasks.jefe.config.allowed-callers]\n set_state \u003d [\"gimlet_seq\"]\n@@ -89,7 +89,7 @@ max-sizes \u003d {flash \u003d 32768, ram \u003d 16384 }\n start \u003d true\n task-slots \u003d [\"sprot\", \"jefe\", \"net\"]\n stacksize \u003d 2400\n-extern-regions \u003d [\"sram2\", \"sram3\", \"sram4\"]\n+extern-regions \u003d [\"sram1\", \"sram2\", \"sram3\", \"sram4\"]\n notifications \u003d [\"socket\"]\n features \u003d [\"net\", \"vlan\"]\n \n@@ -148,8 +148,8 @@ name \u003d \"task-net\"\n stacksize \u003d 8000\n priority \u003d 3\n features \u003d [\"h753\", \"vlan\", \"gimletlet-nic\", \"use-spi-core\", \"spi4\"]\n-max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1 \u003d 16384}\n-sections \u003d {eth_bulk \u003d \"sram1\"}\n+max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1_mac \u003d 16384}\n+sections \u003d {eth_bulk \u003d \"sram1_mac\"}\n uses \u003d [\"eth\", \"tim16\", \"spi4\"]\n start \u003d true\n task-slots \u003d [\"sys\", \"jefe\"]\ndiff --git a/app/grapefruit/app.toml b/app/grapefruit/app.toml\nindex cb3a348..20a3b38 100644\n--- a/app/grapefruit/app.toml\n+++ b/app/grapefruit/app.toml\n@@ -26,7 +26,7 @@ start \u003d true\n stacksize \u003d 1536\n notifications \u003d [\"fault\", \"timer\"]\n features \u003d [\"dump\"]\n-extern-regions \u003d [\"sram2\", \"sram3\", \"sram4\"]\n+extern-regions \u003d [\"sram1\", \"sram2\", \"sram3\", \"sram4\"]\n \n [tasks.jefe.config.allowed-callers]\n set_reset_reason \u003d [\"sys\"]\n@@ -139,7 +139,7 @@ max-sizes \u003d {flash \u003d 32768, ram \u003d 16384 }\n start \u003d true\n task-slots \u003d [\"jefe\", \"net\", \"sprot\"]\n stacksize \u003d 2400\n-extern-regions \u003d [\"sram2\", \"sram3\", \"sram4\"]\n+extern-regions \u003d [\"sram1\", \"sram2\", \"sram3\", \"sram4\"]\n notifications \u003d [\"socket\"]\n features \u003d [\"net\", \"vlan\"]\n \n@@ -198,8 +198,8 @@ name \u003d \"task-net\"\n stacksize \u003d 8000\n priority \u003d 3\n features \u003d [\"h753\", \"vlan\", \"grapefruit\"]\n-max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1 \u003d 16384}\n-sections \u003d {eth_bulk \u003d \"sram1\"}\n+max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1_mac \u003d 16384}\n+sections \u003d {eth_bulk \u003d \"sram1_mac\"}\n uses \u003d [\"eth\", \"tim16\"]\n start \u003d true\n task-slots \u003d [\"sys\", \"jefe\", { spi_driver \u003d \"spi2_driver\" }]\ndiff --git a/app/medusa/base.toml b/app/medusa/base.toml\nindex 622b2ee..0738858 100644\n--- a/app/medusa/base.toml\n+++ b/app/medusa/base.toml\n@@ -15,7 +15,7 @@ max-sizes \u003d {flash \u003d 16384, ram \u003d 2048}\n start \u003d true\n stacksize \u003d 1536\n notifications \u003d [\"fault\", \"timer\"]\n-extern-regions \u003d [\"sram2\", \"sram3\", \"sram4\"]\n+extern-regions \u003d [\"sram1\", \"sram2\", \"sram3\", \"sram4\"]\n \n [tasks.jefe.config.allowed-callers]\n set_reset_reason \u003d [\"sys\"]\n@@ -108,8 +108,8 @@ name \u003d \"task-net\"\n stacksize \u003d 6040\n priority \u003d 5\n features \u003d [\"mgmt\", \"h753\", \"medusa\", \"vlan\", \"vpd-mac\", \"use-spi-core\", \"spi3\"]\n-max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1 \u003d 16384}\n-sections \u003d {eth_bulk \u003d \"sram1\"}\n+max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1_mac \u003d 16384}\n+sections \u003d {eth_bulk \u003d \"sram1_mac\"}\n uses \u003d [\"eth\", \"tim16\", \"spi3\"]\n start \u003d true\n notifications \u003d [\"eth-irq\", \"mdio-timer-irq\", \"spi-irq\", \"wake-timer\"]\ndiff --git a/app/psc/base.toml b/app/psc/base.toml\nindex 8a8cc85..776bff4 100644\n--- a/app/psc/base.toml\n+++ b/app/psc/base.toml\n@@ -23,7 +23,7 @@ start \u003d true\n features \u003d [\"dump\"]\n stacksize \u003d 1536\n notifications \u003d [\"fault\", \"timer\"]\n-extern-regions \u003d [\"sram2\", \"sram3\", \"sram4\"]\n+extern-regions \u003d [\"sram1\", \"sram2\", \"sram3\", \"sram4\"]\n \n [tasks.jefe.config.on-state-change]\n net \u003d \"jefe-state-change\"\n@@ -165,8 +165,8 @@ name \u003d \"task-net\"\n stacksize \u003d 8000\n priority \u003d 4\n features \u003d [\"mgmt\", \"h753\", \"psc\", \"vlan\", \"vpd-mac\", \"spi2\"]\n-max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1 \u003d 16384}\n-sections \u003d {eth_bulk \u003d \"sram1\"}\n+max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1_mac \u003d 16384}\n+sections \u003d {eth_bulk \u003d \"sram1_mac\"}\n uses \u003d [\"eth\", \"tim16\"]\n start \u003d true\n notifications \u003d [\n@@ -304,7 +304,7 @@ max-sizes \u003d {flash \u003d 32768, ram \u003d 16384 }\n start \u003d true\n task-slots \u003d [\"sprot\", \"jefe\", \"net\"]\n stacksize \u003d 2400\n-extern-regions \u003d [ \"sram2\", \"sram3\", \"sram4\" ]\n+extern-regions \u003d [ \"sram1\", \"sram2\", \"sram3\", \"sram4\" ]\n notifications \u003d [\"socket\"]\n features \u003d [\"net\", \"vlan\"]\n \ndiff --git a/app/sidecar/base.toml b/app/sidecar/base.toml\nindex a031d73..545d2c2 100644\n--- a/app/sidecar/base.toml\n+++ b/app/sidecar/base.toml\n@@ -23,7 +23,7 @@ start \u003d true\n features \u003d [\"dump\"]\n stacksize \u003d 1536\n notifications \u003d [\"fault\", \"timer\"]\n-extern-regions \u003d [\"sram2\", \"sram3\", \"sram4\"]\n+extern-regions \u003d [\"sram1\", \"sram2\", \"sram3\", \"sram4\"]\n \n [tasks.jefe.config.allowed-callers]\n set_reset_reason \u003d [\"sys\"]\n@@ -81,8 +81,8 @@ name \u003d \"task-net\"\n stacksize \u003d 10000\n priority \u003d 5\n features \u003d [\"mgmt\", \"h753\", \"sidecar\", \"vlan\", \"vpd-mac\", \"use-spi-core\", \"spi3\"]\n-max-sizes \u003d {flash \u003d 131072, ram \u003d 131072, sram1 \u003d 16384}\n-sections \u003d {eth_bulk \u003d \"sram1\"}\n+max-sizes \u003d {flash \u003d 131072, ram \u003d 131072, sram1_mac \u003d 16384}\n+sections \u003d {eth_bulk \u003d \"sram1_mac\"}\n uses \u003d [\"eth\", \"tim16\", \"spi3\"]\n start \u003d true\n notifications \u003d [\"eth-irq\", \"mdio-timer-irq\", \"spi-irq\", \"wake-timer\"]\n@@ -316,7 +316,7 @@ max-sizes \u003d {flash \u003d 32768, ram \u003d 16384 }\n start \u003d true\n task-slots \u003d [\"sprot\", \"jefe\", \"net\"]\n stacksize \u003d 2400\n-extern-regions \u003d [ \"sram2\", \"sram3\", \"sram4\" ]\n+extern-regions \u003d [ \"sram1\", \"sram2\", \"sram3\", \"sram4\" ]\n notifications \u003d [\"socket\"]\n features \u003d [\"net\", \"vlan\"]\n \ndiff --git a/chips/stm32h7/memory-large.toml b/chips/stm32h7/memory-large.toml\nindex f954c1e..73d2302 100644\n--- a/chips/stm32h7/memory-large.toml\n+++ b/chips/stm32h7/memory-large.toml\n@@ -15,12 +15,21 @@ write \u003d true\n execute \u003d false  # let\u0027s assume XN until proven otherwise\n \n # Network buffers are placed in sram1, which is directly accessible by the\n-# Ethernet MAC.\n-[[sram1]]\n+# Ethernet MAC.  We limit this use of sram1 to 64 KiB, and preserve the\n+# remainder to be used for disjoint purposes (e.g., as an external region).\n+[[sram1_mac]]\n address \u003d 0x30000000\n-size \u003d 0x20000\n+size \u003d 0x10000\n+read \u003d true\n+write \u003d true\n+dma \u003d true\n+\n+[[sram1]]\n+address \u003d 0x30010000\n+size \u003d 0x10000\n read \u003d true\n write \u003d true\n+execute \u003d false\n dma \u003d true\n \n [[sram2]]\ndiff --git a/chips/stm32h7/memory.toml b/chips/stm32h7/memory.toml\nindex 89824a2..d9c5280 100644\n--- a/chips/stm32h7/memory.toml\n+++ b/chips/stm32h7/memory.toml\n@@ -14,12 +14,21 @@ write \u003d true\n execute \u003d false  # let\u0027s assume XN until proven otherwise\n \n # Network buffers are placed in sram1, which is directly accessible by the\n-# Ethernet MAC.\n-[[sram1]]\n+# Ethernet MAC.  We limit this use of sram1 to 64 KiB, and preserve the\n+# remainder to be used for disjoint purposes (e.g., as an external region).\n+[[sram1_mac]]\n address \u003d 0x30000000\n-size \u003d 0x20000\n+size \u003d 0x10000\n+read \u003d true\n+write \u003d true\n+dma \u003d true\n+\n+[[sram1]]\n+address \u003d 0x30010000\n+size \u003d 0x10000\n read \u003d true\n write \u003d true\n+execute \u003d false\n dma \u003d true\n \n [[sram2]]\ndiff --git a/task/dumper/src/main.rs b/task/dumper/src/main.rs\nindex 063ccc9..31c1cfd 100644\n--- a/task/dumper/src/main.rs\n+++ b/task/dumper/src/main.rs\n@@ -92,7 +92,12 @@ impl idl::InOrderDumperImpl for ServerImpl {\n         let mut nwritten \u003d 0;\n         let mut reg \u003d 0;\n \n-        let r \u003d humpty::dump::\u003cDumperError, 512, { humpty::DUMPER_EXTERNAL }\u003e(\n+        //\n+        // Now dump, with a buffer size of 1024.  (1024 is a sweet spot with\n+        // respect to overhead of header size vs. loss to orphaned space at\n+        // the end of segments.)\n+        //\n+        let r \u003d humpty::dump::\u003cDumperError, 1024, { humpty::DUMPER_EXTERNAL }\u003e(\n             header.address,\n             None,\n             || {","expectedMessage":"Can\u0027t collect an SP dump (#1837)","repository":"hubris-cantrill","commitHash":"37ab11a673d60f75dd1b671dd2463c9d5ca0ed39","metadata":{"author":"Bryan Cantrill \u003cbryan@oxide.computer\u003e"}}
{"id":"hubris-cantrill-a35ea553","diff":" app/gimlet/base.toml               |  10 ++-\n drv/gimlet-seq-server/src/main.rs  |  27 ++++++-\n drv/gimlet-seq-server/src/vcore.rs | 156 +++++++++++++++++++++++++++++++++++++\n drv/i2c-devices/src/lib.rs         |  12 +++\n drv/i2c-devices/src/raa229618.rs   |  15 ++++\n 5 files changed, 216 insertions(+), 4 deletions(-)\n\ndiff --git a/app/gimlet/base.toml b/app/gimlet/base.toml\nindex 05a63a6..bcba768 100644\n--- a/app/gimlet/base.toml\n+++ b/app/gimlet/base.toml\n@@ -66,6 +66,12 @@ notifications \u003d [\"exti-wildcard-irq\"]\n \"exti.exti9_5\" \u003d \"exti-wildcard-irq\"\n \"exti.exti15_10\" \u003d \"exti-wildcard-irq\"\n \n+# PWR_CONT1_VCORE_TO_SP_ALERT_L\n+[tasks.sys.config.gpio-irqs.vcore_to_sp_alert_l]\n+port \u003d \"I\"\n+pin \u003d 14\n+owner \u003d {name \u003d \"gimlet_seq\", notification \u003d \"vcore\"}\n+\n [tasks.sys.config.gpio-irqs.rot_irq]\n port \u003d \"E\"\n pin \u003d 3\n@@ -157,11 +163,11 @@ task-slots \u003d [\"sys\", \"hf\", \"i2c_driver\", \"hash_driver\", \"update_server\", \"sprot\"\n name \u003d \"drv-gimlet-seq-server\"\n features \u003d [\"h753\"]\n priority \u003d 4\n-max-sizes \u003d {flash \u003d 131072, ram \u003d 8192 }\n+max-sizes \u003d {flash \u003d 131072, ram \u003d 16384 }\n stacksize \u003d 1600\n start \u003d true\n task-slots \u003d [\"sys\", \"i2c_driver\", {spi_driver \u003d \"spi2_driver\"}, \"hf\", \"jefe\", \"packrat\"]\n-notifications \u003d [\"timer\"]\n+notifications \u003d [\"timer\", \"vcore\"]\n copy-to-archive \u003d [\"register_defs\"]\n \n [tasks.gimlet_seq.config]\ndiff --git a/drv/gimlet-seq-server/src/main.rs b/drv/gimlet-seq-server/src/main.rs\nindex 38116d6..8ba1393 100644\n--- a/drv/gimlet-seq-server/src/main.rs\n+++ b/drv/gimlet-seq-server/src/main.rs\n@@ -8,6 +8,7 @@\n #![no_main]\n \n mod seq_spi;\n+mod vcore;\n \n use counters::*;\n use ringbuf::*;\n@@ -52,6 +53,7 @@ enum I2cTxn {\n     SpdLoadTop(u8, u8),\n     VCoreOn,\n     VCoreOff,\n+    VCoreUndervoltageInitialize,\n     SocOn,\n     SocOff,\n }\n@@ -181,6 +183,7 @@ struct ServerImpl\u003cS: SpiServer\u003e {\n     seq: seq_spi::SequencerFpga\u003cS\u003e,\n     jefe: Jefe,\n     hf: hf_api::HostFlash,\n+    vcore: vcore::VCore,\n     deadline: u64,\n }\n \n@@ -462,6 +465,8 @@ impl\u003cS: SpiServer + Clone\u003e ServerImpl\u003cS\u003e {\n         // Turn on the chassis LED once we reach A2\n         sys.gpio_set(CHASSIS_LED);\n \n+        let (device, rail) \u003d i2c_config::pmbus::vdd_vcore(I2C.get_task_id());\n+\n         let mut server \u003d Self {\n             state: PowerState::A2,\n             sys: sys.clone(),\n@@ -469,6 +474,7 @@ impl\u003cS: SpiServer + Clone\u003e ServerImpl\u003cS\u003e {\n             jefe,\n             hf,\n             deadline: 0,\n+            vcore: vcore::VCore::new(sys, \u0026device, rail),\n         };\n \n         // Power on, unless suppressed by the `stay-in-a2` feature\n@@ -500,10 +506,18 @@ impl\u003cS: SpiServer + Clone\u003e ServerImpl\u003cS\u003e {\n \n impl\u003cS: SpiServer\u003e NotificationHandler for ServerImpl\u003cS\u003e {\n     fn current_notification_mask(\u0026self) -\u003e u32 {\n-        notifications::TIMER_MASK\n+        notifications::TIMER_MASK | self.vcore.mask()\n     }\n \n-    fn handle_notification(\u0026mut self, _bits: u32) {\n+    fn handle_notification(\u0026mut self, bits: u32) {\n+        if (bits \u0026 self.vcore.mask()) !\u003d 0 {\n+            self.vcore.handle_notification();\n+        }\n+\n+        if (bits \u0026 notifications::TIMER_MASK) \u003d\u003d 0 {\n+            return;\n+        }\n+\n         let ifr \u003d self.seq.read_byte(Addr::IFR).unwrap_lite();\n         ringbuf_entry!(Trace::Status {\n             ier: self.seq.read_byte(Addr::IER).unwrap_lite(),\n@@ -685,6 +699,15 @@ impl\u003cS: SpiServer\u003e ServerImpl\u003cS\u003e {\n                     return Err(SeqError::MuxToHostCPUFailed);\n                 }\n \n+                //\n+                // If we fail to initialize our UV warning despite retries, we\n+                // will drive on: the failures will be logged, and this isn\u0027t\n+                // strictly required to sequence.\n+                //\n+                _ \u003d retry_i2c_txn(I2cTxn::VCoreUndervoltageInitialize, || {\n+                    self.vcore.initialize_uv_warning()\n+                });\n+\n                 let start \u003d sys_get_timer().now;\n                 let deadline \u003d start + A0_TIMEOUT_MILLIS;\n \ndiff --git a/drv/gimlet-seq-server/src/vcore.rs b/drv/gimlet-seq-server/src/vcore.rs\nnew file mode 100644\nindex 0000000..dc9bc01\n--- /dev/null\n+++ b/drv/gimlet-seq-server/src/vcore.rs\n@@ -0,0 +1,156 @@\n+// This Source Code Form is subject to the terms of the Mozilla Public\n+// License, v. 2.0. If a copy of the MPL was not distributed with this\n+// file, You can obtain one at https://mozilla.org/MPL/2.0/.\n+\n+///\n+/// We have seen adventures on the V12_SYS_A2 rail in that it will sag from\n+/// 12V to ~8V over a period of about ~4ms, and then rise back 12V over ~7ms.\n+/// This happens only on very few machines, and even then happens very rarely\n+/// (happening once over hours or days), but the consequences are acute:  the\n+/// dip in power results in U.2 drives resetting, and ultimately, the system\n+/// resetting itself.  To better characterize any such dips, we want to use\n+/// one of the rails on of the RAA229618s (specifically, VDD_VCORE) as a\n+/// witness to any V12_SYS_A2 rail fluctuation via its VIN: we set its VIN\n+/// undervoltage warning limit to a value that is lower than any we expect in\n+/// an operable system (but higher than the sags we have observed), and then\n+/// configure its fault output (PWR_CONT1_VCORE_TO_SP_ALERT_L, connected to\n+/// PI14) to generate an interrupt on a falling edge.  Upon the interrupt, we\n+/// will get notification here, and we will record values of VIN as quickly as\n+/// we can.  Each READ_VIN requires 8 bytes, over 3 I2C transactions:\n+///\n+///   [Write + PAGE + rail] [Write + READ_VIN] [Read + MSB + LSB]\n+///\n+/// At our midbus speed of 100kHz, this is ~900µs per READ_VIN.  We gather 50\n+/// of these READ_VIN measurements, along with timestamps before and after the\n+/// operations, and put them all in a ring buffer.  Note that we don\u0027t clear\n+/// faults after this condition; we will wait until the machine next makes an\n+/// A2 to A0 transition to clear faults.\n+///\n+use drv_i2c_api::{I2cDevice, ResponseCode};\n+use drv_i2c_devices::raa229618::Raa229618;\n+use drv_stm32xx_sys_api as sys_api;\n+use ringbuf::*;\n+use sys_api::{gpio_irq_pins::VCORE_TO_SP_ALERT_L, IrqControl};\n+use userlib::*;\n+\n+pub struct VCore {\n+    device: Raa229618,\n+    sys: sys_api::Sys,\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+enum Trace {\n+    Initializing,\n+    Initialized,\n+    LimitLoaded,\n+    FaultsCleared,\n+    Notified,\n+    Fault,\n+    Reading { timestamp: u64, volts: units::Volts },\n+    Error(ResponseCode),\n+    None,\n+}\n+\n+ringbuf!(Trace, 120, Trace::None);\n+\n+///\n+/// We are going to set our input undervoltage warn limit to be 11.75 volts.\n+/// Note that we will not fault if VIN goes below this (that is, we will not\n+/// lose POWER_GOOD), but the part will indicate an input fault and pull\n+/// PWR_CONT1_VCORE_TO_SP_ALERT_L low.\n+///\n+const VCORE_UV_WARN_LIMIT: units::Volts \u003d units::Volts(11.75);\n+\n+///\n+/// We want to collect enough samples (at ~900µs per sample) to adequately\n+/// cover any anticipated dip.  We have seen these have an ~11ms total width\n+/// in the wild, so we give ourselves plenty of margin here and get ~45ms\n+/// of data.\n+///\n+const VCORE_NSAMPLES: usize \u003d 50;\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(not(any(\n+        target_board \u003d \"gimlet-b\",\n+        target_board \u003d \"gimlet-c\",\n+        target_board \u003d \"gimlet-d\",\n+        target_board \u003d \"gimlet-e\",\n+        target_board \u003d \"gimlet-f\",\n+    )))] {\n+        compile_error!(\"RAA229618 VIN monitoring unsupported for this board\");\n+    }\n+}\n+\n+impl VCore {\n+    pub fn new(sys: \u0026sys_api::Sys, device: \u0026I2cDevice, rail: u8) -\u003e Self {\n+        Self {\n+            device: Raa229618::new(device, rail),\n+            sys: sys.clone(),\n+        }\n+    }\n+\n+    pub fn mask(\u0026self) -\u003e u32 {\n+        crate::notifications::VCORE_MASK\n+    }\n+\n+    pub fn initialize_uv_warning(\u0026self) -\u003e Result\u003c(), ResponseCode\u003e {\n+        let sys \u003d \u0026self.sys;\n+\n+        ringbuf_entry!(Trace::Initializing);\n+\n+        // Set our warn limit\n+        self.device.set_vin_uv_warn_limit(VCORE_UV_WARN_LIMIT)?;\n+        ringbuf_entry!(Trace::LimitLoaded);\n+\n+        // Clear our faults\n+        self.device.clear_faults()?;\n+        ringbuf_entry!(Trace::FaultsCleared);\n+\n+        // Set our alert line to be an input\n+        sys.gpio_configure_input(VCORE_TO_SP_ALERT_L, sys_api::Pull::None);\n+        sys.gpio_irq_configure(self.mask(), sys_api::Edge::Falling);\n+\n+        // Enable the interrupt!\n+        let _ \u003d self.sys.gpio_irq_control(self.mask(), IrqControl::Enable);\n+\n+        ringbuf_entry!(Trace::Initialized);\n+\n+        Ok(())\n+    }\n+\n+    pub fn handle_notification(\u0026self) {\n+        let faulted \u003d self.sys.gpio_read(VCORE_TO_SP_ALERT_L) \u003d\u003d 0;\n+\n+        ringbuf_entry!(Trace::Notified);\n+\n+        if faulted {\n+            ringbuf_entry!(Trace::Fault);\n+\n+            for _ in 0..VCORE_NSAMPLES {\n+                match self.device.read_vin() {\n+                    Ok(val) \u003d\u003e {\n+                        //\n+                        // Record our reading, along with a timestamp.  On the\n+                        // one hand, it\u0027s a little exceesive to record a\n+                        // timestamp on every reading:  it\u0027s in milliseconds,\n+                        // and because it takes ~900µs per reading, we expect\n+                        // the timestamp to (basically) be incremented by 1 with\n+                        // every reading (with a duplicate timestamp occuring\n+                        // every ~7-9 entries).  But on the other, it\u0027s not\n+                        // impossible to be preempted, and it\u0027s valuable to have\n+                        // as tight a coupling as possible between observed\n+                        // reading and observed time.\n+                        //\n+                        ringbuf_entry!(Trace::Reading {\n+                            timestamp: sys_get_timer().now,\n+                            volts: val,\n+                        });\n+                    }\n+                    Err(code) \u003d\u003e ringbuf_entry!(Trace::Error(code.into())),\n+                }\n+            }\n+        }\n+\n+        let _ \u003d self.sys.gpio_irq_control(self.mask(), IrqControl::Enable);\n+    }\n+}\ndiff --git a/drv/i2c-devices/src/lib.rs b/drv/i2c-devices/src/lib.rs\nindex fcd8829..4ddafcb 100644\n--- a/drv/i2c-devices/src/lib.rs\n+++ b/drv/i2c-devices/src/lib.rs\n@@ -117,6 +117,18 @@ macro_rules! pmbus_rail_phase_read {\n }\n \n macro_rules! pmbus_write {\n+    ($device:expr, $cmd:ident) \u003d\u003e {{\n+        let payload \u003d [CommandCode::$cmd as u8];\n+\n+        match $device.write(\u0026payload) {\n+            Err(code) \u003d\u003e Err(Error::BadWrite {\n+                cmd: CommandCode::$cmd as u8,\n+                code,\n+            }),\n+            Ok(_) \u003d\u003e Ok(()),\n+        }\n+    }};\n+\n     ($device:expr, $cmd:ident, $data:expr) \u003d\u003e {{\n         let mut payload \u003d [0u8; $cmd::CommandData::len() + 1];\n         payload[0] \u003d $cmd::CommandData::code();\ndiff --git a/drv/i2c-devices/src/raa229618.rs b/drv/i2c-devices/src/raa229618.rs\nindex 3504320..c4a47fa 100644\n--- a/drv/i2c-devices/src/raa229618.rs\n+++ b/drv/i2c-devices/src/raa229618.rs\n@@ -115,6 +115,21 @@ impl Raa229618 {\n         }\n     }\n \n+    pub fn clear_faults(\u0026self) -\u003e Result\u003c(), Error\u003e {\n+        pmbus_write!(self.device, CLEAR_FAULTS)\n+    }\n+\n+    pub fn set_vin_uv_warn_limit(\u0026self, value: Volts) -\u003e Result\u003c(), Error\u003e {\n+        let mut vin \u003d VIN_UV_WARN_LIMIT::CommandData(0);\n+        vin.set(pmbus::units::Volts(value.0))?;\n+        pmbus_rail_write!(self.device, self.rail, VIN_UV_WARN_LIMIT, vin)\n+    }\n+\n+    pub fn read_vin(\u0026self) -\u003e Result\u003cVolts, Error\u003e {\n+        let vin \u003d pmbus_rail_read!(self.device, self.rail, READ_VIN)?;\n+        Ok(Volts(vin.get()?.0))\n+    }\n+\n     pub fn read_phase_current(\u0026self, phase: Phase) -\u003e Result\u003cAmperes, Error\u003e {\n         let iout \u003d pmbus_rail_phase_read!(\n             self.device,","expectedMessage":"add RAA229618 VIN monitoring (#1730)","repository":"hubris-cantrill","commitHash":"a35ea553157462635ef35c6f86f24675063eac97","metadata":{"author":"Bryan Cantrill \u003cbryan@oxide.computer\u003e"}}
{"id":"hubris-cantrill-d663549d","diff":" app/demo-stm32h7-nucleo/app-h743.toml |  2 +-\n app/demo-stm32h7-nucleo/app-h753.toml |  2 +-\n app/gimlet/base.toml                  |  4 +--\n app/gimletlet/app.toml                |  2 +-\n app/psc/base.toml                     |  2 +-\n app/sidecar/base.toml                 |  4 +--\n drv/gimlet-seq-server/src/main.rs     | 66 +++++++++++++++++++++++++++-------\n drv/stm32xx-i2c-server/src/main.rs    | 67 ++++++++++++++++++++++++++++++-----\n task/jefe/src/dump.rs                 | 10 ++++++\n 9 files changed, 129 insertions(+), 30 deletions(-)\n\ndiff --git a/app/demo-stm32h7-nucleo/app-h743.toml b/app/demo-stm32h7-nucleo/app-h743.toml\nindex c8b9c9c..ae97275 100644\n--- a/app/demo-stm32h7-nucleo/app-h743.toml\n+++ b/app/demo-stm32h7-nucleo/app-h743.toml\n@@ -80,7 +80,7 @@ task-slots \u003d [\"sys\"]\n \n [tasks.net]\n name \u003d \"task-net\"\n-stacksize \u003d 3000\n+stacksize \u003d 4000\n priority \u003d 2\n max-sizes \u003d {flash \u003d 65536, ram \u003d 8192, sram1 \u003d 32768}\n features \u003d [\"h743\"]\ndiff --git a/app/demo-stm32h7-nucleo/app-h753.toml b/app/demo-stm32h7-nucleo/app-h753.toml\nindex efa28c1..0909520 100644\n--- a/app/demo-stm32h7-nucleo/app-h753.toml\n+++ b/app/demo-stm32h7-nucleo/app-h753.toml\n@@ -89,7 +89,7 @@ task-slots \u003d [\"sys\"]\n \n [tasks.net]\n name \u003d \"task-net\"\n-stacksize \u003d 3000\n+stacksize \u003d 4000\n priority \u003d 2\n max-sizes \u003d {flash \u003d 131072, ram \u003d 16384, sram1 \u003d 32768}\n features \u003d [\"h753\"]\ndiff --git a/app/gimlet/base.toml b/app/gimlet/base.toml\nindex e9503eb..05a63a6 100644\n--- a/app/gimlet/base.toml\n+++ b/app/gimlet/base.toml\n@@ -37,7 +37,7 @@ request_reset \u003d [\"hiffy\", \"control_plane_agent\"]\n \n [tasks.net]\n name \u003d \"task-net\"\n-stacksize \u003d 6040\n+stacksize \u003d 8000\n priority \u003d 5\n features \u003d [\"mgmt\", \"h753\", \"gimlet\", \"vlan\", \"vpd-mac\"]\n max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1 \u003d 16384}\n@@ -139,7 +139,7 @@ name \u003d \"task-power\"\n features \u003d [\"gimlet\"]\n priority \u003d 6\n max-sizes \u003d {flash \u003d 65536, ram \u003d 16384 }\n-stacksize \u003d 2800\n+stacksize \u003d 3800\n start \u003d true\n task-slots \u003d [\"i2c_driver\", \"sensor\", \"gimlet_seq\"]\n notifications \u003d [\"timer\", \"external_badness\"]\ndiff --git a/app/gimletlet/app.toml b/app/gimletlet/app.toml\nindex a8bce0a..5f89e75 100644\n--- a/app/gimletlet/app.toml\n+++ b/app/gimletlet/app.toml\n@@ -145,7 +145,7 @@ notifications \u003d [\"hash-irq\"]\n \n [tasks.net]\n name \u003d \"task-net\"\n-stacksize \u003d 6040\n+stacksize \u003d 8000\n priority \u003d 3\n features \u003d [\"h753\", \"vlan\", \"gimletlet-nic\", \"use-spi-core\", \"spi4\"]\n max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1 \u003d 16384}\ndiff --git a/app/psc/base.toml b/app/psc/base.toml\nindex 5443d3f..348b875 100644\n--- a/app/psc/base.toml\n+++ b/app/psc/base.toml\n@@ -117,7 +117,7 @@ task-slots \u003d [\"i2c_driver\"]\n \n [tasks.net]\n name \u003d \"task-net\"\n-stacksize \u003d 6040\n+stacksize \u003d 8000\n priority \u003d 4\n features \u003d [\"mgmt\", \"h753\", \"psc\", \"vlan\", \"vpd-mac\", \"use-spi-core\", \"spi2\"]\n max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1 \u003d 16384}\ndiff --git a/app/sidecar/base.toml b/app/sidecar/base.toml\nindex e18eb24..f5e25fa 100644\n--- a/app/sidecar/base.toml\n+++ b/app/sidecar/base.toml\n@@ -78,7 +78,7 @@ task-slots \u003d [\"sys\"]\n \n [tasks.net]\n name \u003d \"task-net\"\n-stacksize \u003d 6040\n+stacksize \u003d 8000\n priority \u003d 5\n features \u003d [\"mgmt\", \"h753\", \"sidecar\", \"vlan\", \"vpd-mac\", \"use-spi-core\", \"spi3\"]\n max-sizes \u003d {flash \u003d 131072, ram \u003d 65536, sram1 \u003d 16384}\n@@ -278,7 +278,7 @@ name \u003d \"task-power\"\n features \u003d [\"sidecar\"]\n priority \u003d 6\n max-sizes \u003d {flash \u003d 32768, ram \u003d 8192 }\n-stacksize \u003d 2800\n+stacksize \u003d 3800\n start \u003d true\n task-slots \u003d [\"i2c_driver\", \"sensor\", \"sequencer\"]\n notifications \u003d [\"timer\"]\ndiff --git a/drv/gimlet-seq-server/src/main.rs b/drv/gimlet-seq-server/src/main.rs\nindex c0ba2d5..38116d6 100644\n--- a/drv/gimlet-seq-server/src/main.rs\n+++ b/drv/gimlet-seq-server/src/main.rs\n@@ -46,6 +46,16 @@ include!(concat!(env!(\"OUT_DIR\"), \"/i2c_config.rs\"));\n )]\n mod payload;\n \n+#[derive(Copy, Clone, PartialEq, Count)]\n+enum I2cTxn {\n+    SpdLoad(u8, u8),\n+    SpdLoadTop(u8, u8),\n+    VCoreOn,\n+    VCoreOff,\n+    SocOn,\n+    SocOff,\n+}\n+\n #[derive(Copy, Clone, PartialEq, Count)]\n enum Trace {\n     Ice40Rails(bool, bool),\n@@ -111,11 +121,17 @@ enum Trace {\n     SpdBankAbsent(u8),\n     SpdAbsent(u8, u8, u8),\n     SpdDimmsFound(usize),\n-    I2cFault {\n-        retries_remaining: u8,\n+    I2cError {\n+        txn: I2cTxn,\n         #[count(children)]\n         code: i2c::ResponseCode,\n     },\n+    I2cFault(I2cTxn),\n+    I2cRetry {\n+        #[count(children)]\n+        txn: I2cTxn,\n+        retries_remaining: u8,\n+    },\n     StartFailed(#[count(children)] SeqError),\n     #[count(skip)]\n     None,\n@@ -592,6 +608,7 @@ impl\u003cS: SpiServer\u003e NotificationHandler for ServerImpl\u003cS\u003e {\n }\n \n fn retry_i2c_txn\u003cT, E\u003e(\n+    which: I2cTxn,\n     mut txn: impl FnMut() -\u003e Result\u003cT, E\u003e,\n ) -\u003e Result\u003cT, i2c::ResponseCode\u003e\n where\n@@ -604,15 +621,18 @@ where\n             Ok(x) \u003d\u003e return Ok(x),\n             Err(e) \u003d\u003e {\n                 let code \u003d e.into();\n-                ringbuf_entry!(Trace::I2cFault {\n-                    retries_remaining,\n-                    code,\n-                });\n+                ringbuf_entry!(Trace::I2cError { txn: which, code });\n \n                 if retries_remaining \u003d\u003d 0 {\n+                    ringbuf_entry!(Trace::I2cFault(which));\n                     return Err(code);\n                 }\n \n+                ringbuf_entry!(Trace::I2cRetry {\n+                    txn: which,\n+                    retries_remaining\n+                });\n+\n                 retries_remaining -\u003d 1;\n             }\n         }\n@@ -1119,7 +1139,20 @@ fn read_spd_data_and_load_packrat(\n             // We\u0027ll store that byte and then read 255 more.\n             tmp[0] \u003d first;\n \n-            retry_i2c_txn(|| spd.read_into(\u0026mut tmp[1..]))?;\n+            let mut retried \u003d false;\n+\n+            retry_i2c_txn(I2cTxn::SpdLoad(nbank, i), || {\n+                if retried {\n+                    //\n+                    // If our read needs to be retried, we need to also reset\n+                    // ourselves back to the 0th byte.\n+                    //\n+                    _ \u003d spd.read_reg::\u003cu8, u8\u003e(0)?;\n+                }\n+\n+                retried \u003d true;\n+                spd.read_into(\u0026mut tmp[1..])\n+            })?;\n \n             packrat.set_spd_eeprom(ndx, false, 0, \u0026tmp);\n         }\n@@ -1146,9 +1179,16 @@ fn read_spd_data_and_load_packrat(\n             let spd \u003d I2cDevice::new(i2c_task, controller, port, mux, mem);\n \n             let chunk \u003d 128;\n-            retry_i2c_txn(|| spd.read_reg_into::\u003cu8\u003e(0, \u0026mut tmp[..chunk]))?;\n \n-            retry_i2c_txn(|| spd.read_into(\u0026mut tmp[chunk..]))?;\n+            retry_i2c_txn(I2cTxn::SpdLoadTop(nbank, i), || {\n+                //\n+                // Both of these reads need to be in a single transaction from\n+                // the perspective of the retry logic: if either fails, we\n+                // must redo both.\n+                //\n+                spd.read_reg_into::\u003cu8\u003e(0, \u0026mut tmp[..chunk])?;\n+                spd.read_into(\u0026mut tmp[chunk..])\n+            })?;\n \n             packrat.set_spd_eeprom(ndx, true, 0, \u0026tmp);\n         }\n@@ -1302,8 +1342,8 @@ cfg_if::cfg_if! {\n             let (device, rail) \u003d i2c_config::pmbus::vddcr_soc(i2c);\n             let mut vddcr_soc \u003d Raa229618::new(\u0026device, rail);\n \n-            retry_i2c_txn(|| vdd_vcore.turn_off())?;\n-            retry_i2c_txn(|| vddcr_soc.turn_off())?;\n+            retry_i2c_txn(I2cTxn::VCoreOff, || vdd_vcore.turn_off())?;\n+            retry_i2c_txn(I2cTxn::SocOff, || vddcr_soc.turn_off())?;\n             Ok(())\n         }\n \n@@ -1317,8 +1357,8 @@ cfg_if::cfg_if! {\n             let (device, rail) \u003d i2c_config::pmbus::vddcr_soc(i2c);\n             let mut vddcr_soc \u003d Raa229618::new(\u0026device, rail);\n \n-            retry_i2c_txn(|| vdd_vcore.turn_on())?;\n-            retry_i2c_txn(|| vddcr_soc.turn_on())?;\n+            retry_i2c_txn(I2cTxn::VCoreOn, || vdd_vcore.turn_on())?;\n+            retry_i2c_txn(I2cTxn::SocOn, || vddcr_soc.turn_on())?;\n             Ok(())\n         }\n \ndiff --git a/drv/stm32xx-i2c-server/src/main.rs b/drv/stm32xx-i2c-server/src/main.rs\nindex a38be81..5073c77 100644\n--- a/drv/stm32xx-i2c-server/src/main.rs\n+++ b/drv/stm32xx-i2c-server/src/main.rs\n@@ -296,6 +296,48 @@ fn reset_if_needed(\n     }\n }\n \n+///\n+/// A variant of [`reset_if_needed`] that will also wiggle the SCL lines\n+/// via [`wiggle_scl`].\n+///\n+fn reset_and_wiggle_if_needed(\n+    code: ResponseCode,\n+    controller: \u0026I2cController\u003c\u0027_\u003e,\n+    port: PortIndex,\n+    muxes: \u0026[I2cMux\u003c\u0027_\u003e],\n+    muxmap: \u0026mut MuxMap,\n+    pins: \u0026[I2cPins],\n+) {\n+    if reset_needed(code) {\n+        let sys \u003d SYS.get_task_id();\n+        let sys \u003d Sys::from(sys);\n+\n+        for pin in pins\n+            .iter()\n+            .filter(|p| p.controller \u003d\u003d controller.controller)\n+            .filter(|p| p.port \u003d\u003d port)\n+        {\n+            wiggle_scl(\u0026sys, pin.scl, pin.sda);\n+\n+            //\n+            // [`wiggle_scl`] puts our pins in output (and input) mode; set\n+            // them back to be configured for I2C before we reset.\n+            //\n+            for gpio_pin in \u0026[pin.scl, pin.sda] {\n+                sys.gpio_configure_alternate(\n+                    *gpio_pin,\n+                    OutputType::OpenDrain,\n+                    Speed::Low,\n+                    Pull::None,\n+                    pin.function,\n+                );\n+            }\n+        }\n+\n+        reset(controller, port, muxes, muxmap);\n+    }\n+}\n+\n include!(concat!(env!(\"OUT_DIR\"), \"/i2c_config.rs\"));\n \n type PortMap \u003d FixedMap\u003cController, PortIndex, { i2c_config::NCONTROLLERS }\u003e;\n@@ -487,12 +529,13 @@ fn main() -\u003e ! {\n                                 }\n                             }\n \n-                            reset_if_needed(\n+                            reset_and_wiggle_if_needed(\n                                 code,\n                                 controller,\n                                 port,\n                                 \u0026muxes,\n                                 \u0026mut muxmap,\n+                                \u0026pins,\n                             );\n                             return Err(code);\n                         }\n@@ -588,17 +631,23 @@ fn configure_port(\n }\n \n ///\n-/// When the system is reset without power loss, I2C can be in an arbitrary\n-/// state with respect to the bus -- and we can therefore come to life with a\n-/// transaction already in flight.  It is very important that we abort any\n-/// such transaction:  failure to do so will result in our first I2C\n-/// transaction being corrupted.  (And especially because our first I2C\n-/// transactions may well be to disable segments on a mux, this can result in\n-/// nearly arbitrary mayhem down the road!)  To do this, we engage in the\n+/// When the system is either reset without power loss (e.g., due to an SP\n+/// upgrade) or I2C is preempted longer than the 25ms I2C timeout (e.g., due\n+/// to a large process panicking and being dumped by jefe), I2C can be in an\n+/// arbitrary state with respect to the bus -- and we can therefore come to\n+/// life with a transaction already in flight.  It is very important that we\n+/// abort any such transaction:  failure to do so will result in our first I2C\n+/// transaction being corrupted.  (And because our first I2C transaction on SP\n+/// boot may well be to disable segments on a mux, this can result in nearly\n+/// arbitrary mayhem down the road!)  To do this, we engage in the\n /// time-honored[0] tradition of \"clocking through the problem\":  wiggling SCL\n /// until we see SDA high, and then pulling SDA low and releasing SCL to\n /// indicate a STOP condition.  (Note that we need to do this up to 9 times to\n-/// assure that we have clocked through the entire transaction.)\n+/// assure that we have clocked through the entire transaction.)  Our assumption\n+/// is that if SCL is being stretched by an errant target, it has been already\n+/// stretched beyond our timeout (25ms); if this is the case, us trying to\n+/// wiggle SCL here won\u0027t actually wiggle SCL -- but unless such a device is\n+/// isolated to a segment on a mux that we can reset, nothing will in fact help.\n ///\n /// [0] Analog Devices. AN-686: Implementing an I2C Reset. 2003.\n ///\ndiff --git a/task/jefe/src/dump.rs b/task/jefe/src/dump.rs\nindex e39d401..7ea79c0 100644\n--- a/task/jefe/src/dump.rs\n+++ b/task/jefe/src/dump.rs\n@@ -55,6 +55,10 @@ enum Trace {\n     },\n     DumpRead(usize),\n     DumpDone(Result\u003c(), humpty::DumpError\u003c()\u003e\u003e),\n+    DumpTime {\n+        start: u64,\n+        end: u64,\n+    },\n }\n \n ringbuf!(Trace, 8, Trace::None);\n@@ -178,6 +182,7 @@ fn dump_task_setup(\n /// Once a task dump is set up, this function executes it\n fn dump_task_run(base: u32, task: usize) -\u003e Result\u003c(), DumpAgentError\u003e {\n     ringbuf_entry!(Trace::DumpStart { base });\n+    let start \u003d sys_get_timer().now;\n \n     //\n     // The humpty dance is your chance... to do the dump!\n@@ -225,6 +230,11 @@ fn dump_task_run(base: u32, task: usize) -\u003e Result\u003c(), DumpAgentError\u003e {\n     );\n \n     ringbuf_entry!(Trace::DumpDone(r));\n+    ringbuf_entry!(Trace::DumpTime {\n+        start,\n+        end: sys_get_timer().now\n+    });\n+\n     r.map_err(|_| DumpAgentError::DumpFailed)?;\n     Ok(())\n }","expectedMessage":"Gimlet hangs on cold power-on after toolchain update (#1742)","repository":"hubris-cantrill","commitHash":"d663549d2751de97374ed5463287393ab0a8d4a6","metadata":{"author":"Bryan Cantrill \u003cbryan@oxide.computer\u003e"}}
{"id":"hubris-cantrill-ff971156","diff":" drv/stm32xx-i2c-server/Cargo.toml | 35 +++++++++++++++++++++++++++++++----\n drv/stm32xx-i2c/src/lib.rs        |  4 ++--\n 2 files changed, 33 insertions(+), 6 deletions(-)\n\ndiff --git a/drv/stm32xx-i2c-server/Cargo.toml b/drv/stm32xx-i2c-server/Cargo.toml\nindex b96d19d..9b23482 100644\n--- a/drv/stm32xx-i2c-server/Cargo.toml\n+++ b/drv/stm32xx-i2c-server/Cargo.toml\n@@ -26,10 +26,37 @@ build-util \u003d { path \u003d \"../../build/util\" }\n build-i2c \u003d { path \u003d \"../../build/i2c\" }\n \n [features]\n-h743 \u003d [\"stm32h7/stm32h743\", \"drv-stm32xx-i2c/h743\", \"drv-stm32xx-sys-api/h743\", \"build-i2c/h743\", \"panic-messages\"]\n-h753 \u003d [\"stm32h7/stm32h753\", \"drv-stm32xx-i2c/h753\", \"drv-stm32xx-sys-api/h753\", \"build-i2c/h753\", \"panic-messages\"]\n-g031 \u003d [\"stm32g0/stm32g031\", \"drv-stm32xx-i2c/g031\", \"drv-stm32xx-sys-api/g031\", \"build-i2c/g031\", \"ringbuf/disabled\", \"panic-messages\"]\n-g030 \u003d [\"stm32g0/stm32g030\", \"drv-stm32xx-i2c/g030\", \"drv-stm32xx-sys-api/g030\", \"build-i2c/g030\", \"ringbuf/disabled\"]\n+h743 \u003d [\n+    \"stm32h7/stm32h743\",\n+    \"drv-stm32xx-i2c/h743\",\n+    \"drv-stm32xx-sys-api/h743\",\n+    \"build-i2c/h743\",\n+    \"panic-messages\",\n+]\n+h753 \u003d [\n+    \"stm32h7/stm32h753\",\n+    \"drv-stm32xx-i2c/h753\",\n+    \"drv-stm32xx-sys-api/h753\",\n+    \"build-i2c/h753\",\n+    \"panic-messages\",\n+]\n+g031 \u003d [\n+    \"stm32g0/stm32g031\",\n+    \"drv-stm32xx-i2c/g031\",\n+    \"drv-stm32xx-sys-api/g031\",\n+    \"build-i2c/g031\",\n+    \"ringbuf-disabled\",\n+    \"panic-messages\",\n+]\n+g030 \u003d [\n+    \"stm32g0/stm32g030\",\n+    \"drv-stm32xx-i2c/g030\",\n+    \"drv-stm32xx-sys-api/g030\",\n+    \"build-i2c/g030\",\n+    \"ringbuf-disabled\",\n+]\n+\n+ringbuf-disabled \u003d [\"ringbuf/disabled\", \"ringbuf/counters-disabled\"]\n panic-messages \u003d [\"userlib/panic-messages\"]\n no-ipc-counters \u003d [\"idol/no-counters\"]\n \ndiff --git a/drv/stm32xx-i2c/src/lib.rs b/drv/stm32xx-i2c/src/lib.rs\nindex caf769f..513590c 100644\n--- a/drv/stm32xx-i2c/src/lib.rs\n+++ b/drv/stm32xx-i2c/src/lib.rs\n@@ -201,14 +201,14 @@ enum Trace {\n     WaitTx,\n     BusySleep,\n     Stop,\n-    RepeatedStart(bool),\n+    RepeatedStart(#[count(children)] bool),\n     LostInterrupt,\n     Panic(Register, u32),\n     #[count(skip)]\n     None,\n }\n \n-ringbuf!(Trace, 48, Trace::None);\n+counted_ringbuf!(Trace, 48, Trace::None);\n \n impl I2cMux\u003c\u0027_\u003e {\n     /// A convenience routine to translate an error induced by in-band","expectedMessage":"i2c_driver should use a counted ringbuf (#1660)","repository":"hubris-cantrill","commitHash":"ff97115687e1b96e6f5d6a5794411907a3efd0d8","metadata":{"author":"Bryan Cantrill \u003cbryan@oxide.computer\u003e"}}
{"id":"hubris-cantrill-97a635f7","diff":" Cargo.lock                            |   1 +\n app/demo-stm32h7-nucleo/app-h743.toml |   1 +\n app/demo-stm32h7-nucleo/app-h753.toml |   1 +\n app/gemini-bu/app.toml                |   1 +\n app/gimlet/base.toml                  |   5 +-\n app/gimletlet/base-gimletlet2.toml    |   1 +\n app/psc/base.toml                     |   5 +-\n app/sidecar/base.toml                 |   5 +-\n drv/stm32xx-i2c-server/src/main.rs    |  23 +++++-\n drv/stm32xx-i2c/Cargo.toml            |   1 +\n drv/stm32xx-i2c/src/lib.rs            | 146 +++++++++++++++++++++++++++-------\n task/spd/src/main.rs                  |   4 +-\n 12 files changed, 153 insertions(+), 41 deletions(-)\n\ndiff --git a/Cargo.lock b/Cargo.lock\nindex 68764d7..9759d93 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1958,6 +1958,7 @@ dependencies \u003d [\n  \"bitfield 0.13.2\",\n  \"build-util\",\n  \"cfg-if\",\n+ \"counters\",\n  \"drv-i2c-api\",\n  \"drv-stm32xx-sys-api\",\n  \"num-traits\",\ndiff --git a/app/demo-stm32h7-nucleo/app-h743.toml b/app/demo-stm32h7-nucleo/app-h743.toml\nindex aeef5d5..95a6e6e 100644\n--- a/app/demo-stm32h7-nucleo/app-h743.toml\n+++ b/app/demo-stm32h7-nucleo/app-h743.toml\n@@ -34,6 +34,7 @@ task-slots \u003d [\"jefe\"]\n \n [tasks.i2c_driver]\n name \u003d \"drv-stm32xx-i2c-server\"\n+stacksize \u003d 1048\n features \u003d [\"h743\"]\n priority \u003d 2\n max-sizes \u003d {flash \u003d 16384, ram \u003d 4096}\ndiff --git a/app/demo-stm32h7-nucleo/app-h753.toml b/app/demo-stm32h7-nucleo/app-h753.toml\nindex 45c4498..ce49a81 100644\n--- a/app/demo-stm32h7-nucleo/app-h753.toml\n+++ b/app/demo-stm32h7-nucleo/app-h753.toml\n@@ -34,6 +34,7 @@ task-slots \u003d [\"jefe\"]\n \n [tasks.i2c_driver]\n name \u003d \"drv-stm32xx-i2c-server\"\n+stacksize \u003d 1048\n features \u003d [\"h753\"]\n priority \u003d 2\n max-sizes \u003d {flash \u003d 16384, ram \u003d 4096}\ndiff --git a/app/gemini-bu/app.toml b/app/gemini-bu/app.toml\nindex 869c515..d380e37 100644\n--- a/app/gemini-bu/app.toml\n+++ b/app/gemini-bu/app.toml\n@@ -32,6 +32,7 @@ task-slots \u003d [\"jefe\"]\n \n [tasks.i2c_driver]\n name \u003d \"drv-stm32xx-i2c-server\"\n+stacksize \u003d 1048\n features \u003d [\"h753\"]\n priority \u003d 2\n max-sizes \u003d {flash \u003d 16384, ram \u003d 4096}\ndiff --git a/app/gimlet/base.toml b/app/gimlet/base.toml\nindex e554d0c..b1cf64d 100644\n--- a/app/gimlet/base.toml\n+++ b/app/gimlet/base.toml\n@@ -71,6 +71,7 @@ notifications \u003d [\"spi-irq\"]\n \n [tasks.i2c_driver]\n name \u003d \"drv-stm32xx-i2c-server\"\n+stacksize \u003d 1048\n features \u003d [\"h753\"]\n priority \u003d 3\n max-sizes \u003d {flash \u003d 16384, ram \u003d 4096}\n@@ -125,7 +126,7 @@ name \u003d \"task-power\"\n features \u003d [\"gimlet\"]\n priority \u003d 6\n max-sizes \u003d {flash \u003d 65536, ram \u003d 16384 }\n-stacksize \u003d 2504\n+stacksize \u003d 2800\n start \u003d true\n task-slots \u003d [\"i2c_driver\", \"sensor\", \"gimlet_seq\"]\n notifications \u003d [\"timer\"]\n@@ -135,7 +136,7 @@ name \u003d \"task-hiffy\"\n features \u003d [\"h753\", \"stm32h7\", \"i2c\", \"gpio\", \"spi\", \"qspi\", \"hash\", \"sprot\"]\n priority \u003d 5\n max-sizes \u003d {flash \u003d 32768, ram \u003d 32768 }\n-stacksize \u003d 1024\n+stacksize \u003d 1200\n start \u003d true\n task-slots \u003d [\"sys\", \"hf\", \"i2c_driver\", \"hash_driver\", \"update_server\", \"sprot\"]\n \ndiff --git a/app/gimletlet/base-gimletlet2.toml b/app/gimletlet/base-gimletlet2.toml\nindex dcb1dc4..dffb02e 100644\n--- a/app/gimletlet/base-gimletlet2.toml\n+++ b/app/gimletlet/base-gimletlet2.toml\n@@ -33,6 +33,7 @@ task-slots \u003d [\"jefe\"]\n \n [tasks.i2c_driver]\n name \u003d \"drv-stm32xx-i2c-server\"\n+stacksize \u003d 1048\n features \u003d [\"h753\"]\n priority \u003d 2\n max-sizes \u003d {flash \u003d 16384, ram \u003d 4096}\ndiff --git a/app/psc/base.toml b/app/psc/base.toml\nindex 4f1ed45..c65c9af 100644\n--- a/app/psc/base.toml\n+++ b/app/psc/base.toml\n@@ -43,6 +43,7 @@ task-slots \u003d [\"jefe\"]\n \n [tasks.i2c_driver]\n name \u003d \"drv-stm32xx-i2c-server\"\n+stacksize \u003d 1048\n features \u003d [\"h753\"]\n priority \u003d 2\n max-sizes \u003d {flash \u003d 16384, ram \u003d 4096}\n@@ -88,7 +89,7 @@ name \u003d \"task-hiffy\"\n features \u003d [\"h753\", \"stm32h7\", \"i2c\", \"gpio\", \"sprot\"]\n priority \u003d 5\n max-sizes \u003d {flash \u003d 32768, ram \u003d 16384 }\n-stacksize \u003d 1024\n+stacksize \u003d 1200\n start \u003d true\n task-slots \u003d [\"sys\", \"i2c_driver\", \"sprot\"]\n \n@@ -207,7 +208,7 @@ notifications \u003d [\"timer\"]\n name \u003d \"task-power\"\n priority \u003d 4\n max-sizes \u003d {flash \u003d 32768, ram \u003d 4096}\n-stacksize \u003d 1504\n+stacksize \u003d 2504\n start \u003d true\n task-slots \u003d [\"i2c_driver\", \"sensor\", \"sys\"]\n features \u003d [\"psc\"]\ndiff --git a/app/sidecar/base.toml b/app/sidecar/base.toml\nindex d9174dc..1a5af3c 100644\n--- a/app/sidecar/base.toml\n+++ b/app/sidecar/base.toml\n@@ -150,6 +150,7 @@ interrupts \u003d {\"spi2.irq\" \u003d \"spi-irq\"}\n \n [tasks.i2c_driver]\n name \u003d \"drv-stm32xx-i2c-server\"\n+stacksize \u003d 1048\n features \u003d [\"h753\"]\n priority \u003d 2\n max-sizes \u003d {flash \u003d 16384, ram \u003d 4096}\n@@ -173,7 +174,7 @@ name \u003d \"task-hiffy\"\n features \u003d [\"h753\", \"stm32h7\", \"i2c\", \"gpio\", \"sprot\"]\n priority \u003d 5\n max-sizes \u003d {flash \u003d 32768, ram \u003d 32768 }\n-stacksize \u003d 1024\n+stacksize \u003d 1200\n start \u003d true\n task-slots \u003d [\"sys\", \"i2c_driver\", \"sprot\"]\n \n@@ -264,7 +265,7 @@ name \u003d \"task-power\"\n features \u003d [\"sidecar\"]\n priority \u003d 6\n max-sizes \u003d {flash \u003d 32768, ram \u003d 8192 }\n-stacksize \u003d 2048\n+stacksize \u003d 2800\n start \u003d true\n task-slots \u003d [\"i2c_driver\", \"sensor\", \"sequencer\"]\n notifications \u003d [\"timer\"]\ndiff --git a/drv/stm32xx-i2c-server/src/main.rs b/drv/stm32xx-i2c-server/src/main.rs\nindex 700f8ab..def47b7 100644\n--- a/drv/stm32xx-i2c-server/src/main.rs\n+++ b/drv/stm32xx-i2c-server/src/main.rs\n@@ -240,7 +240,7 @@ enum Trace {\n     None,\n }\n \n-ringbuf!(Trace, 174, Trace::None);\n+ringbuf!(Trace, 160, Trace::None);\n \n fn reset(\n     controller: \u0026I2cController\u003c\u0027_\u003e,\n@@ -340,8 +340,25 @@ fn main() -\u003e ! {\n         enable: |notification| {\n             sys_irq_control(notification, true);\n         },\n-        wfi: |notification| {\n-            let _ \u003d sys_recv_closed(\u0026mut [], notification, TaskId::KERNEL);\n+        wfi: |notification, timeout| {\n+            const TIMER_NOTIFICATION: u32 \u003d 1 \u003c\u003c 31;\n+\n+            let dead \u003d sys_get_timer().now.checked_add(timeout.0).unwrap_lite();\n+            sys_set_timer(Some(dead), TIMER_NOTIFICATION);\n+\n+            let m \u003d sys_recv_closed(\n+                \u0026mut [],\n+                notification | TIMER_NOTIFICATION,\n+                TaskId::KERNEL,\n+            )\n+            .unwrap_lite();\n+\n+            if m.operation \u003d\u003d TIMER_NOTIFICATION {\n+                I2cControlResult::TimedOut\n+            } else {\n+                sys_set_timer(None, TIMER_NOTIFICATION);\n+                I2cControlResult::Interrupted\n+            }\n         },\n     };\n \ndiff --git a/drv/stm32xx-i2c/Cargo.toml b/drv/stm32xx-i2c/Cargo.toml\nindex ff19c4e..57f589d 100644\n--- a/drv/stm32xx-i2c/Cargo.toml\n+++ b/drv/stm32xx-i2c/Cargo.toml\n@@ -14,6 +14,7 @@ zerocopy \u003d { workspace \u003d true }\n drv-i2c-api \u003d { path \u003d \"../i2c-api\" }\n drv-stm32xx-sys-api \u003d { path \u003d \"../stm32xx-sys-api\" }\n ringbuf \u003d { path \u003d \"../../lib/ringbuf\" }\n+counters \u003d { path \u003d \"../../lib/counters\" }\n userlib \u003d { path \u003d \"../../sys/userlib\" }\n \n [features]\ndiff --git a/drv/stm32xx-i2c/src/lib.rs b/drv/stm32xx-i2c/src/lib.rs\nindex 3a17d75..caf769f 100644\n--- a/drv/stm32xx-i2c/src/lib.rs\n+++ b/drv/stm32xx-i2c/src/lib.rs\n@@ -73,6 +73,16 @@ pub struct I2cController\u003c\u0027a\u003e {\n     pub registers: \u0026\u0027a RegisterBlock,\n }\n \n+///\n+/// A structure to denote an absolute number of ticks to wait.\n+///\n+pub struct I2cTimeout(pub u64);\n+\n+pub enum I2cControlResult {\n+    Interrupted,\n+    TimedOut,\n+}\n+\n ///\n /// A structure that defines interrupt control flow functions that will be\n /// used to pass control flow into the kernel to either enable or wait for\n@@ -80,6 +90,11 @@ pub struct I2cController\u003c\u0027a\u003e {\n /// allowing the [`I2cMuxDriver`] trait to itself be a trait object.\n ///\n pub struct I2cControl {\n+    pub enable: fn(u32),\n+    pub wfi: fn(u32, I2cTimeout) -\u003e I2cControlResult,\n+}\n+\n+pub struct I2cTargetControl {\n     pub enable: fn(u32),\n     pub wfi: fn(u32),\n }\n@@ -148,33 +163,48 @@ pub enum ReadLength {\n     Variable,\n }\n \n+#[allow(clippy::upper_case_acronyms)]\n #[derive(Copy, Clone, Eq, PartialEq)]\n+enum Register {\n+    CR1,\n+    CR2,\n+    OAR1,\n+    OAR2,\n+    TIMINGR,\n+    TIMEOUTR,\n+    ISR,\n+    PECR,\n+}\n+\n+#[derive(Copy, Clone, Eq, PartialEq, counters::Count)]\n enum Trace {\n-    WaitISR(u32),\n-    WriteISR(u32),\n-    WriteWaitISR(u32),\n-    ReadISR(u32),\n-    ReadWaitISR(u32),\n-    RxISR(u32),\n-    KonamiISR(u32),\n-    Konami(I2cKonamiCode),\n-    ResetISR(u32),\n-    ResetCR2(u32),\n-    AddrISR(u32),\n+    Wait(Register, u32),\n+    Write(Register, u32),\n+    WriteWait(Register, u32),\n+    Read(Register, u32),\n+    ReadWait(Register, u32),\n+    KonamiOperation(I2cKonamiCode),\n+    Konami(Register, u32),\n+    Reset(Register, u32),\n+    Addr(Register, u32),\n     AddrMatch,\n     AddrNack(u8),\n+    RxReg(Register, u32),\n     Rx(u8, u8),\n     RxNack(u8, u8),\n     Tx(u8, u8),\n     TxBogus(u8),\n     TxOverrun(u8),\n-    TxISR(u32),\n+    TxReg(Register, u32),\n     WaitAddr,\n     WaitRx,\n     WaitTx,\n     BusySleep,\n     Stop,\n     RepeatedStart(bool),\n+    LostInterrupt,\n+    Panic(Register, u32),\n+    #[count(skip)]\n     None,\n }\n \n@@ -427,7 +457,7 @@ impl I2cController\u003c\u0027_\u003e {\n         // ...wait until we see it disabled.\n         loop {\n             let cr1 \u003d i2c.cr1.read();\n-            ringbuf_entry!(Trace::ResetISR(cr1.bits()));\n+            ringbuf_entry!(Trace::Reset(Register::CR1, cr1.bits()));\n             if cr1.pe().is_disabled() {\n                 break;\n             }\n@@ -436,7 +466,7 @@ impl I2cController\u003c\u0027_\u003e {\n         // And then finally set it\n         i2c.cr1.modify(|_, w| w.pe().set_bit());\n \n-        ringbuf_entry!(Trace::ResetCR2(i2c.cr2.read().bits()));\n+        ringbuf_entry!(Trace::Reset(Register::CR2, i2c.cr2.read().bits()));\n     }\n \n     ///\n@@ -466,6 +496,62 @@ impl I2cController\u003c\u0027_\u003e {\n         Ok(())\n     }\n \n+    ///\n+    /// A routine to panic.  This should not be called merely because something\n+    /// has gone wrong with a device (which should rather be indicated by\n+    /// returning an error and resetting the controller if/as needed), but with\n+    /// the controller itself.\n+    ///\n+    fn panic(\u0026self) -\u003e ! {\n+        let i2c \u003d self.registers;\n+        let tgr \u003d \u0026i2c.timingr;\n+        let tor \u003d \u0026i2c.timeoutr;\n+\n+        ringbuf_entry!(Trace::Panic(Register::CR1, i2c.cr1.read().bits()));\n+        ringbuf_entry!(Trace::Panic(Register::CR2, i2c.cr2.read().bits()));\n+        ringbuf_entry!(Trace::Panic(Register::OAR1, i2c.oar1.read().bits()));\n+        ringbuf_entry!(Trace::Panic(Register::OAR2, i2c.oar2.read().bits()));\n+        ringbuf_entry!(Trace::Panic(Register::TIMINGR, tgr.read().bits()));\n+        ringbuf_entry!(Trace::Panic(Register::TIMEOUTR, tor.read().bits()));\n+        ringbuf_entry!(Trace::Panic(Register::ISR, i2c.isr.read().bits()));\n+        ringbuf_entry!(Trace::Panic(Register::PECR, i2c.pecr.read().bits()));\n+\n+        panic!();\n+    }\n+\n+    ///\n+    /// A common routine to wait for interrupts with a timeout.\n+    ///\n+    fn wfi(\u0026self, ctrl: \u0026I2cControl) -\u003e Result\u003c(), drv_i2c_api::ResponseCode\u003e {\n+        //\n+        // A 100 ms timeout is much, much longer than the I2C timeouts.\n+        //\n+        const TIMEOUT: I2cTimeout \u003d I2cTimeout(100);\n+\n+        match (ctrl.wfi)(self.notification, TIMEOUT) {\n+            I2cControlResult::TimedOut \u003d\u003e {\n+                //\n+                // This really shouldn\u0027t happen:  it means that not only did\n+                // we not get our expected interrupt, but that the configured\n+                // timeout in the I2C block also didn\u0027t function as expected.\n+                // That said, we got our OS timer interrupt (or we wouldn\u0027t be\n+                // here at all), which gives us at least control.  While we\n+                // could conceivably return an error code in this condition,\n+                // this condition is so unexpected that we want to instead\n+                // make sure we can debug it:  we are going to instead call\n+                // our panic routine, which will record some additional data\n+                // from the I2C controller and explicitly panic.  This will\n+                // result in a dump that will effectively preserve this state,\n+                // and will (hopefuflly) allow it to be debugged long after it\n+                // happens.\n+                //\n+                ringbuf_entry!(Trace::LostInterrupt);\n+                self.panic();\n+            }\n+            I2cControlResult::Interrupted \u003d\u003e Ok(()),\n+        }\n+    }\n+\n     fn wait_until_notbusy(\u0026self) -\u003e Result\u003c(), drv_i2c_api::ResponseCode\u003e {\n         let i2c \u003d self.registers;\n \n@@ -484,7 +570,7 @@ impl I2cController\u003c\u0027_\u003e {\n \n         for lap in 0..\u003dBUSY_SLEEP_THRESHOLD + 1 {\n             let isr \u003d i2c.isr.read();\n-            ringbuf_entry!(Trace::WaitISR(isr.bits()));\n+            ringbuf_entry!(Trace::Wait(Register::ISR, isr.bits()));\n \n             //\n             // For reasons unclear and unknown, the timeout flag can become\n@@ -570,7 +656,7 @@ impl I2cController\u003c\u0027_\u003e {\n             while pos \u003c wlen {\n                 loop {\n                     let isr \u003d i2c.isr.read();\n-                    ringbuf_entry!(Trace::WriteISR(isr.bits()));\n+                    ringbuf_entry!(Trace::Write(Register::ISR, isr.bits()));\n \n                     self.check_errors(\u0026isr)?;\n \n@@ -583,7 +669,7 @@ impl I2cController\u003c\u0027_\u003e {\n                         break;\n                     }\n \n-                    (ctrl.wfi)(notification);\n+                    self.wfi(ctrl)?;\n                     (ctrl.enable)(notification);\n                 }\n \n@@ -600,7 +686,7 @@ impl I2cController\u003c\u0027_\u003e {\n             // we\u0027ve been NACK\u0027d (denoting an illegal register value)\n             loop {\n                 let isr \u003d i2c.isr.read();\n-                ringbuf_entry!(Trace::WriteWaitISR(isr.bits()));\n+                ringbuf_entry!(Trace::WriteWait(Register::ISR, isr.bits()));\n \n                 self.check_errors(\u0026isr)?;\n \n@@ -613,7 +699,7 @@ impl I2cController\u003c\u0027_\u003e {\n                     break;\n                 }\n \n-                (ctrl.wfi)(notification);\n+                self.wfi(ctrl)?;\n                 (ctrl.enable)(notification);\n             }\n         }\n@@ -661,11 +747,11 @@ impl I2cController\u003c\u0027_\u003e {\n                 }\n \n                 loop {\n-                    (ctrl.wfi)(notification);\n+                    self.wfi(ctrl)?;\n                     (ctrl.enable)(notification);\n \n                     let isr \u003d i2c.isr.read();\n-                    ringbuf_entry!(Trace::ReadISR(isr.bits()));\n+                    ringbuf_entry!(Trace::Read(Register::ISR, isr.bits()));\n \n                     self.check_errors(\u0026isr)?;\n \n@@ -708,7 +794,7 @@ impl I2cController\u003c\u0027_\u003e {\n             // All done; now block until our transfer is complete...\n             loop {\n                 let isr \u003d i2c.isr.read();\n-                ringbuf_entry!(Trace::ReadWaitISR(isr.bits()));\n+                ringbuf_entry!(Trace::ReadWait(Register::ISR, isr.bits()));\n \n                 if isr.tc().is_complete() {\n                     break;\n@@ -716,7 +802,7 @@ impl I2cController\u003c\u0027_\u003e {\n \n                 self.check_errors(\u0026isr)?;\n \n-                (ctrl.wfi)(notification);\n+                self.wfi(ctrl)?;\n                 (ctrl.enable)(notification);\n             }\n         }\n@@ -764,7 +850,7 @@ impl I2cController\u003c\u0027_\u003e {\n                 I2cKonamiCode::Read \u003d\u003e true,\n             };\n \n-            ringbuf_entry!(Trace::Konami(*op));\n+            ringbuf_entry!(Trace::KonamiOperation(*op));\n \n             #[rustfmt::skip]\n             i2c.cr2.modify(|_, w| { w\n@@ -782,7 +868,7 @@ impl I2cController\u003c\u0027_\u003e {\n             // at our Konami Code sequence).\n             loop {\n                 let isr \u003d i2c.isr.read();\n-                ringbuf_entry!(Trace::KonamiISR(isr.bits()));\n+                ringbuf_entry!(Trace::Konami(Register::ISR, isr.bits()));\n \n                 self.check_errors(\u0026isr)?;\n \n@@ -795,7 +881,7 @@ impl I2cController\u003c\u0027_\u003e {\n                     break;\n                 }\n \n-                (ctrl.wfi)(notification);\n+                self.wfi(ctrl)?;\n                 (ctrl.enable)(notification);\n             }\n         }\n@@ -846,7 +932,7 @@ impl I2cController\u003c\u0027_\u003e {\n \n     pub fn operate_as_target(\n         \u0026self,\n-        ctrl: \u0026I2cControl,\n+        ctrl: \u0026I2cTargetControl,\n         mut initiate: impl FnMut(u8) -\u003e bool,\n         mut rxbyte: impl FnMut(u8, u8),\n         mut txbyte: impl FnMut(u8) -\u003e Option\u003cu8\u003e,\n@@ -866,7 +952,7 @@ impl I2cController\u003c\u0027_\u003e {\n             // Wait to be addressed.\n             let (is_write, addr) \u003d loop {\n                 let isr \u003d i2c.isr.read();\n-                ringbuf_entry!(Trace::AddrISR(isr.bits()));\n+                ringbuf_entry!(Trace::Addr(Register::ISR, isr.bits()));\n \n                 // We expect STOPF to have been handled by the transaction loop\n                 // below, but given that there may be other irrelevant\n@@ -929,7 +1015,7 @@ impl I2cController\u003c\u0027_\u003e {\n                 // handle below.\n                 \u0027rxloop: loop {\n                     let isr \u003d i2c.isr.read();\n-                    ringbuf_entry!(Trace::RxISR(isr.bits()));\n+                    ringbuf_entry!(Trace::RxReg(Register::ISR, isr.bits()));\n \n                     // Note: the order of interrupt flag handling in this\n                     // routine is important. More details interleaved below.\n@@ -1025,7 +1111,7 @@ impl I2cController\u003c\u0027_\u003e {\n \n             \u0027txloop: loop {\n                 let isr \u003d i2c.isr.read();\n-                ringbuf_entry!(Trace::TxISR(isr.bits()));\n+                ringbuf_entry!(Trace::TxReg(Register::ISR, isr.bits()));\n \n                 // First, we want to see if we\u0027re still transmitting.\n \ndiff --git a/task/spd/src/main.rs b/task/spd/src/main.rs\nindex 6a075ec..64ad7a2 100644\n--- a/task/spd/src/main.rs\n+++ b/task/spd/src/main.rs\n@@ -25,7 +25,7 @@ use core::cell::Cell;\n use core::cell::RefCell;\n use drv_gimlet_seq_api::NUM_SPD_BANKS;\n use drv_gimlet_state::PowerState;\n-use drv_stm32xx_i2c::{I2cControl, I2cPins};\n+use drv_stm32xx_i2c::{I2cPins, I2cTargetControl};\n use drv_stm32xx_sys_api::{OutputType, Pull, Speed, Sys};\n use ringbuf::{ringbuf, ringbuf_entry};\n use task_jefe_api::Jefe;\n@@ -249,7 +249,7 @@ fn main() -\u003e ! {\n         rval\n     };\n \n-    let ctrl \u003d I2cControl {\n+    let ctrl \u003d I2cTargetControl {\n         enable: |notification| {\n             sys_irq_control(notification, true);\n         },","expectedMessage":"prevent I2C from hanging on lost interrupt (#1657)","repository":"hubris-cantrill","commitHash":"97a635f7e4c33f578ccba4f158bc82de068296ed","metadata":{"author":"Bryan Cantrill \u003cbryan@oxide.computer\u003e"}}
