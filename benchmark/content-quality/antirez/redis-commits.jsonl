{"id":"redis-antirez-60a4fa2e","diff":" modules/vector-sets/README.md | 4 ----\n 1 file changed, 4 deletions(-)\n\ndiff --git a/modules/vector-sets/README.md b/modules/vector-sets/README.md\nindex 6bacfe0..be87ff3 100644\n--- a/modules/vector-sets/README.md\n+++ b/modules/vector-sets/README.md\n@@ -721,10 +721,6 @@ During Vector Sets testing, we discovered that often clients introduce considera\n \n Switching from `VALUES` to `FP32` as a method for transmitting vectors may easily provide 10-20x speedups.\n \n-# Known bugs\n-\n-* Replication code is pretty much untested, and very vanilla (replicating the commands verbatim).\n-\n # Implementation details\n \n Vector sets are based on the `hnsw.c` implementation of the HNSW data structure with extensions for speed and functionality.","expectedMessage":"Vsets: Remove stale note about replication from README. (#14528)","repository":"redis-antirez","commitHash":"60a4fa2e4bff47b5d3d1c905d2e9ca2a538a6378","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-391530cd","diff":" src/redis-cli.c | 270 ++++++++++++++++++++++++++++++++++++++++++++++++++++++--\n 1 file changed, 265 insertions(+), 5 deletions(-)\n\ndiff --git a/src/redis-cli.c b/src/redis-cli.c\nindex dd5a768..19627d7 100644\n--- a/src/redis-cli.c\n+++ b/src/redis-cli.c\n@@ -209,6 +209,11 @@ static struct config {\n     int monitor_mode;\n     int pubsub_mode;\n     int blocking_state_aborted; /* used to abort monitor_mode and pubsub_mode. */\n+    int vset_recall_mode;\n+    sds vset_recall_key;\n+    int vset_recall_ele_count;\n+    int vset_recall_vsim_count;\n+    int vset_recall_vsim_ef;\n     int latency_mode;\n     int latency_dist_mode;\n     int latency_history;\n@@ -2769,6 +2774,21 @@ static int parseOptions(int argc, char **argv) {\n         } else if (!strcmp(argv[i],\"--latency-history\")) {\n             config.latency_mode \u003d 1;\n             config.latency_history \u003d 1;\n+        } else if (!strcmp(argv[i],\"--vset-recall\") \u0026\u0026 !lastarg) {\n+            config.vset_recall_mode \u003d 1;\n+            config.vset_recall_key \u003d sdsnew(argv[++i]);\n+        } else if (!strcmp(argv[i],\"--vset-recall-ele\") \u0026\u0026 !lastarg) {\n+            config.vset_recall_ele_count \u003d strtoll(argv[++i],NULL,10);\n+            if (config.vset_recall_ele_count \u003c\u003d 0)\n+                config.vset_recall_ele_count \u003d 1;\n+        } else if (!strcmp(argv[i],\"--vset-recall-count\") \u0026\u0026 !lastarg) {\n+            config.vset_recall_vsim_count \u003d strtoll(argv[++i],NULL,10);\n+            if (config.vset_recall_vsim_count \u003c\u003d 0)\n+                config.vset_recall_vsim_count \u003d 1;\n+        } else if (!strcmp(argv[i],\"--vset-recall-ef\") \u0026\u0026 !lastarg) {\n+            config.vset_recall_vsim_ef \u003d strtoll(argv[++i],NULL,10);\n+            if (config.vset_recall_vsim_ef \u003c\u003d 0)\n+                config.vset_recall_vsim_ef \u003d 1;\n         } else if (!strcmp(argv[i],\"--lru-test\") \u0026\u0026 !lastarg) {\n             config.lru_test_mode \u003d 1;\n             config.lru_test_sample_size \u003d strtoll(argv[++i],NULL,10);\n@@ -3188,6 +3208,14 @@ version,tls_usage);\n \"                     Default time interval is 15 sec. Change it using -i.\\n\"\n \"  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.\\n\"\n \"                     Default time interval is 1 sec. Change it using -i.\\n\"\n+\"  --vset-recall \u003ckey\u003e Enable VSIM recall test mode for the specified key\\n\"\n+\"                     (that must be a vector set). Random vectors are created\\n\"\n+\"                     mixing components from other elements. A VSIM is then\\n\"\n+\"                     executed and checked against ground truth.\\n\"\n+\"  --vset-recall-count \u003ccount\u003e How many top elements to fetch per query.\\n\"\n+\"  --vset-recall-ef \u003cef\u003e HSNW EF (search effort) to use. Default 500.\\n\"\n+\"  --vset-recall-ele \u003ccount\u003e Number of elements used to compose query vectors\\n\"\n+\"                            Default 1.\\n\"\n \"  --lru-test \u003ckeys\u003e  Simulate a cache workload with an 80-20 distribution.\\n\"\n \"  --replica          Simulate a replica showing commands received from the master.\\n\"\n \"  --rdb \u003cfilename\u003e   Transfer an RDB dump from remote server to local file.\\n\"\n@@ -3663,6 +3691,11 @@ static int noninteractive(int argc, char **argv) {\n     return retval \u003d\u003d REDIS_OK ? 0 : 1;\n }\n \n+static void longStatLoopModeStop(int s) {\n+    UNUSED(s);\n+    force_cancel_loop \u003d 1;\n+}\n+\n /*------------------------------------------------------------------------------\n  * Eval mode\n  *--------------------------------------------------------------------------- */\n@@ -8571,6 +8604,227 @@ static void latencyDistMode(void) {\n     }\n }\n \n+/*------------------------------------------------------------------------------\n+ * Vset recall mode.\n+ *\n+ * This mode targets a specific vector set key, performing queries on\n+ * vectors composed mixing components from existing vectors (each component of\n+ * the query vector is the component of a random source vector), then uses\n+ * VSIM and VSIM TRUTH to test for recall percentage.\n+ *--------------------------------------------------------------------------- */\n+static void vsetRecallMode(void) {\n+    redisReply *reply, *vsim_reply, *truth_reply;\n+    int ele_count \u003d config.vset_recall_ele_count;\n+    int vsim_count \u003d config.vset_recall_vsim_count;\n+    int vsim_ef \u003d config.vset_recall_vsim_ef;\n+    unsigned long long queries \u003d 0, total_overlap \u003d 0;\n+    long long refresh_time \u003d mstime();\n+    struct hdr_histogram *recall_histogram;\n+\n+    if (!context) exit(1);\n+\n+    /* HDR histogram requires minimum value \u003e\u003d 1 for some reason.\n+     * We store recall percentages as:\n+     * (recall% * 100) + 1, giving us range 1 to 10001.\n+     * This maps: 0.00% -\u003e 1, 50.00% -\u003e 5001, 100.00% -\u003e 10001\n+     * Precision: 2 significant figures \u003d 0.01% accuracy. */\n+    if (hdr_init(1, 10001, 2, \u0026recall_histogram)) {\n+        fprintf(stderr, \"Failed to initialize recall histogram\\n\");\n+        exit(1);\n+    }\n+\n+    /* Get vector dimension. */\n+    reply \u003d reconnectingRedisCommand(context, \"VDIM %s\",\n+        config.vset_recall_key);\n+    if (reply \u003d\u003d NULL || reply-\u003etype !\u003d REDIS_REPLY_INTEGER) {\n+        fprintf(stderr, \"Error: Cannot get dimension for key %s\\n\",\n+                config.vset_recall_key);\n+        exit(1);\n+    }\n+    unsigned int dim \u003d reply-\u003einteger;\n+    freeReplyObject(reply);\n+\n+    printf(\"\\n# Testing recall for vector set: %s (dimension: %d)\\n\",\n+           config.vset_recall_key, dim);\n+    printf(\"# Mixing %d random element vectors, top %d results, EF\u003d%d\\n\\n\",\n+           ele_count, vsim_count, vsim_ef);\n+\n+    signal(SIGINT, longStatLoopModeStop);\n+\n+    /* Do the same recall test again and again. */\n+    while (force_cancel_loop \u003d\u003d 0) {\n+        /* Get random members. */\n+        reply \u003d reconnectingRedisCommand(context, \"VRANDMEMBER %s %d\",\n+                                        config.vset_recall_key, ele_count);\n+        if (reply \u003d\u003d NULL || reply-\u003etype !\u003d REDIS_REPLY_ARRAY ||\n+            reply-\u003eelements \u003d\u003d 0) {\n+            fprintf(stderr, \"Error fetching random members\\n\");\n+            exit(1);\n+        }\n+\n+        /* Fetch and store vectors. */\n+        double **vectors \u003d zmalloc(reply-\u003eelements * sizeof(double*));\n+        int valid_vectors \u003d 0;\n+\n+        for (size_t i \u003d 0; i \u003c reply-\u003eelements; i++) {\n+            redisReply *vemb \u003d reconnectingRedisCommand(context, \"VEMB %s %s\",\n+                                                       config.vset_recall_key,\n+                                                       reply-\u003eelement[i]-\u003estr);\n+            if (vemb \u0026\u0026 vemb-\u003etype \u003d\u003d REDIS_REPLY_ARRAY \u0026\u0026\n+                vemb-\u003eelements \u003d\u003d dim) {\n+                vectors[valid_vectors] \u003d zmalloc(dim * sizeof(double));\n+                for (unsigned int j \u003d 0; j \u003c dim; j++) {\n+                    vectors[valid_vectors][j] \u003d atof(vemb-\u003eelement[j]-\u003estr);\n+                }\n+                valid_vectors++;\n+            }\n+            if (vemb) freeReplyObject(vemb);\n+        }\n+        freeReplyObject(reply);\n+\n+        if (valid_vectors \u003d\u003d 0) {\n+            fprintf(stderr, \"No valid vectors retrieved\\n\");\n+            zfree(vectors);\n+            continue;\n+        }\n+\n+        /* Create mixed query vector by randomly selecting components. */\n+        float *query \u003d zmalloc(sizeof(float) * dim);\n+        for (unsigned int i \u003d 0; i \u003c dim; i++) {\n+            int src \u003d rand() % valid_vectors;\n+            query[i] \u003d vectors[src][i];\n+        }\n+\n+        for (int i \u003d 0; i \u003c valid_vectors; i++) zfree(vectors[i]);\n+        zfree(vectors);\n+\n+        /* Execute VSIM query with HNSW. */\n+        vsim_reply \u003d reconnectingRedisCommand(context,\n+                                     \"VSIM %s FP32 %b COUNT %d EF %d\",\n+                                     config.vset_recall_key, query,\n+                                     sizeof(float)*dim, vsim_count, vsim_ef);\n+        if (vsim_reply \u003d\u003d NULL || vsim_reply-\u003etype !\u003d REDIS_REPLY_ARRAY) {\n+            zfree(query);\n+            if (vsim_reply) freeReplyObject(vsim_reply);\n+            continue;\n+        }\n+\n+        /* Execute ground truth query (brute force using TRUTH). */\n+        truth_reply \u003d reconnectingRedisCommand(context,\n+                                      \"VSIM %s FP32 %b COUNT %d TRUTH\",\n+                                      config.vset_recall_key, query,\n+                                      sizeof(float)*dim, vsim_count);\n+        zfree(query);\n+\n+        if (truth_reply \u003d\u003d NULL || truth_reply-\u003etype !\u003d REDIS_REPLY_ARRAY) {\n+            freeReplyObject(vsim_reply);\n+            if (truth_reply) freeReplyObject(truth_reply);\n+            continue;\n+        }\n+\n+        /* Build dictionary of ground truth results for fast lookup. */\n+        dictType dtype \u003d {\n+            dictSdsHash, NULL, NULL, dictSdsKeyCompare,\n+            dictSdsDestructor, NULL, NULL\n+        };\n+        dict *truth_set \u003d dictCreate(\u0026dtype);\n+\n+        for (size_t i \u003d 0; i \u003c truth_reply-\u003eelements; i++) {\n+            sds key \u003d sdsnew(truth_reply-\u003eelement[i]-\u003estr);\n+            dictAdd(truth_set, key, NULL);\n+        }\n+\n+        /* Count overlap between HNSW results and ground truth. */\n+        int overlap \u003d 0;\n+        for (size_t i \u003d 0; i \u003c vsim_reply-\u003eelements; i++) {\n+            sds vsim_key \u003d sdsnew(vsim_reply-\u003eelement[i]-\u003estr);\n+            if (dictFind(truth_set, vsim_key) !\u003d NULL) {\n+                overlap++;\n+            }\n+            sdsfree(vsim_key);\n+        }\n+\n+        dictRelease(truth_set);\n+        freeReplyObject(vsim_reply);\n+        freeReplyObject(truth_reply);\n+\n+        /* Calculate recall percentage (overlap / expected * 100). */\n+        double recall \u003d (double)overlap / vsim_count * 100.0;\n+\n+        /* Cap at 100% against rounding errors. */\n+        if (recall \u003e 100.0) recall \u003d 100.0;\n+\n+        queries++;\n+        total_overlap +\u003d overlap;\n+\n+        /* Store in histogram: convert to integer by multiplying by 100,\n+         * then add 1 to shift into valid range [1, 10001] */\n+        int64_t recall_value \u003d (int64_t)(recall * 100.0) + 1;\n+        hdr_record_value(recall_histogram, recall_value);\n+\n+        /* Display progresses. */\n+        if (mstime() \u003e refresh_time + REFRESH_INTERVAL || !IS_TTY_OR_FAKETTY())\n+        {\n+            refresh_time \u003d mstime();\n+            double avg_recall \u003d (double)total_overlap / (queries * vsim_count)\n+                                    * 100.0;\n+\n+            if (IS_TTY_OR_FAKETTY()) printf(\"\\x1b[0G\\x1b[2K\");\n+            printf(\"Queries: %llu | Avg recall: %.2f%%\", queries, avg_recall);\n+            if (!IS_TTY_OR_FAKETTY()) printf(\"\\n\");\n+            fflush(stdout);\n+        }\n+        if (config.interval) usleep(config.interval);\n+    }\n+\n+    /* Final statistics. */\n+    printf(\"\\n\\n\");\n+    printf(\"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\");\n+    printf(\"       Recall Test Results\\n\");\n+    printf(\"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\\n\");\n+    printf(\"Total queries:   %llu\\n\", queries);\n+    printf(\"Average recall:  %.2f%%\\n\",\n+           (double)total_overlap / (queries * vsim_count) * 100.0);\n+\n+    /* Convert histogram statistics back to percentages. */\n+    printf(\"Mean recall:     %.2f%%\\n\", (hdr_mean(recall_histogram)-1)/100.0);\n+    printf(\"Median recall:   %.2f%%\\n\",\n+           (hdr_value_at_percentile(recall_histogram, 50.0)-1)/100.0);\n+    printf(\"StdDev:          %.2f%%\\n\", hdr_stddev(recall_histogram)/100.0);\n+    printf(\"Min recall:      %.2f%%\\n\", (hdr_min(recall_histogram)-1)/100.0);\n+    printf(\"Max recall:      %.2f%%\\n\", (hdr_max(recall_histogram)-1)/100.0);\n+\n+    /* Display recall threshold distribution. */\n+    printf(\"\\n--- Recall Thresholds ---\\n\");\n+    printf(\"At least    %% of queries\\n\");\n+    printf(\"--------    ------------\\n\");\n+\n+    double recall_thresholds[] \u003d {0, 50, 60, 70, 80, 85, 90, 95, 99, 100};\n+    int num_thresholds \u003d sizeof(recall_thresholds) / sizeof(recall_thresholds[0]);\n+    for (int i \u003d 0; i \u003c num_thresholds; i++) {\n+        double target_recall \u003d recall_thresholds[i];\n+        /* Convert target recall to histogram value. */\n+        int64_t target_value \u003d (int64_t)(target_recall * 100.0) + 1;\n+\n+        /* Find what percentile this value is at. */\n+        double percentile \u003d 0.0;\n+        for (double p \u003d 0.0; p \u003c\u003d 100.0; p +\u003d 0.1) {\n+            int64_t value_at_p \u003d hdr_value_at_percentile(recall_histogram, p);\n+            if (value_at_p \u003e\u003d target_value) {\n+                percentile \u003d p;\n+                break;\n+            }\n+        }\n+\n+        /* Percentage achieving AT LEAST this recall is (100 - percentile) */\n+        double pct_achieving \u003d 100.0 - percentile;\n+        printf(\"%6.1f%%     %10.2f%%\\n\", target_recall, pct_achieving);\n+    }\n+\n+    hdr_close(recall_histogram);\n+    exit(0);\n+}\n+\n /*------------------------------------------------------------------------------\n  * Slave mode\n  *--------------------------------------------------------------------------- */\n@@ -9252,11 +9506,6 @@ static void getKeySizes(redisReply *keys, typeinfo **types,\n     }\n }\n \n-static void longStatLoopModeStop(int s) {\n-    UNUSED(s);\n-    force_cancel_loop \u003d 1;\n-}\n-\n /* In cluster mode we may need to send the READONLY command.\n    Ignore the error in case the server isn\u0027t using cluster mode. */\n static void sendReadOnly(void) {\n@@ -10656,6 +10905,11 @@ int main(int argc, char **argv) {\n     config.monitor_mode \u003d 0;\n     config.pubsub_mode \u003d 0;\n     config.blocking_state_aborted \u003d 0;\n+    config.vset_recall_mode \u003d 0;\n+    config.vset_recall_key \u003d NULL;\n+    config.vset_recall_ele_count \u003d 1;\n+    config.vset_recall_vsim_count \u003d 100;\n+    config.vset_recall_vsim_ef \u003d 500;\n     config.latency_mode \u003d 0;\n     config.latency_dist_mode \u003d 0;\n     config.latency_history \u003d 0;\n@@ -10779,6 +11033,12 @@ int main(int argc, char **argv) {\n         latencyDistMode();\n     }\n \n+    /* Latency mode */\n+    if (config.vset_recall_mode) {\n+        if (cliConnect(0) \u003d\u003d REDIS_ERR) exit(1);\n+        vsetRecallMode();\n+    }\n+\n     /* Slave mode */\n     if (config.slave_mode) {\n         if (cliConnect(0) \u003d\u003d REDIS_ERR) exit(1);","expectedMessage":"[Vector sets]: redis-cli recall testing abilities (#14408)","repository":"redis-antirez","commitHash":"391530cd15513eb8337e238608daa380e159b86d","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-154fdcee","diff":" tests/unit/maxmemory.tcl     | 15 ++++++++++-\n tests/unit/memefficiency.tcl | 59 ++++++++++++++++++++++++++++++++++++--------\n 2 files changed, 63 insertions(+), 11 deletions(-)\n\ndiff --git a/tests/unit/maxmemory.tcl b/tests/unit/maxmemory.tcl\nindex 4097092..4d4fd7c 100644\n--- a/tests/unit/maxmemory.tcl\n+++ b/tests/unit/maxmemory.tcl\n@@ -349,10 +349,23 @@ proc test_slave_buffers {test_name cmd_count payload_len limit_memory pipeline}\n             # send some 10mb worth of commands that don\u0027t increase the memory usage\n             if {$pipeline \u003d\u003d 1} {\n                 set rd_master [redis_deferring_client -1]\n+                # Send commands in batches and read responses to avoid TCP deadlock.\n+                # Without interleaving reads, the client\u0027s send buffer fills up when\n+                # the server\u0027s output buffers are full (because we\u0027re not reading),\n+                # causing flush to block indefinitely on slow machines.\n+                set batch_size 10000\n                 for {set k 0} {$k \u003c $cmd_count} {incr k} {\n                     $rd_master setrange key:0 0 [string repeat A $payload_len]\n+                    if {($k + 1) % $batch_size \u003d\u003d 0} {\n+                        # Drain responses to prevent TCP buffer deadlock\n+                        for {set j 0} {$j \u003c $batch_size} {incr j} {\n+                            $rd_master read\n+                        }\n+                    }\n                 }\n-                for {set k 0} {$k \u003c $cmd_count} {incr k} {\n+                # Read any remaining responses\n+                set remaining [expr {$cmd_count % $batch_size}]\n+                for {set k 0} {$k \u003c $remaining} {incr k} {\n                     $rd_master read\n                 }\n             } else {\ndiff --git a/tests/unit/memefficiency.tcl b/tests/unit/memefficiency.tcl\nindex ddd72a6..fa6fd7c 100644\n--- a/tests/unit/memefficiency.tcl\n+++ b/tests/unit/memefficiency.tcl\n@@ -234,12 +234,24 @@ run_solo {defrag} {\n             # Populate memory with interleaving script-key pattern of same size\n             set dummy_script \"--[string repeat x 400]\\nreturn \"\n             set rd [redis_deferring_client]\n+            # Send commands in batches and read responses to avoid TCP deadlock.\n+            # Without interleaving reads, TCP congestion control can throttle\n+            # the connection when buffers fill, causing the test to hang.\n+            set batch_size 1000\n             for {set j 0} {$j \u003c $n} {incr j} {\n                 set val \"$dummy_script[format \"%06d\" $j]\"\n                 $rd script load $val\n                 $rd set k$j $val\n+                if {($j + 1) % $batch_size \u003d\u003d 0} {\n+                    for {set i 0} {$i \u003c $batch_size} {incr i} {\n+                        $rd read ; # Discard script load replies\n+                        $rd read ; # Discard set replies\n+                    }\n+                }\n             }\n-            for {set j 0} {$j \u003c $n} {incr j} {\n+            # Read remaining responses\n+            set remaining [expr {$n % $batch_size}]\n+            for {set j 0} {$j \u003c $remaining} {incr j} {\n                 $rd read ; # Discard script load replies\n                 $rd read ; # Discard set replies\n             }\n@@ -253,8 +265,17 @@ run_solo {defrag} {\n             assert_lessthan [s allocator_frag_ratio] 1.05\n \n             # Delete all the keys to create fragmentation\n-            for {set j 0} {$j \u003c $n} {incr j} { $rd del k$j }\n-            for {set j 0} {$j \u003c $n} {incr j} { $rd read } ; # Discard del replies\n+            # Use same batching pattern to avoid TCP deadlock\n+            for {set j 0} {$j \u003c $n} {incr j} {\n+                $rd del k$j\n+                if {($j + 1) % $batch_size \u003d\u003d 0} {\n+                    for {set i 0} {$i \u003c $batch_size} {incr i} {\n+                        $rd read\n+                    }\n+                }\n+            }\n+            set remaining [expr {$n % $batch_size}]\n+            for {set j 0} {$j \u003c $remaining} {incr j} { $rd read }\n             if {$type eq \"cluster\"} {\n                 $rd config resetstat\n                 $rd read ; # Discard config resetstat reply\n@@ -327,16 +348,25 @@ run_solo {defrag} {\n             r xreadgroup GROUP mygroup Alice COUNT 1 STREAMS stream \u003e\n \n             # create big keys with 10k items\n+            # Use batching to avoid TCP deadlock\n             set rd [redis_deferring_client]\n+            set batch_size 1000\n             for {set j 0} {$j \u003c 10000} {incr j} {\n                 $rd hset bighash $j [concat \"asdfasdfasdf\" $j]\n                 $rd lpush biglist [concat \"asdfasdfasdf\" $j]\n                 $rd zadd bigzset $j [concat \"asdfasdfasdf\" $j]\n                 $rd sadd bigset [concat \"asdfasdfasdf\" $j]\n                 $rd xadd bigstream * item 1 value a\n+                if {($j + 1) % $batch_size \u003d\u003d 0} {\n+                    for {set i 0} {$i \u003c [expr {$batch_size * 5}]} {incr i} {\n+                        $rd read\n+                    }\n+                }\n             }\n-            for {set j 0} {$j \u003c 50000} {incr j} {\n-                $rd read ; # Discard replies\n+            # Read remaining replies\n+            set remaining [expr {(10000 % $batch_size) * 5}]\n+            for {set j 0} {$j \u003c $remaining} {incr j} {\n+                $rd read\n             }\n \n             # create some small items (effective in cluster-enabled)\n@@ -480,8 +510,18 @@ run_solo {defrag} {\n             assert_lessthan [s allocator_frag_ratio] 1.05\n \n             # Delete all the keys to create fragmentation\n-            for {set j 0} {$j \u003c $n} {incr j} { $rd del k$j }\n-            for {set j 0} {$j \u003c $n} {incr j} { $rd read } ; # Discard del replies\n+            # Use batching to avoid TCP deadlock\n+            set batch_size 1000\n+            for {set j 0} {$j \u003c $n} {incr j} {\n+                $rd del k$j\n+                if {($j + 1) % $batch_size \u003d\u003d 0} {\n+                    for {set i 0} {$i \u003c $batch_size} {incr i} {\n+                        $rd read\n+                    }\n+                }\n+            }\n+            set remaining [expr {$n % $batch_size}]\n+            for {set j 0} {$j \u003c $remaining} {incr j} { $rd read }\n             if {$type eq \"cluster\"} {\n                 $rd config resetstat\n                 $rd read ; # Discard config resetstat reply\n@@ -555,6 +595,7 @@ run_solo {defrag} {\n             r config set hash-max-listpack-entries 10\n \n             # Populate memory with interleaving hash field of same size\n+            # Interleave reads to avoid TCP deadlock\n             set dummy_field \"[string repeat x 400]\"\n             set rd [redis_deferring_client]\n             for {set i 0} {$i \u003c $n} {incr i} {\n@@ -565,9 +606,7 @@ run_solo {defrag} {\n                     $rd hexpire k$i 9999999 FIELDS 1 $dummy_field$j\n                 }\n                 $rd expire h$i 9999999 ;# Ensure expire is updated after kvobj reallocation\n-            }\n-            \n-            for {set i 0} {$i \u003c $n} {incr i} {\n+                # Read replies for this iteration to avoid TCP deadlock\n                 for {set j 0} {$j \u003c $fields} {incr j} {\n                     $rd read ; # Discard hset replies\n                     $rd read ; # Discard hexpire replies","expectedMessage":"Test tcp deadlock fixes (#14667)","repository":"redis-antirez","commitHash":"154fdcee013ce87a89ce6bfa9b6b99a8d22a0aa5","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-3de2fdad","diff":" modules/vector-sets/README.md       |  72 +++++++++++\n modules/vector-sets/commands.json   |  30 +++++\n modules/vector-sets/tests/vrange.py | 113 +++++++++++++++++\n modules/vector-sets/vset.c          | 235 +++++++++++++++++++++++++++++++++---\n 4 files changed, 434 insertions(+), 16 deletions(-)\n\ndiff --git a/modules/vector-sets/README.md b/modules/vector-sets/README.md\nindex 726f3af..6bacfe0 100644\n--- a/modules/vector-sets/README.md\n+++ b/modules/vector-sets/README.md\n@@ -189,6 +189,78 @@ This command will return 1 (or true) if the specified element is already in the\n \n As with other existence check Redis commands, if the key does not exist it is considered as if it was empty, thus the element is reported as non existing.\n \n+**VRANGE: return elements in a lexicographical range\n+\n+    VRANGE key start end count\n+\n+The `VRANGE` command has many different use cases, but its main goal is to\n+provide a stateless iterator for the elements inside a vector set: that is,\n+it allows to retrieve all the elements inside a vector set in small amounts\n+for each call, without an explicit cursor, and with guarantees about what\n+the user will miss in case the vector set is changing (elements added and/or\n+removed) during the iteration.\n+\n+The command usage is straightforward:\n+\n+```\n+\u003e VRANGE word_embeddings_int8 [Redis + 10\n+ 1) \"Redis\"\n+ 2) \"Rediscover\"\n+ 3) \"Rediscover_Ashland\"\n+ 4) \"Rediscover_Northern_Ireland\"\n+ 5) \"Rediscovered\"\n+ 6) \"Rediscovered_Bookshop\"\n+ 7) \"Rediscovering\"\n+ 8) \"Rediscovering_God\"\n+ 9) \"Rediscovering_Lost\"\n+10) \"Rediscovers\"\n+```\n+\n+The above command returns 10 (or less, if less are available in the specified range) elements from \"Redis\" (inclusive) to the maximum possible element. The comparison is performed byte by byte, as `memcmp()` would do, in this way the elements have a total order. The start and end range can be either a string, prefixed by `[` or `(` (the prefix is mandatory) to tell the command if the range is inclusive or exclusive, or can be the special symbols `-` and `+` that means the maximum and minimum element.\n+\n+So for instance if I want to iterate all the elements, ten elements for each call, I\u0027ll proceed as such:\n+\n+```\n+\u003e VRANGE mykey - + 10\n+ 1) \"a\"\n+ 2) \"a-league\"\n+ 3) \"a.\"\n+ 4) \"a.d.\"\n+ 5) \"a.k.a.\"\n+ 6) \"a.m.\"\n+ 7) \"a1\"\n+ 8) \"a2\"\n+ 9) \"a3\"\n+10) \"a7\"\n+```\n+\n+This will give me the first 10 elements. Then I want the next ten elements\n+starting from the last element in the previous result, but *excluding* it,\n+so the next range will use the `(` prefix with the last element of the\n+previous call, that was `\"a7\"`:\n+\n+```\n+\u003e VRANGE mykey (a7 + 10\n+ 1) \"a930913\"\n+ 2) \"aa\"\n+ 3) \"aaa\"\n+ 4) \"aaron\"\n+ 5) \"ab\"\n+ 6) \"aba\"\n+ 7) \"abandon\"\n+ 8) \"abandoned\"\n+ 9) \"abandoning\"\n+10) \"abandonment\"\n+```\n+\n+And so forth.\n+\n+The command count is mandatory, however a negative count means to return all the elements in the set. This means that `VRANGE mykey - + -1` will return every element. Of course, iterating like that means that it is possible to block the server for a long time.\n+\n+The command time complexity is O(1) to seek to the element (considering the element would be of reasonable size), since we use a Radix Tree in the underlying implementation, plus the time to yield \"M\" elements. So if M is small, each call is just executed in constant time. However the iteration of a total set (via multiple calls) of N elements is O(N). Basically: this command, with a small count, will never produce latency issues in the Redis server.\n+\n+In case the elements are changing continuously as the set is iterated, the guarantees are very simple: each range will produce exactly the elements that were present in the range in the moment the `VRANGE` command was executed. In other words, an iteration performed in this way is *guaranteed* to return all the elements that stayed within the vector set from the start to the end of the iteration. Elements removed or added in the meantime may be returned or not depending on the moment they were added or removed.\n+\n **VLINKS: introspection command that shows neighbors for a node**\n \n     VLINKS key element [WITHSCORES]\ndiff --git a/modules/vector-sets/commands.json b/modules/vector-sets/commands.json\nindex 4bc6190..5f42f87 100644\n--- a/modules/vector-sets/commands.json\n+++ b/modules/vector-sets/commands.json\n@@ -412,5 +412,35 @@\n         \"type\": \"string\"\n       }\n     ]\n+  },\n+  \"VRANGE\": {\n+    \"summary\": \"Return elements in a lexicographical range\",\n+    \"complexity\": \"O(log(K)+M) where K is the number of elements in the start prefix, and M is the number of elements returned. In practical terms, the command is just O(M)\",\n+    \"group\": \"vector_set\",\n+    \"since\": \"8.4.0\",\n+    \"arity\": -4,\n+    \"function\": \"vrangeCommand\",\n+    \"command_flags\": [\n+      \"READONLY\"\n+    ],\n+    \"arguments\": [\n+      {\n+        \"name\": \"key\",\n+        \"type\": \"key\"\n+      },\n+      {\n+        \"name\": \"start\",\n+        \"type\": \"string\"\n+      },\n+      {\n+        \"name\": \"end\",\n+        \"type\": \"string\"\n+      },\n+      {\n+        \"name\": \"count\",\n+        \"type\": \"integer\",\n+        \"optional\": true\n+      }\n+    ]\n   }\n }\ndiff --git a/modules/vector-sets/tests/vrange.py b/modules/vector-sets/tests/vrange.py\nnew file mode 100644\nindex 0000000..7e57588\n--- /dev/null\n+++ b/modules/vector-sets/tests/vrange.py\n@@ -0,0 +1,113 @@\n+from test import TestCase, generate_random_vector\n+import struct\n+\n+class BasicVRANGE(TestCase):\n+    def getname(self):\n+        return \"VRANGE basic functionality and iteration\"\n+\n+    def test(self):\n+        # Add multiple elements with different names for lexicographical ordering\n+        elements \u003d [\n+            \"apple\", \"apricot\", \"banana\", \"cherry\", \"date\",\n+            \"elderberry\", \"fig\", \"grape\", \"honeydew\", \"kiwi\",\n+            \"lemon\", \"mango\", \"nectarine\", \"orange\", \"papaya\",\n+            \"quince\", \"raspberry\", \"strawberry\", \"tangerine\", \"watermelon\"\n+        ]\n+\n+        # Add all elements to the vector set\n+        for elem in elements:\n+            vec \u003d generate_random_vector(4)\n+            vec_bytes \u003d struct.pack(\u00274f\u0027, *vec)\n+            self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027FP32\u0027, vec_bytes, elem)\n+\n+        # Test 1: Basic range with inclusive boundaries\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027[apple\u0027, \u0027[grape\u0027, \u00275\u0027)\n+        result \u003d [r.decode() for r in result]\n+        assert result \u003d\u003d [\u0027apple\u0027, \u0027apricot\u0027, \u0027banana\u0027, \u0027cherry\u0027, \u0027date\u0027], f\"Expected first 5 elements from apple, got {result}\"\n+\n+        # Test 2: Exclusive start boundary\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027(apple\u0027, \u0027[cherry\u0027, \u002710\u0027)\n+        result \u003d [r.decode() for r in result]\n+        assert result \u003d\u003d [\u0027apricot\u0027, \u0027banana\u0027, \u0027cherry\u0027], f\"Expected elements after apple up to cherry inclusive, got {result}\"\n+\n+        # Test 3: Exclusive end boundary\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027[banana\u0027, \u0027(cherry\u0027, \u002710\u0027)\n+        result \u003d [r.decode() for r in result]\n+        assert result \u003d\u003d [\u0027banana\u0027], f\"Expected only banana (cherry excluded), got {result}\"\n+\n+        # Test 4: Using \u0027-\u0027 for minimum element\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027-\u0027, \u0027[banana\u0027, \u002710\u0027)\n+        result \u003d [r.decode() for r in result]\n+        assert result[0] \u003d\u003d \u0027apple\u0027, \"Should start from the first element\"\n+        assert result[-1] \u003d\u003d \u0027banana\u0027, \"Should end at banana\"\n+\n+        # Test 5: Using \u0027+\u0027 for maximum element\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027[raspberry\u0027, \u0027+\u0027, \u002710\u0027)\n+        result \u003d [r.decode() for r in result]\n+        assert \u0027raspberry\u0027 in result and \u0027strawberry\u0027 in result and \u0027tangerine\u0027 in result and \u0027watermelon\u0027 in result, \"Should include all elements from raspberry onwards\"\n+\n+        # Test 6: Full range with \u0027-\u0027 and \u0027+\u0027\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027-\u0027, \u0027+\u0027, \u0027100\u0027)\n+        result \u003d [r.decode() for r in result]\n+        assert len(result) \u003d\u003d len(elements), f\"Should return all {len(elements)} elements\"\n+        assert result \u003d\u003d sorted(elements), \"Elements should be in lexicographical order\"\n+\n+        # Test 7: Iterator pattern - verify each element appears exactly once\n+        seen \u003d set()\n+        batch_size \u003d 3\n+        current \u003d \u0027-\u0027\n+\n+        while True:\n+            if current \u003d\u003d \u0027-\u0027:\n+                # First iteration\n+                result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027-\u0027, \u0027+\u0027, str(batch_size))\n+            else:\n+                # Subsequent iterations - exclusive start from last element\n+                result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, f\u0027({current}\u0027, \u0027+\u0027, str(batch_size))\n+\n+            result \u003d [r.decode() for r in result]\n+\n+            if not result:\n+                break\n+\n+            # Check no duplicates in this batch\n+            for elem in result:\n+                assert elem not in seen, f\"Element {elem} appeared more than once\"\n+                seen.add(elem)\n+\n+            # Update current to last element\n+            current \u003d result[-1]\n+\n+            # Break if we got less than requested (end of set)\n+            if len(result) \u003c batch_size:\n+                break\n+\n+        # Verify we saw all elements exactly once\n+        assert seen \u003d\u003d set(elements), f\"Iterator should visit all elements exactly once. Missing: {set(elements) - seen}, Extra: {seen - set(elements)}\"\n+\n+        # Test 8: Count of 0 returns empty array\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027-\u0027, \u0027+\u0027, \u00270\u0027)\n+        assert result \u003d\u003d [], f\"Count of 0 should return empty array, got {result}\"\n+\n+        # Test 9: Range with no matching elements\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027[zebra\u0027, \u0027+\u0027, \u002710\u0027)\n+        assert result \u003d\u003d [], f\"Range beyond all elements should return empty array, got {result}\"\n+\n+        # Test 10: Non-existent key\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, \u0027nonexistent_key\u0027, \u0027-\u0027, \u0027+\u0027, \u002710\u0027)\n+        assert result \u003d\u003d [], f\"Non-existent key should return empty array, got {result}\"\n+\n+        # Test 11: Partial word boundaries\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027[app\u0027, \u0027[apr\u0027, \u002710\u0027)\n+        result \u003d [r.decode() for r in result]\n+        assert \u0027apple\u0027 in result, \"Should include \u0027apple\u0027 which starts with \u0027app\u0027\"\n+        assert \u0027apricot\u0027 not in result, \"Should not include \u0027apricot\u0027 as it\u0027s \u003e\u003d \u0027apr\u0027\"\n+\n+        # Test 12: Single element range\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027[cherry\u0027, \u0027[cherry\u0027, \u002710\u0027)\n+        result \u003d [r.decode() for r in result]\n+        assert result \u003d\u003d [\u0027cherry\u0027], f\"Inclusive single element range should return that element, got {result}\"\n+\n+        # Test 13: Empty range (start \u003e end)\n+        result \u003d self.redis.execute_command(\u0027VRANGE\u0027, self.test_key, \u0027[grape\u0027, \u0027[apple\u0027, \u002710\u0027)\n+        assert result \u003d\u003d [], f\"Range where start \u003e end should return empty array, got {result}\"\ndiff --git a/modules/vector-sets/vset.c b/modules/vector-sets/vset.c\nindex ecbccc7..500f8e9 100644\n--- a/modules/vector-sets/vset.c\n+++ b/modules/vector-sets/vset.c\n@@ -1718,6 +1718,183 @@ int VISMEMBER_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int ar\n     return RedisModule_ReplyWithBool(ctx, node !\u003d NULL);\n }\n \n+/* Structure to represent a range boundary. */\n+struct vsetRangeOp {\n+    int incl;   /* 1 if inclusive ([), 0 if exclusive ((). */\n+    int min;    /* 1 if this is \"-\" (minimum). */\n+    int max;    /* 1 if this is \"+\" (maximum). */\n+    unsigned char *ele;  /* The actual element, NULL if min/max. */\n+    size_t ele_len;      /* Length of the element. */\n+};\n+\n+/* Parse a range specification like \"[foo\" or \"(bar\" or \"-\" or \"+\".\n+ * Returns 1 on success, 0 on error. */\n+int vsetParseRangeOp(RedisModuleString *arg, struct vsetRangeOp *op) {\n+    size_t len;\n+    const char *str \u003d RedisModule_StringPtrLen(arg, \u0026len);\n+\n+    if (len \u003d\u003d 0) return 0;\n+\n+    /* Initialize the structure. */\n+    op-\u003eincl \u003d 0;\n+    op-\u003emin \u003d 0;\n+    op-\u003emax \u003d 0;\n+    op-\u003eele \u003d NULL;\n+    op-\u003eele_len \u003d 0;\n+\n+    /* Check for special cases \"-\" and \"+\". */\n+    if (len \u003d\u003d 1 \u0026\u0026 str[0] \u003d\u003d \u0027-\u0027) {\n+        op-\u003emin \u003d 1;\n+        return 1;\n+    }\n+    if (len \u003d\u003d 1 \u0026\u0026 str[0] \u003d\u003d \u0027+\u0027) {\n+        op-\u003emax \u003d 1;\n+        return 1;\n+    }\n+\n+    /* Otherwise, must start with ( or [. */\n+    if (str[0] \u003d\u003d \u0027[\u0027) {\n+        op-\u003eincl \u003d 1;\n+    } else if (str[0] \u003d\u003d \u0027(\u0027) {\n+        op-\u003eincl \u003d 0;\n+    } else {\n+        return 0;  /* Invalid format. */\n+    }\n+\n+    /* Extract the string part after the bracket. */\n+    if (len \u003e 1) {\n+        op-\u003eele \u003d (unsigned char *)(str + 1);\n+        op-\u003eele_len \u003d len - 1;\n+    } else {\n+        return 0;  /* Just a bracket with no string. */\n+    }\n+\n+    return 1;\n+}\n+\n+/* Check if the current element is within the range defined by the end operator.\n+ * Returns 1 if the element is within range, 0 if it has passed the end. */\n+int vsetIsElementInRange(const void *ele, size_t ele_len, struct vsetRangeOp *end_op) {\n+    /* If end is \"+\", element is always in range. */\n+    if (end_op-\u003emax) return 1;\n+\n+    /* Compare current element with end boundary. */\n+    size_t minlen \u003d ele_len \u003c end_op-\u003eele_len ? ele_len : end_op-\u003eele_len;\n+    int cmp \u003d memcmp(ele, end_op-\u003eele, minlen);\n+\n+    if (cmp \u003d\u003d 0) {\n+        /* If equal up to minlen, shorter string is smaller. */\n+        if (ele_len \u003c end_op-\u003eele_len) {\n+            cmp \u003d -1;\n+        } else if (ele_len \u003e end_op-\u003eele_len) {\n+            cmp \u003d 1;\n+        }\n+    }\n+\n+    /* Check based on inclusive/exclusive. */\n+    if (end_op-\u003eincl) {\n+        return cmp \u003c\u003d 0;  /* Inclusive: element \u003c\u003d end. */\n+    } else {\n+        return cmp \u003c 0;   /* Exclusive: element \u003c end. */\n+    }\n+}\n+\n+/* VRANGE key start end [count]\n+ * Returns elements in the lexicographical range [start, end]\n+ *\n+ * Elements must be specified in one of the following forms:\n+ *\n+ *  [myelement\n+ *  (myelement\n+ *  +\n+ *  -\n+ *\n+ * Elements starting with [ are inclusive, so \"myelement\" would be\n+ * returned if present in the set. Elements starting with ( are exclusive\n+ * ranges instead. The special - and + elements mean the minimum and maximum\n+ * possible element (inclusive), so \"VRANGE key - +\" will return everything\n+ * (depending on COUNT of course). The special - element can be used only\n+ * as starting element, the special + element only as ending element. */\n+int VRANGE_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n+    RedisModule_AutoMemory(ctx);\n+\n+    /* Check arguments. */\n+    if (argc \u003c 4 || argc \u003e 5) return RedisModule_WrongArity(ctx);\n+\n+    /* Parse COUNT if provided. */\n+    long long count \u003d -1;  /* Default: return all elements. */\n+    if (argc \u003d\u003d 5) {\n+        if (RedisModule_StringToLongLong(argv[4], \u0026count) !\u003d REDISMODULE_OK) {\n+            return RedisModule_ReplyWithError(ctx, \"ERR invalid COUNT value\");\n+        }\n+    }\n+\n+    /* Parse range operators. */\n+    struct vsetRangeOp start_op, end_op;\n+    if (!vsetParseRangeOp(argv[2], \u0026start_op)) {\n+        return RedisModule_ReplyWithError(ctx, \"ERR invalid start range format\");\n+    }\n+    if (!vsetParseRangeOp(argv[3], \u0026end_op)) {\n+        return RedisModule_ReplyWithError(ctx, \"ERR invalid end range format\");\n+    }\n+\n+    /* Validate: \"-\" can only be first arg, \"+\" can only be second. */\n+    if (start_op.max || end_op.min) {\n+        return RedisModule_ReplyWithError(ctx,\n+            \"ERR \u0027-\u0027 can only be used as first argument, \u0027+\u0027 only as second\");\n+    }\n+\n+    /* Open the key. */\n+    RedisModuleKey *key \u003d RedisModule_OpenKey(ctx, argv[1], REDISMODULE_READ);\n+    int type \u003d RedisModule_KeyType(key);\n+\n+    if (type \u003d\u003d REDISMODULE_KEYTYPE_EMPTY) {\n+        return RedisModule_ReplyWithEmptyArray(ctx);\n+    }\n+\n+    if (RedisModule_ModuleTypeGetType(key) !\u003d VectorSetType) {\n+        return RedisModule_ReplyWithError(ctx, REDISMODULE_ERRORMSG_WRONGTYPE);\n+    }\n+\n+    struct vsetObject *vset \u003d RedisModule_ModuleTypeGetValue(key);\n+\n+    /* Start the iterator. */\n+    RedisModuleDictIter *iter;\n+    if (start_op.min) {\n+        /* Start from the beginning. */\n+        iter \u003d RedisModule_DictIteratorStartC(vset-\u003edict, \"^\", NULL, 0);\n+    } else {\n+        /* Start from the specified element. */\n+        const char *op \u003d start_op.incl ? \"\u003e\u003d\" : \"\u003e\";\n+        iter \u003d RedisModule_DictIteratorStartC(vset-\u003edict, op, start_op.ele, start_op.ele_len);\n+    }\n+\n+    /* Collect results. */\n+    RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_LEN);\n+    long long returned \u003d 0;\n+\n+    void *key_data;\n+    size_t key_len;\n+    while ((key_data \u003d RedisModule_DictNextC(iter, \u0026key_len, NULL)) !\u003d NULL) {\n+        /* Check if we\u0027ve collected enough elements. */\n+        if (count \u003e\u003d 0 \u0026\u0026 returned \u003e\u003d count) break;\n+\n+        /* Check if we\u0027ve passed the end range. */\n+        if (!vsetIsElementInRange(key_data, key_len, \u0026end_op)) break;\n+\n+        /* Add this element to the result. */\n+        RedisModule_ReplyWithStringBuffer(ctx, key_data, key_len);\n+        returned++;\n+    }\n+\n+    RedisModule_ReplySetArrayLength(ctx, returned);\n+\n+    /* Cleanup. */\n+    RedisModule_DictIteratorStop(iter);\n+\n+    return REDISMODULE_OK;\n+}\n+\n /* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d vset type methods \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n \n #define SAVE_FLAG_HAS_PROJMATRIX    (1\u003c\u003c0)\n@@ -2082,13 +2259,13 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n         { .name \u003d \"reduce\", .type \u003d REDISMODULE_ARG_TYPE_BLOCK, .token \u003d \"REDUCE\", .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL,\n             .subargs \u003d (RedisModuleCommandArg[]) {\n                 { .name \u003d \"dim\", .type \u003d REDISMODULE_ARG_TYPE_INTEGER },\n-                { NULL }\n+                { .name \u003d NULL }\n             }\n         },\n         { .name \u003d \"format\", .type \u003d REDISMODULE_ARG_TYPE_ONEOF, .subargs \u003d (RedisModuleCommandArg[]) {\n                 { .name \u003d \"fp32\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"FP32\" },\n                 { .name \u003d \"values\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"VALUES\" },\n-                { NULL }\n+                { .name \u003d NULL }\n             }\n         },\n         { .name \u003d \"vector\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n@@ -2098,13 +2275,13 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n                 { .name \u003d \"noquant\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"NOQUANT\" },\n                 { .name \u003d \"bin\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"BIN\" },\n                 { .name \u003d \"q8\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"Q8\" },\n-                { NULL }\n+                { .name \u003d NULL }\n             }\n         },\n         { .name \u003d \"build-exploration-factor\", .type \u003d REDISMODULE_ARG_TYPE_INTEGER, .token \u003d \"EF\", .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL },\n         { .name \u003d \"attributes\", .type \u003d REDISMODULE_ARG_TYPE_STRING, .token \u003d \"SETATTR\", .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL },\n         { .name \u003d \"numlinks\", .type \u003d REDISMODULE_ARG_TYPE_INTEGER, .token \u003d \"M\", .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vadd_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2126,7 +2303,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n     RedisModuleCommandArg vrem_args[] \u003d {\n         { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n         { .name \u003d \"element\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vrem_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2151,7 +2328,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n                 { .name \u003d \"ele\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"ELE\" },\n                 { .name \u003d \"fp32\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"FP32\" },\n                 { .name \u003d \"values\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"VALUES\" },\n-                { NULL }\n+                { .name \u003d NULL }\n             }\n         },\n         { .name \u003d \"vector_or_element\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n@@ -2164,7 +2341,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n         { .name \u003d \"max-filtering-effort\", .type \u003d REDISMODULE_ARG_TYPE_INTEGER, .token \u003d \"FILTER-EF\", .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL },\n         { .name \u003d \"truth\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"TRUTH\", .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL },\n         { .name \u003d \"nothread\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"NOTHREAD\", .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vsim_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2185,7 +2362,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n \n     RedisModuleCommandArg vdim_args[] \u003d {\n         { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vdim_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2206,7 +2383,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n \n     RedisModuleCommandArg vcard_args[] \u003d {\n         { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vcard_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2229,7 +2406,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n         { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n         { .name \u003d \"element\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n         { .name \u003d \"raw\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"RAW\", .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vemb_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2252,7 +2429,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n         { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n         { .name \u003d \"element\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n         { .name \u003d \"withscores\", .type \u003d REDISMODULE_ARG_TYPE_PURE_TOKEN, .token \u003d \"WITHSCORES\", .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vlinks_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2273,7 +2450,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n \n     RedisModuleCommandArg vinfo_args[] \u003d {\n         { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vinfo_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2296,7 +2473,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n         { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n         { .name \u003d \"element\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n         { .name \u003d \"json\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vsetattr_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2318,7 +2495,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n     RedisModuleCommandArg vgetattr_args[] \u003d {\n         { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n         { .name \u003d \"element\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vgetattr_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2340,7 +2517,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n     RedisModuleCommandArg vrandmember_args[] \u003d {\n         { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n         { .name \u003d \"count\", .type \u003d REDISMODULE_ARG_TYPE_INTEGER, .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vrandmember_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2362,7 +2539,7 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n     RedisModuleCommandArg vismember_args[] \u003d {\n         { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n         { .name \u003d \"element\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n-        { NULL }\n+        { .name \u003d NULL }\n     };\n     RedisModuleCommandInfo vismember_info \u003d {\n         .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n@@ -2373,6 +2550,32 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n     };\n     if (RedisModule_SetCommandInfo(vismember_cmd, \u0026vismember_info) \u003d\u003d REDISMODULE_ERR) return REDISMODULE_ERR;\n \n+    // Register command VRANGE\n+    if (RedisModule_CreateCommand(ctx, \"VRANGE\",\n+\tVRANGE_RedisCommand, \"readonly\", 1, 1, 1) \u003d\u003d REDISMODULE_ERR)\n+\treturn REDISMODULE_ERR;\n+\n+    RedisModuleCommand *vrange_cmd \u003d RedisModule_GetCommand(ctx, \"VRANGE\");\n+    if (vrange_cmd \u003d\u003d NULL) return REDISMODULE_ERR;\n+\n+    RedisModuleCommandArg vrange_args[] \u003d {\n+        { .name \u003d \"key\", .type \u003d REDISMODULE_ARG_TYPE_KEY, .key_spec_index \u003d 0 },\n+        { .name \u003d \"start\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n+        { .name \u003d \"end\", .type \u003d REDISMODULE_ARG_TYPE_STRING },\n+        { .name \u003d \"count\", .type \u003d REDISMODULE_ARG_TYPE_INTEGER, .flags \u003d REDISMODULE_CMD_ARG_OPTIONAL },\n+        { .name \u003d NULL }\n+    };\n+    RedisModuleCommandInfo vrange_info \u003d {\n+        .version \u003d REDISMODULE_COMMAND_INFO_VERSION,\n+        .summary \u003d \"Return vector set elements in a lex range\",\n+        .since \u003d \"8.4.0\",\n+        .arity \u003d -4,\n+        .args \u003d vrange_args,\n+    };\n+    if (RedisModule_SetCommandInfo(vrange_cmd, \u0026vrange_info) \u003d\u003d REDISMODULE_ERR) return REDISMODULE_ERR;\n+\n+    // Set the allocator for the HNSW library, so that memory tracking\n+    // is correct in Redis.\n     hnsw_set_allocator(RedisModule_Free, RedisModule_Alloc,\n                        RedisModule_Realloc);\n ","expectedMessage":"[vector sets] VRANGE implementation (#14235)","repository":"redis-antirez","commitHash":"3de2fdad58cf332fa4050b3b72c25eacd22b2b5c","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-674b8299","diff":" modules/vector-sets/README.md        |  4 +-\n modules/vector-sets/tests/epsilon.py | 77 ++++++++++++++++++++++++++++++++++++\n modules/vector-sets/vset.c           |  2 +-\n 3 files changed, 81 insertions(+), 2 deletions(-)\n\ndiff --git a/modules/vector-sets/README.md b/modules/vector-sets/README.md\nindex cbc95a1..726f3af 100644\n--- a/modules/vector-sets/README.md\n+++ b/modules/vector-sets/README.md\n@@ -66,7 +66,7 @@ performed in the background, while the command is executed in the main thread.\n \n **VSIM: return elements by vector similarity**\n \n-    VSIM key [ELE|FP32|VALUES] \u003cvector or element\u003e [WITHSCORES] [WITHATTRIBS] [COUNT num] [EF search-exploration-factor] [FILTER expression] [FILTER-EF max-filtering-effort] [TRUTH] [NOTHREAD]\n+    VSIM key [ELE|FP32|VALUES] \u003cvector or element\u003e [WITHSCORES] [WITHATTRIBS] [COUNT num] [EPSILON delta] [EF search-exploration-factor] [FILTER expression] [FILTER-EF max-filtering-effort] [TRUTH] [NOTHREAD]\n \n The command returns similar vectors, for simplicity (and verbosity) in the following example, instead of providing a vector using FP32 or VALUES (like in `VADD`), we will ask for elements having a vector similar to a given element already in the sorted set:\n \n@@ -92,6 +92,8 @@ It is possible to specify a `COUNT` and also to get the similarity score (from 1\n     5) \"pear\"\n     6) \"0.8226882219314575\"\n \n+It is also possible to specify a `EPSILON`, that is a floating point number between 0 and 1 in order to only return elements that have a distance that is no further than the specified one. In vector sets, the returned elements have a similarity score (when compared to the query vector) that is between 1 and 0, where 1 means identical, 0 opposite vectors. If for instance the `EPSILON` option is specified with an argument of 0.2, it means that we will get only elements that have a similarity of 0.8 or better (a distance \u003c 0.2). This is useful when a large `COUNT` is specified, yet we don\u0027t want elements that are too far away our query vector.\n+\n The `EF` argument is the exploration factor: the higher it is, the slower the command becomes, but the better the index is explored to find nodes that are near to our query. Sensible values are from 50 to 1000.\n \n The `TRUTH` option forces the command to perform a linear scan of all the entries inside the set, without using the graph search inside the HNSW, so it returns the best matching elements (the perfect result set) that can be used in order to easily calculate the recall. Of course the linear scan is `O(N)`, so it is much slower than the `log(N)` (considering a small `COUNT`) provided by the HNSW index.\ndiff --git a/modules/vector-sets/tests/epsilon.py b/modules/vector-sets/tests/epsilon.py\nnew file mode 100644\nindex 0000000..97e11c0\n--- /dev/null\n+++ b/modules/vector-sets/tests/epsilon.py\n@@ -0,0 +1,77 @@\n+from test import TestCase\n+\n+class EpsilonOption(TestCase):\n+    def getname(self):\n+        return \"VSIM EPSILON option filtering\"\n+\n+    def estimated_runtime(self):\n+        return 0.1\n+\n+    def test(self):\n+        # Add vectors as shown in the example\n+        # Vector \u0027a\u0027 at (1, 1) - normalized to (0.707, 0.707)\n+        result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027VALUES\u0027, \u00272\u0027, \u00271\u0027, \u00271\u0027, \u0027a\u0027)\n+        assert result \u003d\u003d 1, \"VADD should return 1 for item \u0027a\u0027\"\n+\n+        # Vector \u0027b\u0027 at (0, 1) - normalized to (0, 1)\n+        result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027VALUES\u0027, \u00272\u0027, \u00270\u0027, \u00271\u0027, \u0027b\u0027)\n+        assert result \u003d\u003d 1, \"VADD should return 1 for item \u0027b\u0027\"\n+\n+        # Vector \u0027c\u0027 at (0, 0) - this will be a zero vector, might be handled specially\n+        result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027VALUES\u0027, \u00272\u0027, \u00270\u0027, \u00270\u0027, \u0027c\u0027)\n+        assert result \u003d\u003d 1, \"VADD should return 1 for item \u0027c\u0027\"\n+\n+        # Vector \u0027d\u0027 at (0, -1) - normalized to (0, -1)\n+        result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027VALUES\u0027, \u00272\u0027, \u00270\u0027, \u0027-1\u0027, \u0027d\u0027)\n+        assert result \u003d\u003d 1, \"VADD should return 1 for item \u0027d\u0027\"\n+\n+        # Vector \u0027e\u0027 at (-1, -1) - normalized to (-0.707, -0.707)\n+        result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027VALUES\u0027, \u00272\u0027, \u0027-1\u0027, \u0027-1\u0027, \u0027e\u0027)\n+        assert result \u003d\u003d 1, \"VADD should return 1 for item \u0027e\u0027\"\n+\n+        # Test without EPSILON - should return all items\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, \u00272\u0027, \u00271\u0027, \u00271\u0027, \u0027WITHSCORES\u0027)\n+        # Result is a flat list: [elem1, score1, elem2, score2, ...]\n+        elements_all \u003d [result[i].decode() for i in range(0, len(result), 2)]\n+        scores_all \u003d [float(result[i]) for i in range(1, len(result), 2)]\n+\n+        assert len(elements_all) \u003d\u003d 5, f\"Should return 5 elements without EPSILON, got {len(elements_all)}\"\n+        assert elements_all[0] \u003d\u003d \u0027a\u0027, \"First element should be \u0027a\u0027 (most similar)\"\n+        assert scores_all[0] \u003d\u003d 1.0, \"Score for \u0027a\u0027 should be 1.0 (identical)\"\n+\n+        # Test with EPSILON 0.5 - should return only elements with similarity \u003e\u003d 0.5 (distance \u003c 0.5)\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, \u00272\u0027, \u00271\u0027, \u00271\u0027, \u0027WITHSCORES\u0027, \u0027EPSILON\u0027, \u00270.5\u0027)\n+        elements_epsilon_0_5 \u003d [result[i].decode() for i in range(0, len(result), 2)]\n+        scores_epsilon_0_5 \u003d [float(result[i]) for i in range(1, len(result), 2)]\n+\n+        assert len(elements_epsilon_0_5) \u003d\u003d 3, f\"With EPSILON 0.5, should return 3 elements, got {len(elements_epsilon_0_5)}\"\n+        assert set(elements_epsilon_0_5) \u003d\u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027}, f\"With EPSILON 0.5, should get a, b, c, got {elements_epsilon_0_5}\"\n+\n+        # Verify all returned scores are \u003e\u003d 0.5\n+        for i, score in enumerate(scores_epsilon_0_5):\n+            assert score \u003e\u003d 0.5, f\"Element {elements_epsilon_0_5[i]} has score {score} which is \u003c 0.5\"\n+\n+        # Test with EPSILON 0.2 - should return only elements with similarity \u003e\u003d 0.8 (distance \u003c 0.2)\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, \u00272\u0027, \u00271\u0027, \u00271\u0027, \u0027WITHSCORES\u0027, \u0027EPSILON\u0027, \u00270.2\u0027)\n+        elements_epsilon_0_2 \u003d [result[i].decode() for i in range(0, len(result), 2)]\n+        scores_epsilon_0_2 \u003d [float(result[i]) for i in range(1, len(result), 2)]\n+\n+        assert len(elements_epsilon_0_2) \u003d\u003d 2, f\"With EPSILON 0.2, should return 2 elements, got {len(elements_epsilon_0_2)}\"\n+        assert set(elements_epsilon_0_2) \u003d\u003d {\u0027a\u0027, \u0027b\u0027}, f\"With EPSILON 0.2, should get a, b, got {elements_epsilon_0_2}\"\n+\n+        # Verify all returned scores are \u003e\u003d 0.8 (since distance \u003c 0.2 means similarity \u003e 0.8)\n+        for i, score in enumerate(scores_epsilon_0_2):\n+            assert score \u003e\u003d 0.8, f\"Element {elements_epsilon_0_2[i]} has score {score} which is \u003c 0.8\"\n+\n+        # Test with very small EPSILON - should return only the exact match\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, \u00272\u0027, \u00271\u0027, \u00271\u0027, \u0027WITHSCORES\u0027, \u0027EPSILON\u0027, \u00270.001\u0027)\n+        elements_epsilon_small \u003d [result[i].decode() for i in range(0, len(result), 2)]\n+\n+        assert len(elements_epsilon_small) \u003d\u003d 1, f\"With EPSILON 0.001, should return only 1 element, got {len(elements_epsilon_small)}\"\n+        assert elements_epsilon_small[0] \u003d\u003d \u0027a\u0027, \"With very small EPSILON, should only get \u0027a\u0027\"\n+\n+        # Test with EPSILON 1.0 - should return all elements (since all similarities are between 0 and 1)\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, \u00272\u0027, \u00271\u0027, \u00271\u0027, \u0027WITHSCORES\u0027, \u0027EPSILON\u0027, \u00271.0\u0027)\n+        elements_epsilon_1 \u003d [result[i].decode() for i in range(0, len(result), 2)]\n+\n+        assert len(elements_epsilon_1) \u003d\u003d 5, f\"With EPSILON 1.0, should return all 5 elements, got {len(elements_epsilon_1)}\"\ndiff --git a/modules/vector-sets/vset.c b/modules/vector-sets/vset.c\nindex 2fc240b..47b3c49 100644\n--- a/modules/vector-sets/vset.c\n+++ b/modules/vector-sets/vset.c\n@@ -852,7 +852,7 @@ void VSIM_execute(RedisModuleCtx *ctx, struct vsetObject *vset,\n \n     long long arraylen \u003d 0;\n     for (unsigned int i \u003d 0; i \u003c found \u0026\u0026 i \u003c count; i++) {\n-        if (distances[i] \u003e epsilon) break;\n+        if (distances[i]/2 \u003e epsilon) break;\n         struct vsetNodeVal *nv \u003d neighbors[i]-\u003evalue;\n         RedisModule_ReplyWithString(ctx, nv-\u003eitem);\n         arraylen++;","expectedMessage":"VSIM EPSILON fixes (#14223)","repository":"redis-antirez","commitHash":"674b829981c0b8ad15a670a32df503e0e4514e96","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-b528788f","diff":" modules/vector-sets/hnsw.c                   |  7 ++++++\n modules/vector-sets/tests/persistence.py     |  4 ++--\n modules/vector-sets/tests/vrand-ping-pong.py | 35 ++++++++++++++++++++++++++++\n 3 files changed, 44 insertions(+), 2 deletions(-)\n\ndiff --git a/modules/vector-sets/hnsw.c b/modules/vector-sets/hnsw.c\nindex 701c1f0..cae43e3 100644\n--- a/modules/vector-sets/hnsw.c\n+++ b/modules/vector-sets/hnsw.c\n@@ -1975,6 +1975,13 @@ hnswNode *hnsw_random_node(HNSW *index, int slot) {\n     double logN \u003d log2(index-\u003enode_count + 1);\n     uint32_t num_walks \u003d (uint32_t)(logN * c);\n \n+    /* Avoid the ping-pong effect: imagine there are just two nodes and\n+     * the number of walks selected is even. We will select always the\n+     * first element of the graph; conversely, if it is odd, we will always\n+     * select the other element. One way to add more selection randomness is\n+     * to randomly add \u00271\u0027 or \u00270\u0027 to the number of walks to perform. */\n+    num_walks +\u003d rand() \u0026 1;\n+\n     // Perform random walk at level 0.\n     for (uint32_t i \u003d 0; i \u003c num_walks; i++) {\n         if (current-\u003elayers[0].num_links \u003d\u003d 0) return current;\ndiff --git a/modules/vector-sets/tests/persistence.py b/modules/vector-sets/tests/persistence.py\nindex 948b904..79730f4 100644\n--- a/modules/vector-sets/tests/persistence.py\n+++ b/modules/vector-sets/tests/persistence.py\n@@ -82,5 +82,5 @@ class HNSWPersistence(TestCase):\n                 f\"Projected vectors: Score mismatch for {key}: \" + \\\n                 f\"before\u003d{initial_projected[key]:.6f}, after\u003d{reloaded_projected[key]:.6f}\"\n \n-        self.redis.del(f\"{self.test_key}:normal\")\n-        self.redis.del(f\"{self.test_key}:projected\")\n+        self.redis.delete(f\"{self.test_key}:normal\")\n+        self.redis.delete(f\"{self.test_key}:projected\")\ndiff --git a/modules/vector-sets/tests/vrand-ping-pong.py b/modules/vector-sets/tests/vrand-ping-pong.py\nnew file mode 100644\nindex 0000000..99d2e9a\n--- /dev/null\n+++ b/modules/vector-sets/tests/vrand-ping-pong.py\n@@ -0,0 +1,35 @@\n+from test import TestCase, generate_random_vector\n+import struct\n+\n+class VRANDMEMBERPingPongRegressionTest(TestCase):\n+    def getname(self):\n+        return \"[regression] VRANDMEMBER ping-pong\"\n+\n+    def test(self):\n+        \"\"\"\n+        This test ensures that when only two vectors exist, VRANDMEMBER\n+        does not get stuck returning only one of them due to the \"ping-pong\" issue.\n+        \"\"\"\n+        self.redis.delete(self.test_key) # Clean up before test\n+        dim \u003d 4\n+\n+        # Add exactly two vectors\n+        vec1_name \u003d \"vec1\"\n+        vec1_data \u003d generate_random_vector(dim)\n+        self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027VALUES\u0027, dim, *vec1_data, vec1_name)\n+\n+        vec2_name \u003d \"vec2\"\n+        vec2_data \u003d generate_random_vector(dim)\n+        self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027VALUES\u0027, dim, *vec2_data, vec2_name)\n+\n+        # Call VRANDMEMBER many times and check for distribution\n+        iterations \u003d 100\n+        results \u003d []\n+        for _ in range(iterations):\n+            member \u003d self.redis.execute_command(\u0027VRANDMEMBER\u0027, self.test_key)\n+            results.append(member.decode())\n+\n+        # Verify that both members were returned, proving it\u0027s not stuck\n+        unique_results \u003d set(results)\n+\n+        assert len(unique_results) \u003d\u003d 2, f\"Ping-pong test failed: should have returned 2 unique members, but got {len(unique_results)}.\"","expectedMessage":"Fix vrand ping pong (#14183)","repository":"redis-antirez","commitHash":"b528788f6547e73afead8bd37cbc0c0bb373e871","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-b5d54866","diff":" modules/vector-sets/hnsw.c | 96 ++++++++++++++++++++++++++++++++++++++--------\n 1 file changed, 80 insertions(+), 16 deletions(-)\n\ndiff --git a/modules/vector-sets/hnsw.c b/modules/vector-sets/hnsw.c\nindex cd38e44..701c1f0 100644\n--- a/modules/vector-sets/hnsw.c\n+++ b/modules/vector-sets/hnsw.c\n@@ -2058,6 +2058,18 @@ hnswNode *hnsw_random_node(HNSW *index, int slot) {\n  * hash table, then scan all the nodes again and fix all the links converting\n  * the ID to the pointer. */\n \n+/* History of serialization versions:\n+ * version 0: the first implementation, lacking worst node id/info.\n+ * version 1: includes worst link id/info. */\n+#define HNSW_SERIALIZATION_VERSION 1\n+\n+/* This is a special worst link index that is set when loading a serialized\n+ * node with version 0 (this version of the serialization lacked explicit\n+ * information about the worst link index/distance). This way, later, the\n+ * function that fixes a deserialized index will know to compute the worst\n+ * index info at runtime. */\n+#define HNSW_SER_WORSTLINK_MISSING UINT32_MAX\n+\n /* Return the serialized node information as specified in the top comment\n  * above. Note that the returned information is true as long as the node\n  * provided is not deleted or modified, so this function should be called\n@@ -2073,6 +2085,7 @@ hnswSerNode *hnsw_serialize_node(HNSW *index, hnswNode *node) {\n     for (uint32_t i \u003d 0; i \u003c\u003d node-\u003elevel; i++) {\n         num_params +\u003d 2; // max_links and num_links info for this layer.\n         num_params +\u003d node-\u003elayers[i].num_links; // The IDs of linked nodes.\n+        num_params +\u003d 1; // worst link id/distance parameter.\n     }\n \n     /* We use another 64bit value to store two floats that are about\n@@ -2096,18 +2109,43 @@ hnswSerNode *hnsw_serialize_node(HNSW *index, hnswNode *node) {\n \n     uint32_t param_idx \u003d 0;\n     sn-\u003eparams[param_idx++] \u003d node-\u003eid;\n-    sn-\u003eparams[param_idx++] \u003d node-\u003elevel;\n+    /* The second parameter contains information about the serialization\n+     * version of this node, the node level and some unused field:\n+     *\n+     * +--------+--------+--------+--------+\n+     * |VVVVVVVV|........|........|LLLLLLLL|\n+     * +--------+--------+--------+--------+\n+     *\n+     * V is the version, 8 bits.\n+     * L is the node level, 8 bits (but actually 16 is the max so far).\n+     * The middle two bytes are reserved for future uses. */\n+    sn-\u003eparams[param_idx] \u003d node-\u003elevel \u0026 0xff;\n+    sn-\u003eparams[param_idx] |\u003d HNSW_SERIALIZATION_VERSION \u003c\u003c 24;\n+    param_idx++;\n     for (uint32_t i \u003d 0; i \u003c\u003d node-\u003elevel; i++) {\n         sn-\u003eparams[param_idx++] \u003d node-\u003elayers[i].num_links;\n         sn-\u003eparams[param_idx++] \u003d node-\u003elayers[i].max_links;\n         for (uint32_t j \u003d 0; j \u003c node-\u003elayers[i].num_links; j++) {\n             sn-\u003eparams[param_idx++] \u003d node-\u003elayers[i].links[j]-\u003eid;\n         }\n-    }\n-    uint64_t l2_and_range \u003d 0;\n-    unsigned char *aux \u003d (unsigned char*)\u0026l2_and_range;\n-    memcpy(aux,\u0026node-\u003el2,sizeof(float));\n-    memcpy(aux+4,\u0026node-\u003equants_range,sizeof(float));\n+        /* Since version 1: pack and store worst_idx and worst_distance. */\n+        uint32_t worst_distance_bits;\n+        memcpy(\u0026worst_distance_bits, \u0026node-\u003elayers[i].worst_distance,\n+               sizeof(float));\n+        uint64_t wi \u003d\n+            (((uint64_t)worst_distance_bits) \u003c\u003c 32) | node-\u003elayers[i].worst_idx;\n+        sn-\u003eparams[param_idx++] \u003d wi;\n+    }\n+\n+    /* Store l2 and range as uint32_t, in a way that is endian-safe.\n+     * Note that in big endian archs both are reversed: integers and\n+     * also the bytes of floats, so they will match. */\n+    uint64_t l2_and_range;\n+    uint32_t l2_bits, range_bits;\n+    memcpy(\u0026l2_bits,\u0026node-\u003el2,sizeof(float));\n+    memcpy(\u0026range_bits,\u0026node-\u003equants_range,sizeof(float));\n+    l2_and_range \u003d ((uint64_t)range_bits\u003c\u003c32) | l2_bits;\n+\n     sn-\u003eparams[param_idx++] \u003d l2_and_range;\n \n     /* Better safe than sorry: */\n@@ -2128,13 +2166,18 @@ void hnsw_free_serialized_node(hnswSerNode *sn) {\n  * The function returns NULL both on out of memory and if the remaining\n  * parameters length does not match the number of links or other items\n  * to load. */\n-#define HNSW_SER_WORSTLINK_MISSING UINT32_MAX\n hnswNode *hnsw_insert_serialized(HNSW *index, void *vector, uint64_t *params, uint32_t params_len, void *value)\n {\n     if (params_len \u003c 2) return NULL;\n \n     uint64_t id \u003d params[0];\n-    uint32_t level \u003d params[1];\n+    /* Check the node serialization function for the specific layout\n+     * of param[1] fields. */\n+    uint32_t level \u003d params[1] \u0026 0xff;                  // Node level.\n+    uint32_t version \u003d (params[1] \u0026 0xff000000) \u003e\u003e 24;  // Format version.\n+\n+    if (version \u003e HNSW_SERIALIZATION_VERSION) return NULL;\n+    int has_worst_link_info \u003d version \u003e 0;\n \n     /* Keep track of maximum ID seen while loading. */\n     if (id \u003e\u003d index-\u003elast_id) index-\u003elast_id \u003d id;\n@@ -2152,7 +2195,7 @@ hnswNode *hnsw_insert_serialized(HNSW *index, void *vector, uint64_t *params, ui\n     uint32_t param_idx \u003d 2;\n     for (uint32_t i \u003d 0; i \u003c\u003d level; i++) {\n         /* Sanity check. */\n-        if (param_idx + 2 \u003e params_len) {\n+        if (param_idx + 2 + has_worst_link_info \u003e params_len) {\n             hnsw_node_free(node);\n             return NULL;\n         }\n@@ -2183,7 +2226,7 @@ hnswNode *hnsw_insert_serialized(HNSW *index, void *vector, uint64_t *params, ui\n         node-\u003elayers[i].num_links \u003d num_links;\n \n         /* Sanity check. */\n-        if (param_idx + num_links \u003e params_len) {\n+        if (param_idx + num_links + has_worst_link_info \u003e params_len) {\n             hnsw_node_free(node);\n             return NULL;\n         }\n@@ -2195,9 +2238,26 @@ hnswNode *hnsw_insert_serialized(HNSW *index, void *vector, uint64_t *params, ui\n         for (uint32_t j \u003d 0; j \u003c num_links; j++)\n             node-\u003elayers[i].links[j] \u003d (hnswNode*)params[param_idx++];\n \n-        /* XXX: fix me, we need to store the worst link info in a\n-         * backward compatible way. */\n-        node-\u003elayers[i].worst_idx \u003d HNSW_SER_WORSTLINK_MISSING;\n+        if (has_worst_link_info) {\n+            uint64_t wi \u003d params[param_idx++];\n+            uint32_t worst_idx \u003d wi \u0026 0xffffffff;\n+            uint32_t worst_distance_bits \u003d wi \u003e\u003e 32;\n+            float worst_distance;\n+            memcpy(\u0026worst_distance,\u0026worst_distance_bits,sizeof(float));\n+            node-\u003elayers[i].worst_idx \u003d worst_idx;\n+            node-\u003elayers[i].worst_distance \u003d worst_distance;\n+\n+            // Sanity check the worst ID range.\n+            if (node-\u003elayers[i].num_links \u003e 0 \u0026\u0026\n+                node-\u003elayers[i].worst_idx \u003e\u003d node-\u003elayers[i].num_links)\n+            {\n+                hnsw_node_free(node);\n+                return NULL;\n+            }\n+        } else {\n+            node-\u003elayers[i].worst_idx \u003d HNSW_SER_WORSTLINK_MISSING;\n+            node-\u003elayers[i].worst_distance \u003d 0;\n+        }\n     }\n \n     /* Get l2 and quantization range. */\n@@ -2205,10 +2265,14 @@ hnswNode *hnsw_insert_serialized(HNSW *index, void *vector, uint64_t *params, ui\n         hnsw_node_free(node);\n         return NULL;\n     }\n+\n+    /* Load l2 and range packed into an uint64_t in an endian safe way. */\n     uint64_t l2_and_range \u003d params[param_idx];\n-    unsigned char *aux \u003d (unsigned char*)\u0026l2_and_range;\n-    memcpy(\u0026node-\u003el2, aux, sizeof(float));\n-    memcpy(\u0026node-\u003equants_range, aux+4, sizeof(float));\n+    uint32_t l2_bits, range_bits;\n+    l2_bits \u003d l2_and_range \u0026 0xffffffff;\n+    range_bits \u003d l2_and_range \u003e\u003e 32;\n+    memcpy(\u0026node-\u003el2, \u0026l2_bits, sizeof(float));\n+    memcpy(\u0026node-\u003equants_range, \u0026range_bits, sizeof(float));\n \n     node-\u003evalue \u003d value;\n     hnsw_add_node(index, node);","expectedMessage":"[Vector sets] Endianess fix and speedup of data loading (#14144)","repository":"redis-antirez","commitHash":"b5d54866ac9f17192b4e747dd27fe9db9022eb49","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-8948a5d2","diff":" modules/vector-sets/README.md            |  12 ++++\n modules/vector-sets/expr.c               |  25 +++++--\n modules/vector-sets/tests/filter_expr.py | 109 ++++++++++++++++++++++++-------\n 3 files changed, 120 insertions(+), 26 deletions(-)\n\ndiff --git a/modules/vector-sets/README.md b/modules/vector-sets/README.md\nindex 07180c1..cbc95a1 100644\n--- a/modules/vector-sets/README.md\n+++ b/modules/vector-sets/README.md\n@@ -365,6 +365,18 @@ JSON attributes are converted in this way:\n \n Any other type is ignored, and accessig it will make the expression evaluate to false.\n \n+### The IN operator\n+\n+The `IN` operator works in two ways, it can test for membership in an array, like in:\n+\n+    5 in [1, 2, 3]\n+    \"foo\" in [1, \"foo\", \"bar\"]\n+\n+But can also check for substrings, in case the A and B operators are both strings.\n+\n+    \"foo\" in \"barfoobar\" # Will evaluate to true\n+    \"zap\" in \"foobar\" # Will evaluate to false\n+\n ### Examples\n \n ```\ndiff --git a/modules/vector-sets/expr.c b/modules/vector-sets/expr.c\nindex 9be54eb..4f3a1cc 100644\n--- a/modules/vector-sets/expr.c\n+++ b/modules/vector-sets/expr.c\n@@ -20,7 +20,6 @@\n #define RedisModule_Assert assert\n #define _DEFAULT_SOURCE\n #define _USE_MATH_DEFINES\n-#define _POSIX_C_SOURCE 200809L\n #include \u003cassert.h\u003e\n #include \u003cmath.h\u003e\n #endif\n@@ -620,11 +619,12 @@ exprstate *exprCompile(char *expr, int *errpos) {\n \n         if (token-\u003etoken_type \u003d\u003d EXPR_TOKEN_EOF) break;\n \n-        /* Handle values (numbers, strings, selectors). */\n+        /* Handle values (numbers, strings, selectors, null). */\n         if (token-\u003etoken_type \u003d\u003d EXPR_TOKEN_NUM ||\n             token-\u003etoken_type \u003d\u003d EXPR_TOKEN_STR ||\n             token-\u003etoken_type \u003d\u003d EXPR_TOKEN_TUPLE ||\n-            token-\u003etoken_type \u003d\u003d EXPR_TOKEN_SELECTOR)\n+            token-\u003etoken_type \u003d\u003d EXPR_TOKEN_SELECTOR ||\n+            token-\u003etoken_type \u003d\u003d EXPR_TOKEN_NULL)\n         {\n             exprStackPush(\u0026es-\u003eprogram, token);\n             exprTokenRetain(token);\n@@ -734,6 +734,17 @@ int exprTokensEqual(exprtoken *a, exprtoken *b) {\n     return exprTokenToNum(a) \u003d\u003d exprTokenToNum(b);\n }\n \n+/* Return true if the string a is a substring of b. */\n+int exprTokensStringIn(exprtoken *a, exprtoken *b) {\n+    RedisModule_Assert(a-\u003etoken_type \u003d\u003d EXPR_TOKEN_STR \u0026\u0026\n+                       b-\u003etoken_type \u003d\u003d EXPR_TOKEN_STR);\n+    if (a-\u003estr.len \u003e b-\u003estr.len) return 0; // A is bigger, can\u0027t be a substring.\n+    for (size_t i \u003d 0; i \u003c\u003d b-\u003estr.len - a-\u003estr.len; i++) {\n+        if (memcmp(b-\u003estr.start+i,a-\u003estr.start,a-\u003estr.len) \u003d\u003d 0) return 1;\n+    }\n+    return 0;\n+}\n+\n #include \"fastjson.c\" // JSON parser implementation used by exprRun().\n \n /* Execute the compiled expression program. Returns 1 if the final stack value\n@@ -823,7 +834,9 @@ int exprRun(exprstate *es, char *json, size_t json_len) {\n             result-\u003enum \u003d !exprTokensEqual(a, b) ? 1 : 0;\n             break;\n         case EXPR_OP_IN: {\n-            // For \u0027in\u0027 operator, b must be a tuple.\n+            /* For \u0027in\u0027 operator, b must be a tuple, and we check for\n+             * membership. Otherwise both a and b must be strings, and\n+             * in this case we check if a is a substring of b. */\n             result-\u003enum \u003d 0;  // Default to false.\n             if (b-\u003etoken_type \u003d\u003d EXPR_TOKEN_TUPLE) {\n                 for (size_t j \u003d 0; j \u003c b-\u003etuple.len; j++) {\n@@ -832,6 +845,10 @@ int exprRun(exprstate *es, char *json, size_t json_len) {\n                         break;\n                     }\n                 }\n+            } else if (a-\u003etoken_type \u003d\u003d EXPR_TOKEN_STR \u0026\u0026\n+                       b-\u003etoken_type \u003d\u003d EXPR_TOKEN_STR)\n+            {\n+                result-\u003enum \u003d exprTokensStringIn(a,b);\n             }\n             break;\n         }\ndiff --git a/modules/vector-sets/tests/filter_expr.py b/modules/vector-sets/tests/filter_expr.py\nindex 13abf7b..364915d 100644\n--- a/modules/vector-sets/tests/filter_expr.py\n+++ b/modules/vector-sets/tests/filter_expr.py\n@@ -39,124 +39,189 @@ class VSIMFilterExpressions(TestCase):\n         self.redis.execute_command(\u0027VSETATTR\u0027, self.test_key, f\u0027{self.test_key}:item:5\u0027,\n                                   \u0027invalid json\u0027)  # Intentionally malformed JSON\n \n-        # Test 1: Basic equality with numbers\n+        # Basic equality with numbers\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age \u003d\u003d 25\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for age \u003d\u003d 25\"\n         assert result[0].decode() \u003d\u003d f\u0027{self.test_key}:item:1\u0027, \"Expected item:1 for age \u003d\u003d 25\"\n \n-        # Test 2: Greater than\n+        # Greater than\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age \u003e 25\u0027)\n         assert len(result) \u003d\u003d 2, \"Expected 2 results for age \u003e 25\"\n \n-        # Test 3: Less than or equal\n+        # Less than or equal\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age \u003c\u003d 30\u0027)\n         assert len(result) \u003d\u003d 2, \"Expected 2 results for age \u003c\u003d 30\"\n \n-        # Test 4: String equality\n+        # String equality\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.name \u003d\u003d \"Alice\"\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for name \u003d\u003d Alice\"\n         assert result[0].decode() \u003d\u003d f\u0027{self.test_key}:item:1\u0027, \"Expected item:1 for name \u003d\u003d Alice\"\n \n-        # Test 5: String inequality\n+        # String inequality\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.name !\u003d \"Alice\"\u0027)\n         assert len(result) \u003d\u003d 2, \"Expected 2 results for name !\u003d Alice\"\n \n-        # Test 6: Boolean value\n+        # Boolean value\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.active\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for .active being true\"\n \n-        # Test 7: Logical AND\n+        # Logical AND\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age \u003e 20 and .age \u003c 30\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for 20 \u003c age \u003c 30\"\n         assert result[0].decode() \u003d\u003d f\u0027{self.test_key}:item:1\u0027, \"Expected item:1 for 20 \u003c age \u003c 30\"\n \n-        # Test 8: Logical OR\n+        # Logical OR\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age \u003c 30 or .age \u003e 35\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for age \u003c 30 or age \u003e 35\"\n \n-        # Test 9: Logical NOT\n+        # Logical NOT\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027!(.age \u003d\u003d 25)\u0027)\n         assert len(result) \u003d\u003d 2, \"Expected 2 results for NOT(age \u003d\u003d 25)\"\n \n-        # Test 10: The \"in\" operator with array\n+        # The \"in\" operator with array\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age in [25, 35]\u0027)\n         assert len(result) \u003d\u003d 2, \"Expected 2 results for age in [25, 35]\"\n \n-        # Test 11: The \"in\" operator with strings in array\n+        # The \"in\" operator with strings in array\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.name in [\"Alice\", \"David\"]\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for name in [Alice, David]\"\n \n-        # Test 12: Arithmetic operations - addition\n+        # The \"in\" operator for substring matching\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n+                                          *[str(x) for x in vec1],\n+                                          \u0027FILTER\u0027, \u0027\"lic\" in .name\u0027)\n+        assert len(result) \u003d\u003d 1, \"Expected 1 result for \u0027lic\u0027 in name\"\n+        assert result[0].decode() \u003d\u003d f\u0027{self.test_key}:item:1\u0027, \"Expected item:1 (Alice)\"\n+\n+        # The \"in\" operator with city substring\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n+                                          *[str(x) for x in vec1],\n+                                          \u0027FILTER\u0027, \u0027\"ork\" in .city\u0027)\n+        assert len(result) \u003d\u003d 1, \"Expected 1 result for \u0027ork\u0027 in city\"\n+        assert result[0].decode() \u003d\u003d f\u0027{self.test_key}:item:1\u0027, \"Expected item:1 (New York)\"\n+\n+        # The \"in\" operator with no matches\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n+                                          *[str(x) for x in vec1],\n+                                          \u0027FILTER\u0027, \u0027\"xyz\" in .name\u0027)\n+        assert len(result) \u003d\u003d 0, \"Expected 0 results for \u0027xyz\u0027 in name\"\n+\n+        # Off-by-one tests - substring at the beginning\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n+                                          *[str(x) for x in vec1],\n+                                          \u0027FILTER\u0027, \u0027\"Ali\" in .name\u0027)\n+        assert len(result) \u003d\u003d 1, \"Expected 1 result for \u0027Ali\u0027 at beginning of \u0027Alice\u0027\"\n+        assert result[0].decode() \u003d\u003d f\u0027{self.test_key}:item:1\u0027, \"Expected item:1\"\n+\n+        # Off-by-one tests - substring at the end\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n+                                          *[str(x) for x in vec1],\n+                                          \u0027FILTER\u0027, \u0027\"ice\" in .name\u0027)\n+        assert len(result) \u003d\u003d 1, \"Expected 1 result for \u0027ice\u0027 at end of \u0027Alice\u0027\"\n+        assert result[0].decode() \u003d\u003d f\u0027{self.test_key}:item:1\u0027, \"Expected item:1\"\n+\n+        # Off-by-one tests - exact match (entire string)\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n+                                          *[str(x) for x in vec1],\n+                                          \u0027FILTER\u0027, \u0027\"Alice\" in .name\u0027)\n+        assert len(result) \u003d\u003d 1, \"Expected 1 result for exact match \u0027Alice\u0027 in \u0027Alice\u0027\"\n+        assert result[0].decode() \u003d\u003d f\u0027{self.test_key}:item:1\u0027, \"Expected item:1\"\n+\n+        # Off-by-one tests - single character\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n+                                          *[str(x) for x in vec1],\n+                                          \u0027FILTER\u0027, \u0027\"A\" in .name\u0027)\n+        assert len(result) \u003d\u003d 1, \"Expected 1 result for single char \u0027A\u0027 in \u0027Alice\u0027\"\n+\n+        # Off-by-one tests - empty string (should match all strings)\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n+                                          *[str(x) for x in vec1],\n+                                          \u0027FILTER\u0027, \u0027\"\" in .name\u0027)\n+        assert len(result) \u003d\u003d 3, \"Expected 3 results for empty string (matches all strings)\"\n+\n+        # Off-by-one tests - non-empty strings are never substrings of \"\"\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n+                                          *[str(x) for x in vec1],\n+                                          \u0027FILTER\u0027, \u0027.name in \"\"\u0027)\n+        assert len(result) \u003d\u003d 0, \"Expected 0 results for empty string on the right of IN operator\"\n+\n+        # Off-by-one tests - empty string match empty string.\n+        result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n+                                          *[str(x) for x in vec1],\n+                                          \u0027FILTER\u0027, \u0027\"\" in .name \u0026\u0026 \"\" in \"\"\u0027)\n+        assert len(result) \u003d\u003d 3, \"Expected empty string matching empty string\"\n+\n+        # Arithmetic operations - addition\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age + 10 \u003e 40\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for age + 10 \u003e 40\"\n \n-        # Test 13: Arithmetic operations - multiplication\n+        # Arithmetic operations - multiplication\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age * 2 \u003e 60\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for age * 2 \u003e 60\"\n \n-        # Test 14: Arithmetic operations - division\n+        # Arithmetic operations - division\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age / 5 \u003d\u003d 5\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for age / 5 \u003d\u003d 5\"\n \n-        # Test 15: Arithmetic operations - modulo\n+        # Arithmetic operations - modulo\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age % 2 \u003d\u003d 0\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for age % 2 \u003d\u003d 0\"\n \n-        # Test 16: Power operator\n+        # Power operator\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age ** 2 \u003e 900\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for age^2 \u003e 900\"\n \n-        # Test 17: Missing attribute (should exclude items missing that attribute)\n+        # Missing attribute (should exclude items missing that attribute)\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.missing_field \u003d\u003d \"value\"\u0027)\n         assert len(result) \u003d\u003d 0, \"Expected 0 results for missing_field \u003d\u003d value\"\n \n-        # Test 18: No attribute set at all\n+        # No attribute set at all\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.any_field\u0027)\n         assert f\u0027{self.test_key}:item:4\u0027 not in [item.decode() for item in result], \"Item with no attribute should be excluded\"\n \n-        # Test 19: Malformed JSON\n+        # Malformed JSON\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.any_field\u0027)\n         assert f\u0027{self.test_key}:item:5\u0027 not in [item.decode() for item in result], \"Item with malformed JSON should be excluded\"\n \n-        # Test 20: Complex expression combining multiple operators\n+        # Complex expression combining multiple operators\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027(.age \u003e 20 and .age \u003c 40) and (.city \u003d\u003d \"Boston\" or .city \u003d\u003d \"New York\")\u0027)\n@@ -164,13 +229,13 @@ class VSIMFilterExpressions(TestCase):\n         expected_items \u003d [f\u0027{self.test_key}:item:1\u0027, f\u0027{self.test_key}:item:2\u0027]\n         assert set([item.decode() for item in result]) \u003d\u003d set(expected_items), \"Expected item:1 and item:2 for the complex expression\"\n \n-        # Test 21: Parentheses to control operator precedence\n+        # Parentheses to control operator precedence\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.age \u003e (20 + 10)\u0027)\n         assert len(result) \u003d\u003d 1, \"Expected 1 result for age \u003e (20 + 10)\"\n \n-        # Test 22: Array access (arrays evaluate to true)\n+        # Array access (arrays evaluate to true)\n         result \u003d self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, 4,\n                                           *[str(x) for x in vec1],\n                                           \u0027FILTER\u0027, \u0027.scores\u0027)","expectedMessage":"[Vector Sets] IN operator for string/string operands (#14122)","repository":"redis-antirez","commitHash":"8948a5d2b22472fd65857a4258b290ae22e5da96","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-f6d1fd08","diff":" modules/vector-sets/test.py              | 42 +++++++++++++++++++-------------\n modules/vector-sets/tests/persistence.py |  3 +++\n 2 files changed, 28 insertions(+), 17 deletions(-)\n\ndiff --git a/modules/vector-sets/test.py b/modules/vector-sets/test.py\nindex b8cbc32..1eeb28e 100755\n--- a/modules/vector-sets/test.py\n+++ b/modules/vector-sets/test.py\n@@ -28,7 +28,10 @@ def colored(text: str, color: str) -\u003e str:\n     colors \u003d {\n         \u0027red\u0027: \u0027\\033[91m\u0027,\n         \u0027green\u0027: \u0027\\033[92m\u0027,\n-        \u0027yellow\u0027: \u0027\\033[93m\u0027\n+        \u0027yellow\u0027: \u0027\\033[93m\u0027,\n+        \u0027blue\u0027: \u0027\\033[94m\u0027,\n+        \u0027magenta\u0027: \u0027\\033[95m\u0027,\n+        \u0027cyan\u0027: \u0027\\033[96m\u0027,\n     }\n     reset \u003d \u0027\\033[0m\u0027\n     return f\"{colors.get(color, \u0027\u0027)}{text}{reset}\"\n@@ -93,10 +96,10 @@ class TestCase:\n         self.error_details \u003d None\n         self.test_key \u003d f\"test:{self.__class__.__name__.lower()}\"\n         # Primary Redis instance\n-        self.redis \u003d redis.Redis(port\u003dprimary_port)\n-        self.redis3 \u003d redis.Redis(port\u003dprimary_port,protocol\u003d3)\n+        self.redis \u003d redis.Redis(port\u003dprimary_port,db\u003d9)\n+        self.redis3 \u003d redis.Redis(port\u003dprimary_port,protocol\u003d3,db\u003d9)\n         # Replica Redis instance\n-        self.replica \u003d redis.Redis(port\u003dreplica_port)\n+        self.replica \u003d redis.Redis(port\u003dreplica_port,db\u003d9)\n         # Replication status\n         self.replication_setup \u003d False\n         # Ports\n@@ -118,7 +121,7 @@ class TestCase:\n         self.replica.execute_command(\u0027REPLICAOF\u0027, \u0027127.0.0.1\u0027, self.primary_port)\n \n         # Wait for replication to be established\n-        max_attempts \u003d 10\n+        max_attempts \u003d 50\n         for attempt in range(max_attempts):\n             # Check replication info\n             repl_info \u003d self.replica.info(\u0027replication\u0027)\n@@ -133,6 +136,7 @@ class TestCase:\n                 return True\n \n             # Wait before next attempt\n+            print(colored(\".\",\u0027cyan\u0027),end\u003d\"\",flush\u003dTrue)\n             time.sleep(0.5)\n \n         # If we get here, replication wasn\u0027t established\n@@ -183,12 +187,7 @@ def find_test_classes(primary_port, replica_port):\n                 for name, obj in inspect.getmembers(module):\n                     if inspect.isclass(obj) and obj.__name__ !\u003d \u0027TestCase\u0027 and hasattr(obj, \u0027test\u0027):\n                         # Create test instance with specified ports\n-                        test_instance \u003d obj()\n-                        test_instance.redis \u003d redis.Redis(port\u003dprimary_port)\n-                        test_instance.redis3 \u003d redis.Redis(port\u003dprimary_port,protocol\u003d3)\n-                        test_instance.replica \u003d redis.Redis(port\u003dreplica_port)\n-                        test_instance.primary_port \u003d primary_port\n-                        test_instance.replica_port \u003d replica_port\n+                        test_instance \u003d obj(primary_port,replica_port)\n                         test_classes.append(test_instance)\n             except Exception as e:\n                 print(f\"Error loading {file}: {e}\")\n@@ -200,7 +199,7 @@ def check_redis_empty(r, instance_name):\n     try:\n         dbsize \u003d r.dbsize()\n         if dbsize \u003e 0:\n-            print(colored(f\"ERROR: {instance_name} Redis instance is not empty (dbsize: {dbsize}).\", \"red\"))\n+            print(colored(f\"ERROR: {instance_name} Redis instance DB 9 is not empty (dbsize: {dbsize}).\", \"red\"))\n             print(colored(\"Make sure you\u0027re not using a production instance and that all data is safe to delete.\", \"red\"))\n             sys.exit(1)\n     except redis.exceptions.ConnectionError:\n@@ -215,7 +214,7 @@ def check_replica_running(replica_port):\n         return True\n     except redis.exceptions.ConnectionError:\n         print(colored(f\"WARNING: Replica Redis instance (port {replica_port}) is not running.\", \"yellow\"))\n-        print(colored(\"Replication tests will fail. Make sure to start the replica instance.\", \"yellow\"))\n+        print(colored(\"Replication tests will be skipped. Make sure to start the replica instance.\", \"yellow\"))\n         return False\n \n def run_tests():\n@@ -233,8 +232,8 @@ def run_tests():\n     print(\"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\")\n \n     # Check if Redis instances are empty\n-    primary \u003d redis.Redis(port\u003dargs.primary_port)\n-    replica \u003d redis.Redis(port\u003dargs.replica_port)\n+    primary \u003d redis.Redis(port\u003dargs.primary_port,db\u003d9)\n+    replica \u003d redis.Redis(port\u003dargs.replica_port,db\u003d9)\n \n     check_redis_empty(primary, \"Primary\")\n \n@@ -252,12 +251,18 @@ def run_tests():\n     tests.sort(key\u003dlambda t: t.estimated_runtime())\n \n     passed \u003d 0\n+    skipped \u003d 0\n     total \u003d len(tests)\n \n     for test in tests:\n         print(f\"{test.getname()}: \", end\u003d\"\")\n         sys.stdout.flush()\n \n+        if not replica_running and test.getname().lower().find(\"replication\") !\u003d -1:\n+            print(colored(\"SKIPPING\",\"yellow\"))\n+            skipped +\u003d 1\n+            continue\n+\n         start_time \u003d time.time()\n         success \u003d test.run()\n         duration \u003d time.time() - start_time\n@@ -276,9 +281,12 @@ def run_tests():\n     print(f\"\\nTest Summary: {passed}/{total} tests passed\")\n \n     if passed \u003d\u003d total:\n-        print(colored(\"\\nALL TESTS PASSED!\", \"green\"))\n+        print(colored(\"ALL TESTS PASSED!\", \"green\"))\n     else:\n-        print(colored(f\"\\n{total-passed} TESTS FAILED!\", \"red\"))\n+        if total-skipped-passed \u003e 0:\n+            print(colored(f\"{total-skipped-passed} TESTS FAILED!\", \"red\"))\n+        if skipped \u003e 0:\n+            print(colored(f\"{skipped} TESTS SKIPPED!\", \"yellow\"))\n \n if __name__ \u003d\u003d \"__main__\":\n     run_tests()\ndiff --git a/modules/vector-sets/tests/persistence.py b/modules/vector-sets/tests/persistence.py\nindex 021c8b6..948b904 100644\n--- a/modules/vector-sets/tests/persistence.py\n+++ b/modules/vector-sets/tests/persistence.py\n@@ -81,3 +81,6 @@ class HNSWPersistence(TestCase):\n             assert abs(initial_projected[key] - reloaded_projected[key]) \u003c 0.0001, \\\n                 f\"Projected vectors: Score mismatch for {key}: \" + \\\n                 f\"before\u003d{initial_projected[key]:.6f}, after\u003d{reloaded_projected[key]:.6f}\"\n+\n+        self.redis.del(f\"{self.test_key}:normal\")\n+        self.redis.del(f\"{self.test_key}:projected\")","expectedMessage":"Vset tests improvements (#14089)","repository":"redis-antirez","commitHash":"f6d1fd08f9b03a90c4e6a18866f8709b86bae627","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-27dd3b71","diff":" modules/vector-sets/hnsw.c  | 104 ++++++++++++++++++++++++++++++++++++++++---\n modules/vector-sets/hnsw.h  |   2 +-\n modules/vector-sets/mixer.h | 106 ++++++++++++++++++++++++++++++++++++++++++++\n modules/vector-sets/vset.c  |   5 ++-\n 4 files changed, 210 insertions(+), 7 deletions(-)\n\ndiff --git a/modules/vector-sets/hnsw.c b/modules/vector-sets/hnsw.c\nindex 291c95b..cd38e44 100644\n--- a/modules/vector-sets/hnsw.c\n+++ b/modules/vector-sets/hnsw.c\n@@ -45,6 +45,7 @@\n #include \u003cfloat.h\u003e  /* for INFINITY if not in math.h */\n #include \u003cassert.h\u003e\n #include \"hnsw.h\"\n+#include \"mixer.h\"\n \n #if 0\n #define debugmsg printf\n@@ -2127,6 +2128,7 @@ void hnsw_free_serialized_node(hnswSerNode *sn) {\n  * The function returns NULL both on out of memory and if the remaining\n  * parameters length does not match the number of links or other items\n  * to load. */\n+#define HNSW_SER_WORSTLINK_MISSING UINT32_MAX\n hnswNode *hnsw_insert_serialized(HNSW *index, void *vector, uint64_t *params, uint32_t params_len, void *value)\n {\n     if (params_len \u003c 2) return NULL;\n@@ -2158,6 +2160,13 @@ hnswNode *hnsw_insert_serialized(HNSW *index, void *vector, uint64_t *params, ui\n         uint32_t num_links \u003d params[param_idx++];\n         uint32_t max_links \u003d params[param_idx++];\n \n+        /* Sanity check: links should be less than max links and\n+         * in general a reasonable amount. */\n+        if (num_links \u003e max_links || max_links \u003e HNSW_MAX_M*4) {\n+            hnsw_node_free(node);\n+            return NULL;\n+        }\n+\n         /* If max_links is larger than current allocation, reallocate.\n          * It could happen in select_neighbors() that we over-allocate the\n          * node under very unlikely to happen conditions. */\n@@ -2185,6 +2194,10 @@ hnswNode *hnsw_insert_serialized(HNSW *index, void *vector, uint64_t *params, ui\n          * fit more than 2^32 nodes in a 32 bit system. */\n         for (uint32_t j \u003d 0; j \u003c num_links; j++)\n             node-\u003elayers[i].links[j] \u003d (hnswNode*)params[param_idx++];\n+\n+        /* XXX: fix me, we need to store the worst link info in a\n+         * backward compatible way. */\n+        node-\u003elayers[i].worst_idx \u003d HNSW_SER_WORSTLINK_MISSING;\n     }\n \n     /* Get l2 and quantization range. */\n@@ -2221,13 +2234,28 @@ uint64_t hnsw_hash_node_id(uint64_t id) {\n     return id;\n }\n \n+/* Helper for duplicated link detection in hnsw_deserialize_index(). */\n+static int qsort_compare_pointers(const void *aptr, const void *bptr) {\n+    uintptr_t a \u003d *((uintptr_t*)aptr);\n+    uintptr_t b \u003d *((uintptr_t*)bptr);\n+    if (a \u003e b) return 1;\n+    if (a \u003c b) return -1;\n+    return 0;\n+}\n+\n /* Fix pointers of neighbors nodes: after loading the serialized nodes, the\n  * neighbors links are just IDs (casted to pointers), instead of the actual\n  * pointers. We need to resolve IDs into pointers.\n  *\n+ * The two integers salt0 and salt1 are used to make the internal state\n+ * of the function unguessable to an external attacker, in order to protect\n+ * from corruptions. Show be two random numbers from /dev/urandom if possible\n+ * otherwise can be just 0,0 if the application is not security critical and\n+ * never processes untrusted inputs.\n+ *\n  * Return 0 on error (out of memory or some ID that can\u0027t be resolved), 1 on\n  * success. */\n-int hnsw_deserialize_index(HNSW *index) {\n+int hnsw_deserialize_index(HNSW *index, uint64_t salt0, uint64_t salt1) {\n     /* We will use simple linear probing, so over-allocating is a good\n      * idea: anyway this flat array of pointers will consume a fraction\n      * of the memory of the loaded index. */\n@@ -2253,12 +2281,60 @@ int hnsw_deserialize_index(HNSW *index) {\n         node \u003d node-\u003enext;\n     }\n \n-    /* Second pass: fix pointers of all the neighbors links. */\n+    /* Second pass: fix pointers of all the neighbors links.\n+     * As we scan and fix the links, we also compute the accumulator\n+     * register \"reciprocal\", that is used in order to guarantee that all\n+     * the links are reciprocal.\n+     *\n+     * This is how it works, we hash (using a strong hash function) the\n+     * following key for each link that we see from A to B (or vice versa):\n+     *\n+     *      hash(salt || A || B || link-level)\n+     *\n+     * We always sort A and B, so the same link from A to B and from B to A\n+     * will hash the same. The we xor the result into the 128 bit accumulator.\n+     * If each link has its own backlink, the accumulator is guaranteed to\n+     * be zero at the end.\n+     *\n+     * Collisions are extremely unlikely to happen, and an external attacker\n+     * can\u0027t easily control the hash function output, since the salt is\n+     * unknown, and also there would be to control the pointers.\n+     *\n+     * This algorithm is O(1) for each node so it is basically free for\n+     * us, as we scan the list of nodes, and runs on constant and very\n+     * small memory. */\n+    uint64_t accumulator[2] \u003d {0,0};\n+\n     node \u003d index-\u003ehead; // Rewind.\n     while(node) {\n+        uint64_t this_node_id \u003d node-\u003eid;\n         for (uint32_t i \u003d 0; i \u003c\u003d node-\u003elevel; i++) {\n+            // Check if there are duplicated links: those are\n+            // also corruptions of the on-disk serialization format.\n+            if (node-\u003elayers[i].num_links \u003e 0) {\n+                qsort(node-\u003elayers[i].links, node-\u003elayers[i].num_links,\n+                        sizeof(void*), qsort_compare_pointers);\n+                for (uint32_t j \u003d 0; j \u003c node-\u003elayers[i].num_links-1; j++) {\n+                    if (node-\u003elayers[i].links[j] \u003d\u003d node-\u003elayers[i].links[j+1])\n+                        goto corrupted;\n+                }\n+            }\n+\n+            // Resolve pointers.\n             for (uint32_t j \u003d 0; j \u003c node-\u003elayers[i].num_links; j++) {\n                 uint64_t linked_id \u003d (uint64_t) node-\u003elayers[i].links[j];\n+\n+                // We can\u0027t link to our own node.\n+                if (linked_id \u003d\u003d this_node_id) goto corrupted;\n+\n+                // Compute accumulator for reciprocal links check.\n+                uint64_t mixed_h1, mixed_h2;\n+                secure_pair_mixer_128(salt0, salt1, this_node_id, linked_id, (uint64_t)i, \u0026mixed_h1, \u0026mixed_h2);\n+\n+                accumulator[0] ^\u003d mixed_h1;\n+                accumulator[1] ^\u003d mixed_h2;\n+\n+                // Fix links.\n                 uint64_t bucket \u003d hnsw_hash_node_id(linked_id) \u0026 (table_size-1);\n                 hnswNode *neighbor \u003d NULL;\n                 for (uint64_t k \u003d 0; k \u003c table_size; k++) {\n@@ -2268,19 +2344,37 @@ int hnsw_deserialize_index(HNSW *index) {\n                     }\n                     bucket \u003d (bucket+1) \u0026 (table_size-1);\n                 }\n-                if (neighbor \u003d\u003d NULL) {\n+\n+                /* The neighbor must exist and also exist at the right\n+                 * level. */\n+                if (neighbor \u003d\u003d NULL || neighbor-\u003elevel \u003c i) {\n                     /* Unresolved link! Either a bug in this code\n                      * or broken serialization data. */\n-                    hfree(table);\n-                    return 0;\n+                    goto corrupted;\n                 }\n                 node-\u003elayers[i].links[j] \u003d neighbor;\n             }\n+\n+            /* The worst link information was missing from older\n+             * serialization formats. Compute it on the fly if needed. */\n+            if (node-\u003elayers[i].worst_idx \u003d\u003d HNSW_SER_WORSTLINK_MISSING) {\n+                hnsw_update_worst_neighbor(index,node,i);\n+            }\n         }\n         node \u003d node-\u003enext;\n     }\n+\n+    /* Check that links are reciprocal, otherwise fail. */\n+    if (accumulator[0] || accumulator[1]) goto corrupted;\n+\n+    /* Everything fine. Return success. */\n     hfree(table);\n     return 1;\n+\n+corrupted:\n+    /* Some corruption error detected. */\n+    hfree(table);\n+    return 0;\n }\n \n /* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d Iterator \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\ndiff --git a/modules/vector-sets/hnsw.h b/modules/vector-sets/hnsw.h\nindex 2af35a2..8935521 100644\n--- a/modules/vector-sets/hnsw.h\n+++ b/modules/vector-sets/hnsw.h\n@@ -158,7 +158,7 @@ void hnsw_free_insert_context(InsertContext *ctx);\n hnswSerNode *hnsw_serialize_node(HNSW *index, hnswNode *node);\n void hnsw_free_serialized_node(hnswSerNode *sn);\n hnswNode *hnsw_insert_serialized(HNSW *index, void *vector, uint64_t *params, uint32_t params_len, void *value);\n-int hnsw_deserialize_index(HNSW *index);\n+int hnsw_deserialize_index(HNSW *index, uint64_t salt0, uint64_t salt1);\n \n // Helper function in case the user wants to directly copy\n // the vector bytes.\ndiff --git a/modules/vector-sets/mixer.h b/modules/vector-sets/mixer.h\nnew file mode 100644\nindex 0000000..d75e193\n--- /dev/null\n+++ b/modules/vector-sets/mixer.h\n@@ -0,0 +1,106 @@\n+/* Redis implementation for vector sets. The data structure itself\n+ * is implemented in hnsw.c.\n+ *\n+ * Copyright (c) 2009-Present, Redis Ltd.\n+ * All rights reserved.\n+ *\n+ * Licensed under your choice of (a) the Redis Source Available License 2.0\n+ * (RSALv2); or (b) the Server Side Public License v1 (SSPLv1); or (c) the\n+ * GNU Affero General Public License v3 (AGPLv3).\n+ * Originally authored by: Salvatore Sanfilippo.\n+ *\n+ * \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n+ *\n+ * Mixing function for HNSW link integrity verification\n+ * Designed to resist collision attacks when salts are unknown.\n+ */\n+\n+#include \u003cstdint.h\u003e\n+#include \u003cstring.h\u003e\n+\n+static inline uint64_t ROTL64(uint64_t x, int r) {\n+    return (x \u003c\u003c r) | (x \u003e\u003e (64 - r));\n+}\n+\n+// Use more rounds and stronger constants\n+#define MIX_PRIME_1 0xFF51AFD7ED558CCDULL\n+#define MIX_PRIME_2 0xC4CEB9FE1A85EC53ULL\n+#define MIX_PRIME_3 0x9E3779B97F4A7C15ULL\n+#define MIX_PRIME_4 0xBF58476D1CE4E5B9ULL\n+#define MIX_PRIME_5 0x94D049BB133111EBULL\n+#define MIX_PRIME_6 0x2B7E151628AED2A7ULL\n+\n+/* Mixer design goals:\n+ * 1. Thorough mixing of the level parameter.\n+ * 2. Enough rounds of mixing.\n+ * 3. Cross-influence between h1 and h2.\n+ * 4. Domain separation to prevent related-key attacks.\n+ */\n+void secure_pair_mixer_128(uint64_t salt0, uint64_t salt1,\n+                          uint64_t id1_in, uint64_t id2_in, uint64_t level,\n+                          uint64_t* out_h1, uint64_t* out_h2) {\n+    // Order independence (A -\u003e B links should hash as B -\u003e A links).\n+    uint64_t id_a \u003d (id1_in \u003c id2_in) ? id1_in : id2_in;\n+    uint64_t id_b \u003d (id1_in \u003c id2_in) ? id2_in : id1_in;\n+\n+    // Domain separation: mix salts with a constant to prevent\n+    // related-key attacks.\n+    uint64_t h1 \u003d salt0 ^ 0xDEADBEEFDEADBEEFULL;\n+    uint64_t h2 \u003d salt1 ^ 0xCAFEBABECAFEBABEULL;\n+\n+    // First, thoroughly mix the level into both accumulators\n+    // This prevents predictable level values from being a weakness\n+    uint64_t level_mix \u003d level;\n+    level_mix *\u003d MIX_PRIME_5;\n+    level_mix ^\u003d level_mix \u003e\u003e 32;\n+    level_mix *\u003d MIX_PRIME_6;\n+\n+    h1 ^\u003d level_mix;\n+    h2 ^\u003d ROTL64(level_mix, 31);\n+\n+    // Mix in id_a with strong diffusion.\n+    h1 ^\u003d id_a;\n+    h1 *\u003d MIX_PRIME_1;\n+    h1 \u003d ROTL64(h1, 23);\n+    h1 *\u003d MIX_PRIME_2;\n+\n+    // Mix in id_b.\n+    h2 ^\u003d id_b;\n+    h2 *\u003d MIX_PRIME_3;\n+    h2 \u003d ROTL64(h2, 29);\n+    h2 *\u003d MIX_PRIME_4;\n+\n+    // Three rounds of cross-mixing for better security.\n+    for (int i \u003d 0; i \u003c 3; i++) {\n+        // Cross-influence.\n+        uint64_t tmp \u003d h1;\n+        h1 +\u003d h2;\n+        h2 +\u003d tmp;\n+\n+        // Mix h1.\n+        h1 ^\u003d ROTL64(h1, 31);\n+        h1 *\u003d MIX_PRIME_1;\n+        h1 ^\u003d salt0;\n+\n+        // Mix h2.\n+        h2 ^\u003d ROTL64(h2, 37);\n+        h2 *\u003d MIX_PRIME_2;\n+        h2 ^\u003d salt1;\n+    }\n+\n+    // Finalization with avalanche rounds.\n+    h1 ^\u003d h1 \u003e\u003e 33;\n+    h1 *\u003d MIX_PRIME_3;\n+    h1 ^\u003d h1 \u003e\u003e 29;\n+    h1 *\u003d MIX_PRIME_4;\n+    h1 ^\u003d h1 \u003e\u003e 32;\n+\n+    h2 ^\u003d h2 \u003e\u003e 33;\n+    h2 *\u003d MIX_PRIME_5;\n+    h2 ^\u003d h2 \u003e\u003e 29;\n+    h2 *\u003d MIX_PRIME_6;\n+    h2 ^\u003d h2 \u003e\u003e 32;\n+\n+    *out_h1 \u003d h1;\n+    *out_h2 \u003d h2;\n+}\ndiff --git a/modules/vector-sets/vset.c b/modules/vector-sets/vset.c\nindex e0c7fc9..a61bcec 100644\n--- a/modules/vector-sets/vset.c\n+++ b/modules/vector-sets/vset.c\n@@ -1883,7 +1883,10 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n         RedisModule_Free(vector);\n         RedisModule_Free(params);\n     }\n-    if (!hnsw_deserialize_index(vset-\u003ehnsw)) goto ioerr;\n+\n+    uint64_t salt[2];\n+    RedisModule_GetRandomBytes((unsigned char*)salt,sizeof(salt));\n+    if (!hnsw_deserialize_index(vset-\u003ehnsw, salt[0], salt[1])) goto ioerr;\n \n     return vset;\n ","expectedMessage":"Vector Sets fixes against corrupted data in absence of checksum verification (#14102)","repository":"redis-antirez","commitHash":"27dd3b71ceb90f639b74253298ab1174e9b08613","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-0ac822e1","diff":" modules/vector-sets/README.md     |   8 +-\n modules/vector-sets/commands.json |   6 ++\n modules/vector-sets/test.py       |   2 +\n modules/vector-sets/tests/with.py | 214 ++++++++++++++++++++++++++++++++++++++\n modules/vector-sets/vset.c        |  70 +++++++++----\n 5 files changed, 279 insertions(+), 21 deletions(-)\n\ndiff --git a/modules/vector-sets/README.md b/modules/vector-sets/README.md\nindex b15cdaa..07180c1 100644\n--- a/modules/vector-sets/README.md\n+++ b/modules/vector-sets/README.md\n@@ -66,7 +66,7 @@ performed in the background, while the command is executed in the main thread.\n \n **VSIM: return elements by vector similarity**\n \n-    VSIM key [ELE|FP32|VALUES] \u003cvector or element\u003e [WITHSCORES] [COUNT num] [EF search-exploration-factor] [FILTER expression] [FILTER-EF max-filtering-effort] [TRUTH] [NOTHREAD]\n+    VSIM key [ELE|FP32|VALUES] \u003cvector or element\u003e [WITHSCORES] [WITHATTRIBS] [COUNT num] [EF search-exploration-factor] [FILTER expression] [FILTER-EF max-filtering-effort] [TRUTH] [NOTHREAD]\n \n The command returns similar vectors, for simplicity (and verbosity) in the following example, instead of providing a vector using FP32 or VALUES (like in `VADD`), we will ask for elements having a vector similar to a given element already in the sorted set:\n \n@@ -98,8 +98,14 @@ The `TRUTH` option forces the command to perform a linear scan of all the entrie\n \n The `NOTHREAD` option forces the command to execute the search on the data structure in the main thread. Normally `VSIM` spawns a thread instead. This may be useful for benchmarking purposes, or when we work with extremely small vector sets and don\u0027t want to pay the cost of spawning a thread. It is possible that in the future this option will be automatically used by Redis when we detect small vector sets. Note that this option blocks the server for all the time needed to complete the command, so it is a source of potential latency issues: if you are in doubt, never use it.\n \n+The `WITHSCORES` option returns, for each returned element, a floating point number representing how near the element is from the query, as a similarity between 0 and 1, where 0 means the vectors are opposite, and 1 means they are pointing exactly in the same direction (maximum similarity).\n+\n+The `WITHATTRIBS` option returns, for each element, the JSON attribute associated with the element, or NULL for the elements missing an attribute.\n+\n For `FILTER` and `FILTER-EF` options, please check the filtered search section of this documentation.\n \n+Note that when `WITHSCORES` and `WITHATTRIBS` are provided at the same time, the RESP2 reply guarantees that the returned elements are always in the sequence *ele*,*score*,*attribs*, while RESP3 replies will be in the form *ele \u003e score|attrib* when just one is provided, or *ele -\u003e [score,attrib]* when both are provided, that is, when both options are used and RESP3 is used the score and attribute will be a two-items array associated to the element key.\n+\n **VDIM: return the dimension of the vectors inside the vector set**\n \n     VDIM keyname\ndiff --git a/modules/vector-sets/commands.json b/modules/vector-sets/commands.json\nindex 0d7d6c3..36ed203 100644\n--- a/modules/vector-sets/commands.json\n+++ b/modules/vector-sets/commands.json\n@@ -291,6 +291,12 @@\n         \"name\": \"withscores\",\n         \"type\": \"pure-token\",\n         \"optional\": true\n+      },\n+      {\n+        \"token\": \"WITHATTRIBS\",\n+        \"name\": \"withattribs\",\n+        \"type\": \"pure-token\",\n+        \"optional\": true\n       }\n     ]\n   },\ndiff --git a/modules/vector-sets/test.py b/modules/vector-sets/test.py\nindex da5ce15..b8cbc32 100755\n--- a/modules/vector-sets/test.py\n+++ b/modules/vector-sets/test.py\n@@ -94,6 +94,7 @@ class TestCase:\n         self.test_key \u003d f\"test:{self.__class__.__name__.lower()}\"\n         # Primary Redis instance\n         self.redis \u003d redis.Redis(port\u003dprimary_port)\n+        self.redis3 \u003d redis.Redis(port\u003dprimary_port,protocol\u003d3)\n         # Replica Redis instance\n         self.replica \u003d redis.Redis(port\u003dreplica_port)\n         # Replication status\n@@ -184,6 +185,7 @@ def find_test_classes(primary_port, replica_port):\n                         # Create test instance with specified ports\n                         test_instance \u003d obj()\n                         test_instance.redis \u003d redis.Redis(port\u003dprimary_port)\n+                        test_instance.redis3 \u003d redis.Redis(port\u003dprimary_port,protocol\u003d3)\n                         test_instance.replica \u003d redis.Redis(port\u003dreplica_port)\n                         test_instance.primary_port \u003d primary_port\n                         test_instance.replica_port \u003d replica_port\ndiff --git a/modules/vector-sets/tests/with.py b/modules/vector-sets/tests/with.py\nnew file mode 100644\nindex 0000000..d14a23f\n--- /dev/null\n+++ b/modules/vector-sets/tests/with.py\n@@ -0,0 +1,214 @@\n+from test import TestCase, generate_random_vector\n+import struct\n+import json\n+import random\n+\n+class VSIMWithAttribs(TestCase):\n+    def getname(self):\n+        return \"VSIM WITHATTRIBS/WITHSCORES functionality testing\"\n+\n+    def setup(self):\n+        super().setup()\n+        self.dim \u003d 8\n+        self.count \u003d 20\n+\n+        # Create vectors with attributes\n+        for i in range(self.count):\n+            vec \u003d generate_random_vector(self.dim)\n+            vec_bytes \u003d struct.pack(f\u0027{self.dim}f\u0027, *vec)\n+\n+            # Item name\n+            name \u003d f\"{self.test_key}:item:{i}\"\n+\n+            # Add to Redis\n+            self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027FP32\u0027, vec_bytes, name)\n+\n+            # Create and add attribute\n+            if i % 5 \u003d\u003d 0:\n+                # Every 5th item has no attribute (for testing NULL responses)\n+                continue\n+\n+            category \u003d random.choice([\"electronics\", \"furniture\", \"clothing\"])\n+            price \u003d random.randint(50, 1000)\n+            attrs \u003d {\"category\": category, \"price\": price, \"id\": i}\n+\n+            self.redis.execute_command(\u0027VSETATTR\u0027, self.test_key, name, json.dumps(attrs))\n+\n+    def is_numeric(self, value):\n+        \"\"\"Check if a value can be converted to float\"\"\"\n+        try:\n+            if isinstance(value, (int, float)):\n+                return True\n+            if isinstance(value, bytes):\n+                float(value.decode(\u0027utf-8\u0027))\n+                return True\n+            if isinstance(value, str):\n+                float(value)\n+                return True\n+            return False\n+        except (ValueError, TypeError):\n+            return False\n+\n+    def test(self):\n+        # Create query vector\n+        query_vec \u003d generate_random_vector(self.dim)\n+\n+        # Test 1: VSIM with no additional options (should be same for RESP2 and RESP3)\n+        cmd_args \u003d [\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, self.dim]\n+        cmd_args.extend([str(x) for x in query_vec])\n+        cmd_args.extend([\u0027COUNT\u0027, 5])\n+\n+        results_resp2 \u003d self.redis.execute_command(*cmd_args)\n+        results_resp3 \u003d self.redis3.execute_command(*cmd_args)\n+\n+        # Both should return simple arrays of item names\n+        assert len(results_resp2) \u003d\u003d 5, f\"RESP2: Expected 5 results, got {len(results_resp2)}\"\n+        assert len(results_resp3) \u003d\u003d 5, f\"RESP3: Expected 5 results, got {len(results_resp3)}\"\n+        assert all(isinstance(item, bytes) for item in results_resp2), \"RESP2: Results should be byte strings\"\n+        assert all(isinstance(item, bytes) for item in results_resp3), \"RESP3: Results should be byte strings\"\n+\n+        # Test 2: VSIM with WITHSCORES only\n+        cmd_args \u003d [\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, self.dim]\n+        cmd_args.extend([str(x) for x in query_vec])\n+        cmd_args.extend([\u0027COUNT\u0027, 5, \u0027WITHSCORES\u0027])\n+\n+        results_resp2 \u003d self.redis.execute_command(*cmd_args)\n+        results_resp3 \u003d self.redis3.execute_command(*cmd_args)\n+\n+        # RESP2: Should be a flat array alternating item, score\n+        assert len(results_resp2) \u003d\u003d 10, f\"RESP2: Expected 10 elements (5 items  2), got {len(results_resp2)}\"\n+        for i in range(0, len(results_resp2), 2):\n+            assert isinstance(results_resp2[i], bytes), f\"RESP2: Item at {i} should be bytes\"\n+            assert self.is_numeric(results_resp2[i+1]), f\"RESP2: Score at {i+1} should be numeric\"\n+            score \u003d float(results_resp2[i+1]) if isinstance(results_resp2[i+1], bytes) else results_resp2[i+1]\n+            assert 0 \u003c\u003d score \u003c\u003d 1, f\"RESP2: Score {score} should be between 0 and 1\"\n+\n+        # RESP3: Should be a dict/map with items as keys and scores as DIRECT values (not arrays)\n+        assert isinstance(results_resp3, dict), f\"RESP3: Expected dict, got {type(results_resp3)}\"\n+        assert len(results_resp3) \u003d\u003d 5, f\"RESP3: Expected 5 entries, got {len(results_resp3)}\"\n+        for item, score in results_resp3.items():\n+            assert isinstance(item, bytes), f\"RESP3: Key should be bytes\"\n+            # Score should be a direct value, NOT an array\n+            assert not isinstance(score, list), f\"RESP3: With single WITH option, value should not be array\"\n+            assert self.is_numeric(score), f\"RESP3: Score should be numeric, got {type(score)}\"\n+            score_val \u003d float(score) if isinstance(score, bytes) else score\n+            assert 0 \u003c\u003d score_val \u003c\u003d 1, f\"RESP3: Score {score_val} should be between 0 and 1\"\n+\n+        # Test 3: VSIM with WITHATTRIBS only\n+        cmd_args \u003d [\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, self.dim]\n+        cmd_args.extend([str(x) for x in query_vec])\n+        cmd_args.extend([\u0027COUNT\u0027, 5, \u0027WITHATTRIBS\u0027])\n+\n+        results_resp2 \u003d self.redis.execute_command(*cmd_args)\n+        results_resp3 \u003d self.redis3.execute_command(*cmd_args)\n+\n+        # RESP2: Should be a flat array alternating item, attribute\n+        assert len(results_resp2) \u003d\u003d 10, f\"RESP2: Expected 10 elements (5 items  2), got {len(results_resp2)}\"\n+        for i in range(0, len(results_resp2), 2):\n+            assert isinstance(results_resp2[i], bytes), f\"RESP2: Item at {i} should be bytes\"\n+            attr \u003d results_resp2[i+1]\n+            assert attr is None or isinstance(attr, bytes), f\"RESP2: Attribute at {i+1} should be None or bytes\"\n+            if attr is not None:\n+                # Verify it\u0027s valid JSON\n+                json.loads(attr)\n+\n+        # RESP3: Should be a dict/map with items as keys and attributes as DIRECT values (not arrays)\n+        assert isinstance(results_resp3, dict), f\"RESP3: Expected dict, got {type(results_resp3)}\"\n+        assert len(results_resp3) \u003d\u003d 5, f\"RESP3: Expected 5 entries, got {len(results_resp3)}\"\n+        for item, attr in results_resp3.items():\n+            assert isinstance(item, bytes), f\"RESP3: Key should be bytes\"\n+            # Attribute should be a direct value, NOT an array\n+            assert not isinstance(attr, list), f\"RESP3: With single WITH option, value should not be array\"\n+            assert attr is None or isinstance(attr, bytes), f\"RESP3: Attribute should be None or bytes\"\n+            if attr is not None:\n+                # Verify it\u0027s valid JSON\n+                json.loads(attr)\n+\n+        # Test 4: VSIM with both WITHSCORES and WITHATTRIBS\n+        cmd_args \u003d [\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, self.dim]\n+        cmd_args.extend([str(x) for x in query_vec])\n+        cmd_args.extend([\u0027COUNT\u0027, 5, \u0027WITHSCORES\u0027, \u0027WITHATTRIBS\u0027])\n+\n+        results_resp2 \u003d self.redis.execute_command(*cmd_args)\n+        results_resp3 \u003d self.redis3.execute_command(*cmd_args)\n+\n+        # RESP2: Should be a flat array with pattern: item, score, attribute\n+        assert len(results_resp2) \u003d\u003d 15, f\"RESP2: Expected 15 elements (5 items  3), got {len(results_resp2)}\"\n+        for i in range(0, len(results_resp2), 3):\n+            assert isinstance(results_resp2[i], bytes), f\"RESP2: Item at {i} should be bytes\"\n+            assert self.is_numeric(results_resp2[i+1]), f\"RESP2: Score at {i+1} should be numeric\"\n+            score \u003d float(results_resp2[i+1]) if isinstance(results_resp2[i+1], bytes) else results_resp2[i+1]\n+            assert 0 \u003c\u003d score \u003c\u003d 1, f\"RESP2: Score {score} should be between 0 and 1\"\n+            attr \u003d results_resp2[i+2]\n+            assert attr is None or isinstance(attr, bytes), f\"RESP2: Attribute at {i+2} should be None or bytes\"\n+\n+        # RESP3: Should be a dict where each value is a 2-element array [score, attribute]\n+        assert isinstance(results_resp3, dict), f\"RESP3: Expected dict, got {type(results_resp3)}\"\n+        assert len(results_resp3) \u003d\u003d 5, f\"RESP3: Expected 5 entries, got {len(results_resp3)}\"\n+        for item, value in results_resp3.items():\n+            assert isinstance(item, bytes), f\"RESP3: Key should be bytes\"\n+            # With BOTH options, value MUST be an array\n+            assert isinstance(value, list), f\"RESP3: With both WITH options, value should be a list, got {type(value)}\"\n+            assert len(value) \u003d\u003d 2, f\"RESP3: Value should have 2 elements [score, attr], got {len(value)}\"\n+\n+            score, attr \u003d value\n+            assert self.is_numeric(score), f\"RESP3: Score should be numeric\"\n+            score_val \u003d float(score) if isinstance(score, bytes) else score\n+            assert 0 \u003c\u003d score_val \u003c\u003d 1, f\"RESP3: Score {score_val} should be between 0 and 1\"\n+            assert attr is None or isinstance(attr, bytes), f\"RESP3: Attribute should be None or bytes\"\n+\n+        # Test 5: Verify consistency - same items returned in same order\n+        cmd_args \u003d [\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, self.dim]\n+        cmd_args.extend([str(x) for x in query_vec])\n+        cmd_args.extend([\u0027COUNT\u0027, 5, \u0027WITHSCORES\u0027, \u0027WITHATTRIBS\u0027])\n+\n+        results_resp2 \u003d self.redis.execute_command(*cmd_args)\n+        results_resp3 \u003d self.redis3.execute_command(*cmd_args)\n+\n+        # Extract items from RESP2 (every 3rd element starting from 0)\n+        items_resp2 \u003d [results_resp2[i] for i in range(0, len(results_resp2), 3)]\n+\n+        # Extract items from RESP3 (keys of the dict)\n+        items_resp3 \u003d list(results_resp3.keys())\n+\n+        # Verify same items returned\n+        assert set(items_resp2) \u003d\u003d set(items_resp3), \"RESP2 and RESP3 should return the same items\"\n+\n+        # Build a mapping from items to scores and attributes for comparison\n+        data_resp2 \u003d {}\n+        for i in range(0, len(results_resp2), 3):\n+            item \u003d results_resp2[i]\n+            score \u003d float(results_resp2[i+1]) if isinstance(results_resp2[i+1], bytes) else results_resp2[i+1]\n+            attr \u003d results_resp2[i+2]\n+            data_resp2[item] \u003d (score, attr)\n+\n+        data_resp3 \u003d {}\n+        for item, value in results_resp3.items():\n+            score \u003d float(value[0]) if isinstance(value[0], bytes) else value[0]\n+            attr \u003d value[1]\n+            data_resp3[item] \u003d (score, attr)\n+\n+        # Verify scores and attributes match for each item\n+        for item in data_resp2:\n+            score_resp2, attr_resp2 \u003d data_resp2[item]\n+            score_resp3, attr_resp3 \u003d data_resp3[item]\n+\n+            assert abs(score_resp2 - score_resp3) \u003c 0.0001, \\\n+                f\"Scores for {item} don\u0027t match: RESP2\u003d{score_resp2}, RESP3\u003d{score_resp3}\"\n+            assert attr_resp2 \u003d\u003d attr_resp3, \\\n+                f\"Attributes for {item} don\u0027t match: RESP2\u003d{attr_resp2}, RESP3\u003d{attr_resp3}\"\n+\n+        # Test 6: Test ordering of WITHSCORES and WITHATTRIBS doesn\u0027t matter\n+        cmd_args1 \u003d [\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, self.dim]\n+        cmd_args1.extend([str(x) for x in query_vec])\n+        cmd_args1.extend([\u0027COUNT\u0027, 3, \u0027WITHSCORES\u0027, \u0027WITHATTRIBS\u0027])\n+\n+        cmd_args2 \u003d [\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, self.dim]\n+        cmd_args2.extend([str(x) for x in query_vec])\n+        cmd_args2.extend([\u0027COUNT\u0027, 3, \u0027WITHATTRIBS\u0027, \u0027WITHSCORES\u0027])  # Reversed order\n+\n+        results1_resp3 \u003d self.redis3.execute_command(*cmd_args1)\n+        results2_resp3 \u003d self.redis3.execute_command(*cmd_args2)\n+\n+        # Both should return the same structure\n+        assert results1_resp3 \u003d\u003d results2_resp3, \"Order of WITH options shouldn\u0027t matter\"\ndiff --git a/modules/vector-sets/vset.c b/modules/vector-sets/vset.c\nindex 33b6507..e0c7fc9 100644\n--- a/modules/vector-sets/vset.c\n+++ b/modules/vector-sets/vset.c\n@@ -801,8 +801,8 @@ int vectorSetFilterCallback(void *value, void *privdata) {\n  * handles the HNSW locking explicitly. */\n void VSIM_execute(RedisModuleCtx *ctx, struct vsetObject *vset,\n     float *vec, unsigned long count, float epsilon, unsigned long withscores,\n-    unsigned long ef, exprstate *filter_expr, unsigned long filter_ef,\n-    int ground_truth)\n+    unsigned long withattribs, unsigned long ef, exprstate *filter_expr,\n+    unsigned long filter_ef, int ground_truth)\n {\n     /* In our scan, we can\u0027t just collect \u0027count\u0027 elements as\n      * if count is small we would explore the graph in an insufficient\n@@ -837,28 +837,52 @@ void VSIM_execute(RedisModuleCtx *ctx, struct vsetObject *vset,\n     }\n \n     /* Return results */\n-    if (withscores)\n+    int resp3 \u003d RedisModule_GetContextFlags(ctx) \u0026 REDISMODULE_CTX_FLAGS_RESP3;\n+    int reply_with_map \u003d resp3 \u0026\u0026 (withscores || withattribs);\n+\n+    if (reply_with_map)\n         RedisModule_ReplyWithMap(ctx, REDISMODULE_POSTPONED_LEN);\n     else\n         RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_LEN);\n-    long long arraylen \u003d 0;\n \n+    long long arraylen \u003d 0;\n     for (unsigned int i \u003d 0; i \u003c found \u0026\u0026 i \u003c count; i++) {\n         if (distances[i] \u003e epsilon) break;\n         struct vsetNodeVal *nv \u003d neighbors[i]-\u003evalue;\n         RedisModule_ReplyWithString(ctx, nv-\u003eitem);\n         arraylen++;\n+\n+        /* If the user asked for multiple properties at the same time using\n+         * the RESP3 protocol, we wrap the value of the map into an N-items\n+         * array. Two for now, since we have just two properties that can be\n+         * requested.\n+         *\n+         * So in the case of RESP2 we will just have the flat reply:\n+         * item, score, attribute. For RESP3 instead item -\u003e [score, attribute]\n+         */\n+        if (resp3 \u0026\u0026 withscores \u0026\u0026 withattribs)\n+            RedisModule_ReplyWithArray(ctx,2);\n+\n         if (withscores) {\n             /* The similarity score is provided in a 0-1 range. */\n             RedisModule_ReplyWithDouble(ctx, 1.0 - distances[i]/2.0);\n         }\n+        if (withattribs) {\n+            /* Return the attributes as well, if any. */\n+            if (nv-\u003eattrib)\n+                RedisModule_ReplyWithString(ctx, nv-\u003eattrib);\n+            else\n+                RedisModule_ReplyWithNull(ctx);\n+        }\n     }\n     hnsw_release_read_slot(vset-\u003ehnsw,slot);\n \n-    if (withscores)\n+    if (reply_with_map) {\n         RedisModule_ReplySetMapLength(ctx, arraylen);\n-    else\n-        RedisModule_ReplySetArrayLength(ctx, arraylen);\n+    } else {\n+        int items_per_ele \u003d 1+withattribs+withscores;\n+        RedisModule_ReplySetArrayLength(ctx, arraylen * items_per_ele);\n+    }\n \n     RedisModule_Free(vec);\n     RedisModule_Free(neighbors);\n@@ -878,10 +902,11 @@ void *VSIM_thread(void *arg) {\n     unsigned long count \u003d (unsigned long)targ[3];\n     float epsilon \u003d *((float*)targ[4]);\n     unsigned long withscores \u003d (unsigned long)targ[5];\n-    unsigned long ef \u003d (unsigned long)targ[6];\n-    exprstate *filter_expr \u003d targ[7];\n-    unsigned long filter_ef \u003d (unsigned long)targ[8];\n-    unsigned long ground_truth \u003d (unsigned long)targ[9];\n+    unsigned long withattribs \u003d (unsigned long)targ[6];\n+    unsigned long ef \u003d (unsigned long)targ[7];\n+    exprstate *filter_expr \u003d targ[8];\n+    unsigned long filter_ef \u003d (unsigned long)targ[9];\n+    unsigned long ground_truth \u003d (unsigned long)targ[10];\n     RedisModule_Free(targ[4]);\n     RedisModule_Free(targ);\n \n@@ -894,7 +919,7 @@ void *VSIM_thread(void *arg) {\n     RedisModuleCtx *ctx \u003d RedisModule_GetThreadSafeContext(bc);\n \n     // Run the query.\n-    VSIM_execute(ctx, vset, vec, count, epsilon, withscores, ef, filter_expr, filter_ef, ground_truth);\n+    VSIM_execute(ctx, vset, vec, count, epsilon, withscores, withattribs, ef, filter_expr, filter_ef, ground_truth);\n     pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n \n     // Cleanup.\n@@ -904,7 +929,7 @@ void *VSIM_thread(void *arg) {\n     return NULL;\n }\n \n-/* VSIM key [ELE|FP32|VALUES] \u003cvector or ele\u003e [WITHSCORES] [COUNT num] [EPSILON eps] [EF exploration-factor] [FILTER expression] [FILTER-EF exploration-factor] */\n+/* VSIM key [ELE|FP32|VALUES] \u003cvector or ele\u003e [WITHSCORES] [WITHATTRIBS] [COUNT num] [EPSILON eps] [EF exploration-factor] [FILTER expression] [FILTER-EF exploration-factor] */\n int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     RedisModule_AutoMemory(ctx);\n \n@@ -914,6 +939,7 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n \n     /* Defaults */\n     int withscores \u003d 0;\n+    int withattribs \u003d 0;\n     long long count \u003d VSET_DEFAULT_COUNT;   /* New default value */\n     long long ef \u003d 0;       /* Exploration factor (see HNSW paper) */\n     double epsilon \u003d 2.0;   /* Max cosine distance */\n@@ -1017,6 +1043,9 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         if (!strcasecmp(opt, \"WITHSCORES\")) {\n             withscores \u003d 1;\n             j++;\n+        } else if (!strcasecmp(opt, \"WITHATTRIBS\")) {\n+            withattribs \u003d 1;\n+            j++;\n         } else if (!strcasecmp(opt, \"TRUTH\")) {\n             ground_truth \u003d 1;\n             j++;\n@@ -1097,7 +1126,7 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n          * free slot if all the HNSW_MAX_THREADS slots are used. */\n         RedisModuleBlockedClient *bc \u003d RedisModule_BlockClient(ctx,NULL,NULL,NULL,0);\n         pthread_t tid;\n-        void **targ \u003d RedisModule_Alloc(sizeof(void*)*10);\n+        void **targ \u003d RedisModule_Alloc(sizeof(void*)*11);\n         targ[0] \u003d bc;\n         targ[1] \u003d vset;\n         targ[2] \u003d vec;\n@@ -1105,10 +1134,11 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         targ[4] \u003d RedisModule_Alloc(sizeof(float));\n         *((float*)targ[4]) \u003d epsilon;\n         targ[5] \u003d (void*)(unsigned long)withscores;\n-        targ[6] \u003d (void*)(unsigned long)ef;\n-        targ[7] \u003d (void*)filter_expr;\n-        targ[8] \u003d (void*)(unsigned long)filter_ef;\n-        targ[9] \u003d (void*)(unsigned long)ground_truth;\n+        targ[6] \u003d (void*)(unsigned long)withattribs;\n+        targ[7] \u003d (void*)(unsigned long)ef;\n+        targ[8] \u003d (void*)filter_expr;\n+        targ[9] \u003d (void*)(unsigned long)filter_ef;\n+        targ[10] \u003d (void*)(unsigned long)ground_truth;\n         RedisModule_BlockedClientMeasureTimeStart(bc);\n         vset-\u003ethread_creation_pending++;\n         if (pthread_create(\u0026tid,NULL,VSIM_thread,targ) !\u003d 0) {\n@@ -1116,10 +1146,10 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n             RedisModule_AbortBlock(bc);\n             RedisModule_Free(targ[4]);\n             RedisModule_Free(targ);\n-            VSIM_execute(ctx, vset, vec, count, epsilon, withscores, ef, filter_expr, filter_ef, ground_truth);\n+            VSIM_execute(ctx, vset, vec, count, epsilon, withscores, withattribs, ef, filter_expr, filter_ef, ground_truth);\n         }\n     } else {\n-        VSIM_execute(ctx, vset, vec, count, epsilon, withscores, ef, filter_expr, filter_ef, ground_truth);\n+        VSIM_execute(ctx, vset, vec, count, epsilon, withscores, withattribs, ef, filter_expr, filter_ef, ground_truth);\n     }\n \n     return REDISMODULE_OK;","expectedMessage":"Implement WITHATTRIBS for VSIM. (#14065)","repository":"redis-antirez","commitHash":"0ac822e15415cfa116df4ea21ebacc2cbe42195c","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-22ebb06e","diff":" src/Makefile  |   2 +-\n src/lolwut.c  |   4 ++\n src/lolwut8.c | 177 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n 3 files changed, 182 insertions(+), 1 deletion(-)\n\ndiff --git a/src/Makefile b/src/Makefile\nindex 6cfac4a..4b86468 100644\n--- a/src/Makefile\n+++ b/src/Makefile\n@@ -375,7 +375,7 @@ endif\n \n REDIS_SERVER_NAME\u003dredis-server$(PROG_SUFFIX)\n REDIS_SENTINEL_NAME\u003dredis-sentinel$(PROG_SUFFIX)\n-REDIS_SERVER_OBJ\u003dthreads_mngr.o adlist.o quicklist.o ae.o anet.o dict.o ebuckets.o eventnotifier.o iothread.o mstr.o kvstore.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o cluster_legacy.o crc16.o endianconv.o slowlog.o eval.o bio.o rio.o rand.o memtest.o syscheck.o crcspeed.o crccombine.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o t_stream.o listpack.o localtime.o lolwut.o lolwut5.o lolwut6.o acl.o tracking.o socket.o tls.o sha256.o timeout.o setcpuaffinity.o monotonic.o mt19937-64.o resp_parser.o call_reply.o script_lua.o script.o functions.o function_lua.o commands.o strl.o connection.o unix.o logreqres.o\n+REDIS_SERVER_OBJ\u003dthreads_mngr.o adlist.o quicklist.o ae.o anet.o dict.o ebuckets.o eventnotifier.o iothread.o mstr.o kvstore.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o cluster_legacy.o crc16.o endianconv.o slowlog.o eval.o bio.o rio.o rand.o memtest.o syscheck.o crcspeed.o crccombine.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o t_stream.o listpack.o localtime.o lolwut.o lolwut5.o lolwut6.o lolwut8.o acl.o tracking.o socket.o tls.o sha256.o timeout.o setcpuaffinity.o monotonic.o mt19937-64.o resp_parser.o call_reply.o script_lua.o script.o functions.o function_lua.o commands.o strl.o connection.o unix.o logreqres.o\n REDIS_CLI_NAME\u003dredis-cli$(PROG_SUFFIX)\n REDIS_CLI_OBJ\u003danet.o adlist.o dict.o redis-cli.o zmalloc.o release.o ae.o redisassert.o crcspeed.o crccombine.o crc64.o siphash.o crc16.o monotonic.o cli_common.o mt19937-64.o strl.o cli_commands.o\n REDIS_BENCHMARK_NAME\u003dredis-benchmark$(PROG_SUFFIX)\ndiff --git a/src/lolwut.c b/src/lolwut.c\nindex 3017f7a..8467c78 100644\n--- a/src/lolwut.c\n+++ b/src/lolwut.c\n@@ -19,6 +19,7 @@\n \n void lolwut5Command(client *c);\n void lolwut6Command(client *c);\n+void lolwut8Command(client *c);\n \n /* The default target for LOLWUT if no matching version was found.\n  * This is what unstable versions of Redis will display. */\n@@ -54,6 +55,9 @@ void lolwutCommand(client *c) {\n     else if ((v[0] \u003d\u003d \u00276\u0027 \u0026\u0026 v[1] \u003d\u003d \u0027.\u0027 \u0026\u0026 v[2] !\u003d \u00279\u0027) ||\n              (v[0] \u003d\u003d \u00275\u0027 \u0026\u0026 v[1] \u003d\u003d \u0027.\u0027 \u0026\u0026 v[2] \u003d\u003d \u00279\u0027))\n         lolwut6Command(c);\n+    else if ((v[0] \u003d\u003d \u00278\u0027 \u0026\u0026 v[1] \u003d\u003d \u0027.\u0027 \u0026\u0026 v[2] !\u003d \u00279\u0027) ||\n+             (v[0] \u003d\u003d \u00277\u0027 \u0026\u0026 v[1] \u003d\u003d \u0027.\u0027 \u0026\u0026 v[2] \u003d\u003d \u00279\u0027))\n+        lolwut8Command(c);\n     else\n         lolwutUnstableCommand(c);\n \ndiff --git a/src/lolwut8.c b/src/lolwut8.c\nnew file mode 100644\nindex 0000000..1be150e\n--- /dev/null\n+++ b/src/lolwut8.c\n@@ -0,0 +1,177 @@\n+/*\n+ * Copyright (c) 2025-Present, Redis Ltd.\n+ * All rights reserved.\n+ *\n+ * Licensed under your choice of (a) the Redis Source Available License 2.0\n+ * (RSALv2); or (b) the Server Side Public License v1 (SSPLv1); or (c) the\n+ * GNU Affero General Public License v3 (AGPLv3).\n+ *\n+ * Originally authored by: Salvatore Sanfilippo.\n+ * Algorithm based on the Almanacco Bompiani description and the Python\n+ * code written by Emiliano Russo.\n+ */\n+\n+#include \"server.h\"\n+#include \u003cctype.h\u003e\n+\n+/* The LOLWUT 8 command:\n+ *\n+ * LOLWUT [EN|IT]\n+ *\n+ * By default the command produces verses in English language, in order for\n+ * the output to be more universally accessible. However, passing IT as argument\n+ * it is possible to reproduce the original output, exactly like done by\n+ * Nanni Balestrini in TAPE MARK I, and described in the Almanacco Letterario\n+ * Bompiani, 1962.\n+ */\n+\n+// Structure to represent a verse with its metrical characteristics.\n+typedef struct {\n+    char text_en[100];    // English verse text.\n+    char text_it[100];    // Italian verse text.\n+    char fraction1[5];    // First fraction (rhythm/meter indicator).\n+    char fraction2[5];    // Second fraction (rhythm/meter indicator).\n+    char group[2];        // Group number (1-3 representing different\n+                          // literary sources).\n+} Verse;\n+\n+// Fisher-Yates shuffle algorithm to randomize verse order.\n+static void shuffle(Verse *array, int size) {\n+    for (int i \u003d size - 1; i \u003e 0; i--) {\n+        int j \u003d rand() % (i + 1);\n+        Verse temp \u003d array[j];\n+        array[j] \u003d array[i];\n+        array[i] \u003d temp;\n+    }\n+}\n+\n+void lolwut8Command(client *c) {\n+    int en_lang \u003d 1;  // Default to English.\n+\n+    /* Parse the optional arguments if any. */\n+    if (c-\u003eargc \u003e 1 \u0026\u0026 !strcasecmp(c-\u003eargv[1]-\u003eptr,\"IT\"))\n+        en_lang \u003d 0;\n+\n+    // Define verses from three literary sources with their metrical fractions:\n+    // Group 1: Diary of Hiroshima by Michihito Hachiya.\n+    // Group 2: The Mystery of the Elevator by Paul Goldwin.\n+    // Group 3: Tao Te Ching by Lao Tse.\n+    Verse verses[] \u003d {\n+        // Group 1: Hiroshima verses.\n+        {\" The blinding / globe / of fire \",\n+         \" l accecante   /  globo  /  di fuoco  \", \"1/4\", \"2/3\", \"1\"},\n+        {\" It expands / rapidly \",\n+         \" si espande   /  rapidamente  \", \"1/2\", \"3/4\", \"1\"},\n+        {\" Thirty times / brighter / than the sun \",\n+         \" trenta volte  / piu luminoso  / del sole \", \"2/3\", \"2/4\", \"1\"},\n+        {\" When it reaches / the stratosphere \",\n+         \" quando  raggiunge / la stratosfera  \", \"3/4\", \"1/2\", \"1\"},\n+        {\" The summit / of the cloud \",\n+         \" la  sommita  /  della nuvola \", \"1/3\", \"2/3\", \"1\"},\n+        {\" Assumes / the well-known shape / of a mushroom \",\n+         \" assume   / la ben nota forma  / di fungo \", \"2/4\", \"3/4\", \"1\"},\n+\n+        // Group 2: Elevator mystery verses.\n+        {\" The head / pressed / upon the shoulder \",\n+         \" la testa / premuta  / sulla spalla  \", \"1/4\", \"2/4\", \"2\"},\n+        {\" The hair / between the lips \",\n+         \" i  capelli   /  tra le labbra \", \"1/4\", \"2/4\", \"2\"},\n+        {\" They lay / motionless / without speaking \",\n+         \" giacquero  /   immobili / senza parlare \", \"2/3\", \"2/3\", \"2\"},\n+        {\" Till he moved / his fingers / slowly \",\n+         \" finche non mosse  /  le dita  / lentamente    \", \"3/4\", \"1/3\", \"2\"},\n+        {\" Trying / to grasp \",\n+         \" cercando / di afferrare  \", \"3/4\", \"1/2\", \"2\"},\n+\n+        // Group 3: Tao Te Ching verses.\n+        {\" While the multitude / of things / comes into being \",\n+         \" mentre la moltitudine  /  delle cose  /   accade   \", \"1/2\", \"1/2\", \"3\"},\n+        {\" I envisage / their return \",\n+         \" io contemplo  /  il loro ritorno    \", \"2/3\", \"3/4\", \"3\"},\n+        {\" Although / things / flourish \",\n+         \" malgrado / che le cose  /  fioriscano    \", \"1/2\", \"2/3\", \"3\"},\n+        {\" They all return / to / their roots \",\n+         \" esse tornano  / tutte    / alla loro radice   \", \"2/3\", \"1/4\", \"3\"}\n+    };\n+\n+    // Calculate the total number of verses.\n+    int num_verses \u003d sizeof(verses) / sizeof(verses[0]);\n+\n+    // Create a working copy of verses for manipulation.\n+    Verse *working_verses \u003d zmalloc(num_verses * sizeof(Verse));\n+    memcpy(working_verses, verses, num_verses * sizeof(Verse));\n+\n+    // Step 1: Shuffle the verses randomly.\n+    shuffle(working_verses, num_verses);\n+\n+    // Step 2: Build stanza by finding compatible verses\n+    // Each subsequent verse must:\n+    // - Have compatible metrical fractions (connecting criteria).\n+    // - Belong to a different group than the previous verse.\n+    Verse stanza[10];\n+\n+    int j; // At the end, it will contain the number of added stanzas.\n+    for (j \u003d 0; j \u003c 10; j++) {\n+        int i \u003d 0;\n+        int found \u003d 0;\n+\n+        // Search for compatible verse among remaining verses.\n+        while (i \u003c num_verses) {\n+            // Metrical compatibility check: this is used to select verses\n+            // that go somewhat well together, if their fractions match.\n+            // The algorithm checks if current verse\u0027s first fraction matches\n+            // with previous verse\u0027s second fraction in various ways, and\n+            // force successive verses to be of different groups.\n+            if (j \u003d\u003d 0 || // First stanza is always accepted.\n+                ((working_verses[i].fraction1[0] \u003d\u003d stanza[j-1].fraction2[0] ||\n+                  working_verses[i].fraction1[2] \u003d\u003d stanza[j-1].fraction2[0] ||\n+                  working_verses[i].fraction1[2] \u003d\u003d stanza[j-1].fraction2[2]) \u0026\u0026\n+                 strcmp(working_verses[i].group, stanza[j-1].group) !\u003d 0))\n+            {\n+\n+                // Add compatible verse to stanza.\n+                stanza[j] \u003d working_verses[i];\n+\n+                // Remove selected verse from working set, to avoid reuse.\n+                for (int k \u003d i; k \u003c num_verses - 1; k++)\n+                    working_verses[k] \u003d working_verses[k + 1];\n+                num_verses--;\n+\n+                found \u003d 1;\n+                break;\n+            }\n+            i++;\n+        }\n+\n+        // Exit if there are no longer matching verses.\n+        if (!found) break;\n+    }\n+    zfree(working_verses);\n+\n+    // Step 3: Combine all stanza verses into single SDS string.\n+    sds combined \u003d sdsempty();\n+    for (int i \u003d 0; i \u003c j; i++) {\n+        if (en_lang) {\n+            combined \u003d sdscat(combined, stanza[i].text_en);\n+        } else {\n+            combined \u003d sdscat(combined, stanza[i].text_it);\n+        }\n+        combined \u003d sdscat(combined, \"\\n\");\n+    }\n+\n+    // Step 4: Make uppercase, and strip the \"/\".\n+    for (size_t j \u003d 0; j \u003c sdslen(combined); j++) {\n+        combined[j] \u003d toupper(combined[j]);\n+        if (combined[j] \u003d\u003d \u0027/\u0027) combined[j] \u003d \u0027 \u0027;\n+    }\n+\n+    // Step 5: Add background info about what the user just saw.\n+    combined \u003d sdscat(combined,\n+        \"\\nIn 1961, Nanni Balestrini created one of the first computer-generated poems, TAPE MARK I, using an IBM 7090 mainframe. Each execution combined verses from three literary sources following algorithmic rules based on metrical compatibility and group constraints. This LOLWUT command reproduces Balestrini\u0027s original algorithm, generating new stanzas through the same computational poetry process described in Almanacco Letterario Bompiani, 1962.\\n\\n\"\n+        \"https://en.wikipedia.org/wiki/Digital_poetry\\n\"\n+        \"https://www.youtube.com/watch?v\u003d8i7uFCK7G0o (English subs)\\n\\n\"\n+        \"Use: LOLWUT IT for the original Italian output.\\n\\n\");\n+\n+    addReplyVerbatim(c,combined,sdslen(combined),\"txt\");\n+    sdsfree(combined);\n+}","expectedMessage":"LOLWUT for Redis 8. (#14048)","repository":"redis-antirez","commitHash":"22ebb06eb3d76575434674c7913635fea5393774","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-871d4c40","diff":" tests/support/server.tcl | 5 -----\n 1 file changed, 5 deletions(-)\n\ndiff --git a/tests/support/server.tcl b/tests/support/server.tcl\nindex 6e7bfa1..a30acf0 100644\n--- a/tests/support/server.tcl\n+++ b/tests/support/server.tcl\n@@ -730,11 +730,6 @@ proc start_server {options {code undefined}} {\n         # fetch srv back from the server list, in case it was restarted by restart_server (new PID)\n         set srv [lindex $::servers end]\n \n-        # Don\u0027t do the leak check when no tests were run\n-        if {$num_tests \u003d\u003d $::num_tests} {\n-            dict set srv \"skipleaks\" 1\n-        }\n-\n         # pop the server object\n         set ::servers [lrange $::servers 0 end-1]\n ","expectedMessage":"Test: check always for memory leaks on MacOS. (#14060)","repository":"redis-antirez","commitHash":"871d4c4004bdf7383a6c172efdf9ea48188e0f76","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-65e164ca","diff":" modules/vector-sets/vset.c         | 18 +++++++++++++++---\n tests/integration/corrupt-dump.tcl | 11 +++++++++++\n 2 files changed, 26 insertions(+), 3 deletions(-)\n\ndiff --git a/modules/vector-sets/vset.c b/modules/vector-sets/vset.c\nindex e904ade..33b6507 100644\n--- a/modules/vector-sets/vset.c\n+++ b/modules/vector-sets/vset.c\n@@ -1746,6 +1746,12 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n     uint32_t quant_type \u003d hnsw_config \u0026 0xff;\n     uint32_t hnsw_m \u003d (hnsw_config \u003e\u003e 8) \u0026 0xffff;\n \n+    /* Check that the quantization type is correct. Otherwise\n+     * return ASAP signaling the error. */\n+    if (quant_type !\u003d HNSW_QUANT_NONE \u0026\u0026\n+        quant_type !\u003d HNSW_QUANT_Q8 \u0026\u0026\n+        quant_type !\u003d HNSW_QUANT_BIN) return NULL;\n+\n     if (hnsw_m \u003d\u003d 0) hnsw_m \u003d 16; // Default, useful for RDB files predating\n                                   // this configuration parameter: it was fixed\n                                   // to 16.\n@@ -1768,7 +1774,7 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n \n         // Load projection matrix as a binary blob\n         char *matrix_blob \u003d RedisModule_LoadStringBuffer(rdb, NULL);\n-        if (RedisModule_IsIOError(rdb)) goto ioerr;\n+        if (matrix_blob \u003d\u003d NULL) goto ioerr;\n         memcpy(vset-\u003eproj_matrix, matrix_blob, matrix_size);\n         RedisModule_Free(matrix_blob);\n     }\n@@ -1802,7 +1808,10 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n         if (vector_len !\u003d vector_bytes) {\n             RedisModule_LogIOError(rdb,\"warning\",\n                                        \"Mismatching vector dimension\");\n-            return NULL; // Loading error.\n+            RedisModule_FreeString(NULL,ele);\n+            if (attrib) RedisModule_FreeString(NULL,attrib);\n+            RedisModule_Free(vector);\n+            goto ioerr;\n         }\n \n         // Load node parameters back.\n@@ -1834,7 +1843,10 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n         if (node \u003d\u003d NULL) {\n             RedisModule_LogIOError(rdb,\"warning\",\n                                        \"Vector set node index loading error\");\n-            return NULL; // Loading error: likely a corruption.\n+            vectorSetReleaseNodeValue(nv);\n+            RedisModule_Free(vector);\n+            RedisModule_Free(params);\n+            goto ioerr;\n         }\n         if (nv-\u003eattrib) vset-\u003enumattribs++;\n         RedisModule_DictSet(vset-\u003edict,ele,node);\ndiff --git a/tests/integration/corrupt-dump.tcl b/tests/integration/corrupt-dump.tcl\nindex 7b8d399..ee044c7 100644\n--- a/tests/integration/corrupt-dump.tcl\n+++ b/tests/integration/corrupt-dump.tcl\n@@ -931,5 +931,16 @@ test {corrupt payload: hash listpack encoded with invalid length causes hscan to\n     }\n }\n \n+test {corrupt payload: fuzzer findings - vector sets with wrong encoding} {\n+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {\n+        r config set sanitize-dump-payload yes\n+        r debug set-skip-checksum-validation 1\n+        catch {r restore _key 0 \"\\x07\\x81\\xBD\\xE7\\x2D\\xA2\\xBB\\x1E\\xB4\\x00\\x02\\x03\\x02\\x03\\x02\\x50\\x8F\\x02\\x00\\x05\\xC0\\x02\\x05\\x03\\x7F\\x7F\\x7F\\x02\\x07\\x02\\x03\\x02\\x00\\x02\\x02\\x02\\x20\\x02\\x01\\x02\\x02\\x02\\x81\\x3F\\x13\\xCD\\x3A\\x3F\\xDD\\xB3\\xD7\\x05\\xC0\\x01\\x05\\x03\\x7F\\x7F\\x7F\\x02\\x0B\\x02\\x02\\x02\\x02\\x02\\x02\\x02\\x20\\x02\\x01\\x02\\x03\\x02\\x06\\x02\\x10\\x02\\x00\\x02\\x10\\x02\\x81\\x3F\\x13\\xCD\\x3A\\x3F\\xDD\\xB3\\xD7\\x05\\xC0\\x00\\x05\\x03\\x7F\\x7F\\x7F\\x02\\x07\\x02\\x01\\x02\\x00\\x02\\x02\\x02\\x20\\x02\\x02\\x02\\x03\\x02\\x81\\x3F\\x13\\xCD\\x3A\\x3F\\xDD\\xB3\\xD7\\x00\\x0C\\x00\\xC6\\xA3\\x70\\x40\\x02\\x26\\xE8\\x9B\"} err\n+        assert_match \"*Bad data format*\" $err\n+        r ping\n+    }\n+}\n+\n+\n } ;# tags\n ","expectedMessage":"[Vector sets] More rdb loading fixes (#14032)","repository":"redis-antirez","commitHash":"65e164caffa507dc1723c577206eda2009e2b07b","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-a46624e1","diff":" modules/vector-sets/vset.c                | 53 ++++++++++++++++++++++++-------\n tests/integration/corrupt-dump-fuzzer.tcl |  9 +++++-\n tests/integration/replication.tcl         |  7 ++++\n tests/support/util.tcl                    | 24 +++++++++++++-\n 4 files changed, 80 insertions(+), 13 deletions(-)\n\ndiff --git a/modules/vector-sets/vset.c b/modules/vector-sets/vset.c\nindex 88e54a6..e904ade 100644\n--- a/modules/vector-sets/vset.c\n+++ b/modules/vector-sets/vset.c\n@@ -1734,15 +1734,15 @@ void VectorSetRdbSave(RedisModuleIO *rdb, void *value) {\n     }\n }\n \n-/* Load object from RDB. Please note that we don\u0027t do any cleanup\n- * on errors, and just return NULL, as Redis will abort completely\n- * not just the module but the server itself in this case. */\n+/* Load object from RDB. Recover from recoverable errors (read errors)\n+ * by performing cleanup. */\n void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n     if (encver !\u003d 0) return NULL;  // Invalid version\n \n     uint32_t dim \u003d RedisModule_LoadUnsigned(rdb);\n     uint64_t elements \u003d RedisModule_LoadUnsigned(rdb);\n     uint32_t hnsw_config \u003d RedisModule_LoadUnsigned(rdb);\n+    if (RedisModule_IsIOError(rdb)) return NULL;\n     uint32_t quant_type \u003d hnsw_config \u0026 0xff;\n     uint32_t hnsw_m \u003d (hnsw_config \u003e\u003e 8) \u0026 0xffff;\n \n@@ -1754,22 +1754,21 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n \n     /* Load projection matrix if present */\n     uint32_t save_flags \u003d RedisModule_LoadUnsigned(rdb);\n+    if (RedisModule_IsIOError(rdb)) goto ioerr;\n     int has_projection \u003d save_flags \u0026 SAVE_FLAG_HAS_PROJMATRIX;\n     int has_attribs \u003d save_flags \u0026 SAVE_FLAG_HAS_ATTRIBS;\n     if (has_projection) {\n         uint32_t input_dim \u003d RedisModule_LoadUnsigned(rdb);\n+        if (RedisModule_IsIOError(rdb)) goto ioerr;\n         uint32_t output_dim \u003d dim;\n         size_t matrix_size \u003d sizeof(float) * input_dim * output_dim;\n \n         vset-\u003eproj_matrix \u003d RedisModule_Alloc(matrix_size);\n-        if (!vset-\u003eproj_matrix) {\n-            vectorSetReleaseObject(vset);\n-            return NULL;\n-        }\n         vset-\u003eproj_input_size \u003d input_dim;\n \n         // Load projection matrix as a binary blob\n         char *matrix_blob \u003d RedisModule_LoadStringBuffer(rdb, NULL);\n+        if (RedisModule_IsIOError(rdb)) goto ioerr;\n         memcpy(vset-\u003eproj_matrix, matrix_blob, matrix_size);\n         RedisModule_Free(matrix_blob);\n     }\n@@ -1777,9 +1776,14 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n     while(elements--) {\n         // Load associated string element.\n         RedisModuleString *ele \u003d RedisModule_LoadString(rdb);\n+        if (RedisModule_IsIOError(rdb)) goto ioerr;\n         RedisModuleString *attrib \u003d NULL;\n         if (has_attribs) {\n             attrib \u003d RedisModule_LoadString(rdb);\n+            if (RedisModule_IsIOError(rdb)) {\n+                RedisModule_FreeString(NULL,ele);\n+                goto ioerr;\n+            }\n             size_t attrlen;\n             RedisModule_StringPtrLen(attrib,\u0026attrlen);\n             if (attrlen \u003d\u003d 0) {\n@@ -1789,6 +1793,11 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n         }\n         size_t vector_len;\n         void *vector \u003d RedisModule_LoadStringBuffer(rdb, \u0026vector_len);\n+        if (RedisModule_IsIOError(rdb)) {\n+            RedisModule_FreeString(NULL,ele);\n+            if (attrib) RedisModule_FreeString(NULL,attrib);\n+            goto ioerr;\n+        }\n         uint32_t vector_bytes \u003d hnsw_quants_bytes(vset-\u003ehnsw);\n         if (vector_len !\u003d vector_bytes) {\n             RedisModule_LogIOError(rdb,\"warning\",\n@@ -1798,9 +1807,25 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n \n         // Load node parameters back.\n         uint32_t params_count \u003d RedisModule_LoadUnsigned(rdb);\n+        if (RedisModule_IsIOError(rdb)) {\n+            RedisModule_FreeString(NULL,ele);\n+            if (attrib) RedisModule_FreeString(NULL,attrib);\n+            RedisModule_Free(vector);\n+            goto ioerr;\n+        }\n+\n         uint64_t *params \u003d RedisModule_Alloc(params_count*sizeof(uint64_t));\n-        for (uint32_t j \u003d 0; j \u003c params_count; j++)\n+        for (uint32_t j \u003d 0; j \u003c params_count; j++) {\n+            // Ignore loading errors here: handled at the end of the loop.\n             params[j] \u003d RedisModule_LoadUnsigned(rdb);\n+        }\n+        if (RedisModule_IsIOError(rdb)) {\n+            RedisModule_FreeString(NULL,ele);\n+            if (attrib) RedisModule_FreeString(NULL,attrib);\n+            RedisModule_Free(vector);\n+            RedisModule_Free(params);\n+            goto ioerr;\n+        }\n \n         struct vsetNodeVal *nv \u003d RedisModule_Alloc(sizeof(*nv));\n         nv-\u003eitem \u003d ele;\n@@ -1809,15 +1834,22 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n         if (node \u003d\u003d NULL) {\n             RedisModule_LogIOError(rdb,\"warning\",\n                                        \"Vector set node index loading error\");\n-            return NULL; // Loading error.\n+            return NULL; // Loading error: likely a corruption.\n         }\n         if (nv-\u003eattrib) vset-\u003enumattribs++;\n         RedisModule_DictSet(vset-\u003edict,ele,node);\n         RedisModule_Free(vector);\n         RedisModule_Free(params);\n     }\n-    hnsw_deserialize_index(vset-\u003ehnsw);\n+    if (!hnsw_deserialize_index(vset-\u003ehnsw)) goto ioerr;\n+\n     return vset;\n+\n+ioerr:\n+    /* We want to recover from I/O errors and free the partially allocated\n+     * data structure to support diskless replication. */\n+    vectorSetReleaseObject(vset);\n+    return NULL;\n }\n \n /* Calculate memory usage */\n@@ -1944,7 +1976,6 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n     if (RedisModule_Init(ctx,\"vectorset\",1,REDISMODULE_APIVER_1)\n         \u003d\u003d REDISMODULE_ERR) return REDISMODULE_ERR;\n \n-    /* TODO: Added to pass CI, need to make changes in order to support these options */\n     RedisModule_SetModuleOptions(ctx, REDISMODULE_OPTIONS_HANDLE_IO_ERRORS|REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD);\n \n     RedisModuleTypeMethods tm \u003d {\ndiff --git a/tests/integration/corrupt-dump-fuzzer.tcl b/tests/integration/corrupt-dump-fuzzer.tcl\nindex ed6a15b..5c7c992 100644\n--- a/tests/integration/corrupt-dump-fuzzer.tcl\n+++ b/tests/integration/corrupt-dump-fuzzer.tcl\n@@ -15,6 +15,10 @@ if { ! [ catch {\n \n proc generate_collections {suffix elements} {\n     set rd [redis_deferring_client]\n+    set numcmd 7\n+    set has_vsets [server_has_command vadd]\n+    if {$has_vsets} {incr numcmd}\n+\n     for {set j 0} {$j \u003c $elements} {incr j} {\n         # add both string values and integers\n         if {$j % 2 \u003d\u003d 0} {set val $j} else {set val \"_$j\"}\n@@ -25,8 +29,11 @@ proc generate_collections {suffix elements} {\n         $rd zadd zset$suffix $j $val\n         $rd sadd set$suffix $val\n         $rd xadd stream$suffix * item 1 value $val\n+        if {$has_vsets} {\n+            $rd vadd vset$suffix VALUES 3 1 1 1 $j\n+        }\n     }\n-    for {set j 0} {$j \u003c $elements * 7} {incr j} {\n+    for {set j 0} {$j \u003c $elements * $numcmd} {incr j} {\n         $rd read ; # Discard replies\n     }\n     $rd close\ndiff --git a/tests/integration/replication.tcl b/tests/integration/replication.tcl\nindex da7983c..10e7a1f 100644\n--- a/tests/integration/replication.tcl\n+++ b/tests/integration/replication.tcl\n@@ -756,6 +756,8 @@ test {diskless loading short read} {\n                 redis.register_function(\u0027test\u0027, function() return \u0027hello1\u0027 end)\n             }\n \n+            set has_vector_sets [server_has_command vadd]\n+\n             for {set k 0} {$k \u003c 3} {incr k} {\n                 for {set i 0} {$i \u003c 10} {incr i} {\n                     r set \"$k int_$i\" [expr {int(rand()*10000)}]\n@@ -769,6 +771,11 @@ test {diskless loading short read} {\n                     r zadd \"$k zset_large\" [expr {rand()}] [string repeat A [expr {int(rand()*1000000)}]]\n                     r lpush \"$k list_small\" [string repeat A [expr {int(rand()*10)}]]\n                     r lpush \"$k list_large\" [string repeat A [expr {int(rand()*1000000)}]]\n+\n+                    if {$has_vector_sets} {\n+                        r vadd \"$k vector_set\" VALUES 3 [expr {rand()}] [expr {rand()}] [expr {rand()}] [string repeat A [expr {int(rand()*1000)}]]\n+                    }\n+\n                     for {set j 0} {$j \u003c 10} {incr j} {\n                         r xadd \"$k stream\" * foo \"asdf\" bar \"1234\"\n                     }\ndiff --git a/tests/support/util.tcl b/tests/support/util.tcl\nindex 3e4b0a8..0d7d885 100644\n--- a/tests/support/util.tcl\n+++ b/tests/support/util.tcl\n@@ -738,7 +738,8 @@ proc generate_fuzzy_traffic_on_key {key type duration} {\n     set list_commands {LINDEX LINSERT LLEN LPOP LPOS LPUSH LPUSHX LRANGE LREM LSET LTRIM RPOP RPOPLPUSH RPUSH RPUSHX}\n     set set_commands {SADD SCARD SDIFF SDIFFSTORE SINTER SINTERSTORE SISMEMBER SMEMBERS SMOVE SPOP SRANDMEMBER SREM SSCAN SUNION SUNIONSTORE}\n     set stream_commands {XACK XADD XCLAIM XDEL XGROUP XINFO XLEN XPENDING XRANGE XREAD XREADGROUP XREVRANGE XTRIM}\n-    set commands [dict create string $string_commands hash $hash_commands zset $zset_commands list $list_commands set $set_commands stream $stream_commands]\n+    set vset_commands {VADD VREM}\n+    set commands [dict create string $string_commands hash $hash_commands zset $zset_commands list $list_commands set $set_commands stream $stream_commands vectorset $vset_commands]\n \n     set cmds [dict get $commands $type]\n     set start_time [clock seconds]\n@@ -788,6 +789,18 @@ proc generate_fuzzy_traffic_on_key {key type duration} {\n             lappend cmd [randomValue]\n             incr i 4\n         }\n+        if {$cmd \u003d\u003d \"VADD\"} {\n+            lappend cmd $key\n+            lappend cmd VALUES 3 1 1 1\n+            lappend cmd [randomValue]\n+            incr i 7\n+        }\n+        if {$cmd \u003d\u003d \"VREM\"} {\n+            lappend cmd $key\n+            lappend cmd [randomValue]\n+            incr i 2\n+        }\n+\n         for {} {$i \u003c $arity} {incr i} {\n             if {$i \u003d\u003d $firstkey || $i \u003d\u003d $lastkey} {\n                 lappend cmd $key\n@@ -1144,6 +1157,15 @@ proc memory_usage {key} {\n     return $usage\n }\n \n+# Test if the server supports the specified command.\n+proc server_has_command {cmd_wanted} {\n+    set lowercase_commands {}\n+    foreach cmd [r command list] {\n+        lappend lowercase_commands [string tolower $cmd]\n+    }\n+    expr {[lsearch $lowercase_commands [string tolower $cmd_wanted]] !\u003d -1}\n+}\n+\n # forward compatibility, lmap missing in TCL 8.5\n proc lmap args {\n     set body [lindex $args end]","expectedMessage":"[Vector sets] RDB IO errors handling (#13978)","repository":"redis-antirez","commitHash":"a46624e10e5b866d4154fb9bcc3fc7b45dd1aef8","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-41ecf732","diff":" modules/vector-sets/README.md          | 10 ++++\n modules/vector-sets/test.py            | 89 ++++++++++++++++++++++++++--------\n modules/vector-sets/tests/vismember.py | 47 ++++++++++++++++++\n modules/vector-sets/vset.c             | 40 ++++++++++++++-\n utils/req-res-log-validator.py         |  1 +\n 5 files changed, 167 insertions(+), 20 deletions(-)\n\ndiff --git a/modules/vector-sets/README.md b/modules/vector-sets/README.md\nindex 83febe4..b15cdaa 100644\n--- a/modules/vector-sets/README.md\n+++ b/modules/vector-sets/README.md\n@@ -11,6 +11,8 @@ Moreover, Vector sets implement optional filtered search capabilities: it is pos\n \n ## Installation\n \n+**WARNING:** If you are running **Redis 8.0 RC1 or greater** you don\u0027t need to install anything, just compile Redis, and the Vector Sets commands will be part of the default install. Otherwise to test Vector Sets with older Redis versions follow the following instructions.\n+\n Build with:\n \n     make\n@@ -171,6 +173,14 @@ For q8 quantization, an additional elements is also returned: the quantization\n range, so the integers from -127 to 127 represent (normalized) components\n in the range `-range`, `+range`.\n \n+**VISMEMBER: test if a given element already exists**\n+\n+This command will return 1 (or true) if the specified element is already in the vector set, otherwise 0 (or false) is returned.\n+\n+    VISMEMBER key element\n+\n+As with other existence check Redis commands, if the key does not exist it is considered as if it was empty, thus the element is reported as non existing.\n+\n **VLINKS: introspection command that shows neighbors for a node**\n \n     VLINKS key element [WITHSCORES]\ndiff --git a/modules/vector-sets/test.py b/modules/vector-sets/test.py\nindex 7d9f0c1..1cc7da2 100755\n--- a/modules/vector-sets/test.py\n+++ b/modules/vector-sets/test.py\n@@ -10,7 +10,6 @@\n # (RSALv2) or the Server Side Public License v1 (SSPLv1).\n #\n \n-#!/usr/bin/env python3\n import redis\n import random\n import struct\n@@ -20,13 +19,15 @@ import sys\n import os\n import importlib\n import inspect\n+import argparse\n from typing import List, Tuple, Optional\n from dataclasses import dataclass\n \n def colored(text: str, color: str) -\u003e str:\n     colors \u003d {\n         \u0027red\u0027: \u0027\\033[91m\u0027,\n-        \u0027green\u0027: \u0027\\033[92m\u0027\n+        \u0027green\u0027: \u0027\\033[92m\u0027,\n+        \u0027yellow\u0027: \u0027\\033[93m\u0027\n     }\n     reset \u003d \u0027\\033[0m\u0027\n     return f\"{colors.get(color, \u0027\u0027)}{text}{reset}\"\n@@ -63,7 +64,7 @@ def generate_random_vector(dim: int) -\u003e List[float]:\n     norm \u003d math.sqrt(sum(x*x for x in vec))\n     return [x/norm for x in vec]\n \n-def fill_redis_with_vectors(r: redis.Redis, key: str, count: int, dim: int, \n+def fill_redis_with_vectors(r: redis.Redis, key: str, count: int, dim: int,\n                           with_reduce: Optional[int] \u003d None) -\u003e VectorData:\n     \"\"\"Fill Redis with random vectors and return a VectorData object for verification.\"\"\"\n     vectors \u003d []\n@@ -86,16 +87,19 @@ def fill_redis_with_vectors(r: redis.Redis, key: str, count: int, dim: int,\n     return VectorData(vectors\u003dvectors, names\u003dnames)\n \n class TestCase:\n-    def __init__(self):\n+    def __init__(self, primary_port\u003d6379, replica_port\u003d6380):\n         self.error_msg \u003d None\n         self.error_details \u003d None\n         self.test_key \u003d f\"test:{self.__class__.__name__.lower()}\"\n-        # Primary Redis instance (default port)\n-        self.redis \u003d redis.Redis()\n-        # Replica Redis instance (port 6380)\n-        self.replica \u003d redis.Redis(port\u003d6380)\n+        # Primary Redis instance\n+        self.redis \u003d redis.Redis(port\u003dprimary_port)\n+        # Replica Redis instance\n+        self.replica \u003d redis.Redis(port\u003dreplica_port)\n         # Replication status\n         self.replication_setup \u003d False\n+        # Ports\n+        self.primary_port \u003d primary_port\n+        self.replica_port \u003d replica_port\n \n     def setup(self):\n         self.redis.delete(self.test_key)\n@@ -109,7 +113,7 @@ class TestCase:\n         Returns True if replication is successfully established, False otherwise.\n         \"\"\"\n         # Configure replica to replicate from primary\n-        self.replica.execute_command(\u0027REPLICAOF\u0027, \u0027127.0.0.1\u0027, 6379)\n+        self.replica.execute_command(\u0027REPLICAOF\u0027, \u0027127.0.0.1\u0027, self.primary_port)\n \n         # Wait for replication to be established\n         max_attempts \u003d 10\n@@ -120,7 +124,7 @@ class TestCase:\n             # Check if replication is established\n             if (repl_info.get(\u0027role\u0027) \u003d\u003d \u0027slave\u0027 and\n                 repl_info.get(\u0027master_host\u0027) \u003d\u003d \u0027127.0.0.1\u0027 and\n-                repl_info.get(\u0027master_port\u0027) \u003d\u003d 6379 and\n+                repl_info.get(\u0027master_port\u0027) \u003d\u003d self.primary_port and\n                 repl_info.get(\u0027master_link_status\u0027) \u003d\u003d \u0027up\u0027):\n \n                 self.replication_setup \u003d True\n@@ -162,7 +166,7 @@ class TestCase:\n         \"\"\"\"Each test class should override this if it takes a significant amount of time to run. Default is 100ms\"\"\"\n         return 0.1\n \n-def find_test_classes():\n+def find_test_classes(primary_port, replica_port):\n     test_classes \u003d []\n     tests_dir \u003d \u0027tests\u0027\n \n@@ -176,20 +180,67 @@ def find_test_classes():\n                 module \u003d importlib.import_module(module_name)\n                 for name, obj in inspect.getmembers(module):\n                     if inspect.isclass(obj) and obj.__name__ !\u003d \u0027TestCase\u0027 and hasattr(obj, \u0027test\u0027):\n-                        test_classes.append(obj())\n+                        # Create test instance with specified ports\n+                        test_instance \u003d obj()\n+                        test_instance.redis \u003d redis.Redis(port\u003dprimary_port)\n+                        test_instance.replica \u003d redis.Redis(port\u003dreplica_port)\n+                        test_instance.primary_port \u003d primary_port\n+                        test_instance.replica_port \u003d replica_port\n+                        test_classes.append(test_instance)\n             except Exception as e:\n                 print(f\"Error loading {file}: {e}\")\n \n     return test_classes\n \n-def run_tests():\n-    print(\"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\"+\n-          \"Make sure to have Redis running in the localhost\\n\"+\n-          \"with --enable-debug-command yes\\n\"+\n-          \"Both primary (6379) and replica (6380) instances\\n\"+\n-          \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\")\n+def check_redis_empty(r, instance_name):\n+    \"\"\"Check if Redis instance is empty\"\"\"\n+    try:\n+        dbsize \u003d r.dbsize()\n+        if dbsize \u003e 0:\n+            print(colored(f\"ERROR: {instance_name} Redis instance is not empty (dbsize: {dbsize}).\", \"red\"))\n+            print(colored(\"Make sure you\u0027re not using a production instance and that all data is safe to delete.\", \"red\"))\n+            sys.exit(1)\n+    except redis.exceptions.ConnectionError:\n+        print(colored(f\"ERROR: Cannot connect to {instance_name} Redis instance.\", \"red\"))\n+        sys.exit(1)\n+\n+def check_replica_running(replica_port):\n+    \"\"\"Check if replica Redis instance is running\"\"\"\n+    r \u003d redis.Redis(port\u003dreplica_port)\n+    try:\n+        r.ping()\n+        return True\n+    except redis.exceptions.ConnectionError:\n+        print(colored(f\"WARNING: Replica Redis instance (port {replica_port}) is not running.\", \"yellow\"))\n+        print(colored(\"Replication tests will fail. Make sure to start the replica instance.\", \"yellow\"))\n+        return False\n \n-    tests \u003d find_test_classes()\n+def run_tests():\n+    # Parse command line arguments\n+    parser \u003d argparse.ArgumentParser(description\u003d\u0027Run Redis vector tests.\u0027)\n+    parser.add_argument(\u0027--primary-port\u0027, type\u003dint, default\u003d6379, help\u003d\u0027Primary Redis instance port (default: 6379)\u0027)\n+    parser.add_argument(\u0027--replica-port\u0027, type\u003dint, default\u003d6380, help\u003d\u0027Replica Redis instance port (default: 6380)\u0027)\n+    args \u003d parser.parse_args()\n+\n+    print(\"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\")\n+    print(f\"Make sure to have Redis running on localhost\")\n+    print(f\"Primary port: {args.primary_port}\")\n+    print(f\"Replica port: {args.replica_port}\")\n+    print(\"with --enable-debug-command yes\")\n+    print(\"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\")\n+\n+    # Check if Redis instances are empty\n+    primary \u003d redis.Redis(port\u003dargs.primary_port)\n+    replica \u003d redis.Redis(port\u003dargs.replica_port)\n+\n+    check_redis_empty(primary, \"Primary\")\n+\n+    # Check if replica is running\n+    replica_running \u003d check_replica_running(args.replica_port)\n+    if replica_running:\n+        check_redis_empty(replica, \"Replica\")\n+\n+    tests \u003d find_test_classes(args.primary_port, args.replica_port)\n     if not tests:\n         print(\"No tests found!\")\n         return\ndiff --git a/modules/vector-sets/tests/vismember.py b/modules/vector-sets/tests/vismember.py\nnew file mode 100644\nindex 0000000..eabebca\n--- /dev/null\n+++ b/modules/vector-sets/tests/vismember.py\n@@ -0,0 +1,47 @@\n+from test import TestCase, generate_random_vector\n+import struct\n+\n+class BasicVISMEMBER(TestCase):\n+    def getname(self):\n+        return \"VISMEMBER basic functionality\"\n+\n+    def test(self):\n+        # Add multiple vectors to the vector set\n+        vec1 \u003d generate_random_vector(4)\n+        vec2 \u003d generate_random_vector(4)\n+        vec_bytes1 \u003d struct.pack(\u00274f\u0027, *vec1)\n+        vec_bytes2 \u003d struct.pack(\u00274f\u0027, *vec2)\n+\n+        # Create item keys\n+        item1 \u003d f\u0027{self.test_key}:item:1\u0027\n+        item2 \u003d f\u0027{self.test_key}:item:2\u0027\n+        nonexistent_item \u003d f\u0027{self.test_key}:item:nonexistent\u0027\n+\n+        # Add the vectors\n+        self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027FP32\u0027, vec_bytes1, item1)\n+        self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027FP32\u0027, vec_bytes2, item2)\n+\n+        # Test VISMEMBER with existing elements\n+        result1 \u003d self.redis.execute_command(\u0027VISMEMBER\u0027, self.test_key, item1)\n+        assert result1 \u003d\u003d 1, f\"VISMEMBER should return 1 for existing item, got {result1}\"\n+\n+        result2 \u003d self.redis.execute_command(\u0027VISMEMBER\u0027, self.test_key, item2)\n+        assert result2 \u003d\u003d 1, f\"VISMEMBER should return 1 for existing item, got {result2}\"\n+\n+        # Test VISMEMBER with non-existent element\n+        result3 \u003d self.redis.execute_command(\u0027VISMEMBER\u0027, self.test_key, nonexistent_item)\n+        assert result3 \u003d\u003d 0, f\"VISMEMBER should return 0 for non-existent item, got {result3}\"\n+\n+        # Test VISMEMBER with non-existent key\n+        nonexistent_key \u003d f\u0027{self.test_key}_nonexistent\u0027\n+        result4 \u003d self.redis.execute_command(\u0027VISMEMBER\u0027, nonexistent_key, item1)\n+        assert result4 \u003d\u003d 0, f\"VISMEMBER should return 0 for non-existent key, got {result4}\"\n+\n+        # Test VISMEMBER after removing an element\n+        self.redis.execute_command(\u0027VREM\u0027, self.test_key, item1)\n+        result5 \u003d self.redis.execute_command(\u0027VISMEMBER\u0027, self.test_key, item1)\n+        assert result5 \u003d\u003d 0, f\"VISMEMBER should return 0 after element removal, got {result5}\"\n+\n+        # Verify item2 still exists\n+        result6 \u003d self.redis.execute_command(\u0027VISMEMBER\u0027, self.test_key, item2)\n+        assert result6 \u003d\u003d 1, f\"VISMEMBER should still return 1 for remaining item, got {result6}\"\ndiff --git a/modules/vector-sets/vset.c b/modules/vector-sets/vset.c\nindex c411df7..84a193c 100644\n--- a/modules/vector-sets/vset.c\n+++ b/modules/vector-sets/vset.c\n@@ -577,7 +577,10 @@ int VADD_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         return RedisModule_ReplyWithError(ctx,\"ERR invalid vector specification\");\n \n     /* Missing element string at the end? */\n-    if (argc-2-consumed_args \u003c 1) return RedisModule_WrongArity(ctx);\n+    if (argc-2-consumed_args \u003c 1) {\n+        RedisModule_Free(vec);\n+        return RedisModule_WrongArity(ctx);\n+    }\n \n     /* Parse options after the element string. */\n     uint32_t quant_type \u003d HNSW_QUANT_Q8; // Default quantization type.\n@@ -1646,6 +1649,37 @@ int VRANDMEMBER_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int\n     return REDISMODULE_OK;\n }\n \n+/* VISMEMBER key element\n+ * Check if an element exists in a vector set.\n+ * Returns 1 if the element exists, 0 if not. */\n+int VISMEMBER_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n+    RedisModule_AutoMemory(ctx);\n+    if (argc !\u003d 3) return RedisModule_WrongArity(ctx);\n+\n+    RedisModuleString *key \u003d argv[1];\n+    RedisModuleString *element \u003d argv[2];\n+\n+    /* Open key. */\n+    RedisModuleKey *keyptr \u003d RedisModule_OpenKey(ctx, key, REDISMODULE_READ);\n+    int type \u003d RedisModule_KeyType(keyptr);\n+\n+    /* Handle non-existing key or wrong type. */\n+    if (type \u003d\u003d REDISMODULE_KEYTYPE_EMPTY) {\n+        /* An element of a non existing key does not exist, like\n+         * SISMEMBER \u0026 similar. */\n+        return RedisModule_ReplyWithBool(ctx, 0);\n+    }\n+    if (RedisModule_ModuleTypeGetType(keyptr) !\u003d VectorSetType) {\n+        return RedisModule_ReplyWithError(ctx, REDISMODULE_ERRORMSG_WRONGTYPE);\n+    }\n+\n+    /* Get the object and test membership via the dictionary in constant\n+     * time (assuming a member of average size). */\n+    struct vsetObject *vset \u003d RedisModule_ModuleTypeGetValue(keyptr);\n+    hnswNode *node \u003d RedisModule_DictGet(vset-\u003edict, element, NULL);\n+    return RedisModule_ReplyWithBool(ctx, node !\u003d NULL);\n+}\n+\n /* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d vset type methods \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */\n \n #define SAVE_FLAG_HAS_PROJMATRIX    (1\u003c\u003c0)\n@@ -1969,6 +2003,10 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n         VRANDMEMBER_RedisCommand, \"readonly\", 1, 1, 1) \u003d\u003d REDISMODULE_ERR)\n         return REDISMODULE_ERR;\n \n+    if (RedisModule_CreateCommand(ctx, \"VISMEMBER\",\n+        VISMEMBER_RedisCommand, \"readonly\", 1, 1, 1) \u003d\u003d REDISMODULE_ERR)\n+        return REDISMODULE_ERR;\n+\n     hnsw_set_allocator(RedisModule_Free, RedisModule_Alloc,\n                        RedisModule_Realloc);\n \ndiff --git a/utils/req-res-log-validator.py b/utils/req-res-log-validator.py\nindex d4c387c..ddb2ef7 100755\n--- a/utils/req-res-log-validator.py\n+++ b/utils/req-res-log-validator.py\n@@ -70,6 +70,7 @@ IGNORED_COMMANDS \u003d {\n     \"VREM\",\n     \"VSETATTR\",\n     \"VSIM\",\n+    \"VISMEMBER\",\n }\n \n class Request(object):","expectedMessage":"Vector Sets: VISMEMBER and other fixes (#13941)","repository":"redis-antirez","commitHash":"41ecf7323ee96b50effcc8d0ae7d6f8a631a5f25","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-96a0cfde","diff":" modules/vector-sets/README.md |  2 ++\n modules/vector-sets/vset.c    |  7 +------\n modules/vector-sets/w2v.c     | 36 ++++++++++++++++++++++++++++++------\n 3 files changed, 33 insertions(+), 12 deletions(-)\n\ndiff --git a/modules/vector-sets/README.md b/modules/vector-sets/README.md\nindex 43038d0..83febe4 100644\n--- a/modules/vector-sets/README.md\n+++ b/modules/vector-sets/README.md\n@@ -1,3 +1,5 @@\n+**IMPORTANT:** *Please note that this is a merged module, it\u0027s part of the Redis binary now, and you don\u0027t need to build it and load it into Redis. Compiling Redis version 8 or greater will result into having the Vector Sets commands available. However, you could compile this module as a shared library in order to load it in older versions of Redis.*\n+\n This module implements Vector Sets for Redis, a new Redis data type similar\n to Sorted Sets but having string elements associated to a vector instead of\n a score. The fundamental goal of Vector Sets is to make possible adding items,\ndiff --git a/modules/vector-sets/vset.c b/modules/vector-sets/vset.c\nindex f987535..c411df7 100644\n--- a/modules/vector-sets/vset.c\n+++ b/modules/vector-sets/vset.c\n@@ -1902,12 +1902,7 @@ void VectorSetDigest(RedisModuleDigest *md, void *value) {\n \n /* This function must be present on each Redis module. It is used in order to\n  * register the commands into the Redis server. */\n-#ifdef MERGED_REDIS_MODULE\n-#define ONLOAD VectorSets_OnLoad\n-#else\n-#define ONLOAD RedisModule_OnLoad\n-#endif\n-int ONLOAD(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n+int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     REDISMODULE_NOT_USED(argv);\n     REDISMODULE_NOT_USED(argc);\n \ndiff --git a/modules/vector-sets/w2v.c b/modules/vector-sets/w2v.c\nindex 3a8ef05..9cbf7e1 100644\n--- a/modules/vector-sets/w2v.c\n+++ b/modules/vector-sets/w2v.c\n@@ -10,9 +10,14 @@\n  * Originally authored by: Salvatore Sanfilippo\n  */\n \n+#define _DEFAULT_SOURCE\n+#define _USE_MATH_DEFINES\n+#define _POSIX_C_SOURCE 200809L\n+\n #include \u003cstdio.h\u003e\n #include \u003cstdlib.h\u003e\n #include \u003cstring.h\u003e\n+#include \u003cstrings.h\u003e\n #include \u003csys/time.h\u003e\n #include \u003ctime.h\u003e\n #include \u003cstdint.h\u003e\n@@ -222,7 +227,10 @@ int w2v_single_thread(int m_param, int quantization, uint64_t numele, int massde\n         exit(1);\n     }\n     unsigned char header[8];\n-    fread(header,8,1,fp); // Skip header\n+    if (fread(header,8,1,fp) \u003c\u003d 0) { // Skip header\n+        perror(\"Unexpected EOF\");\n+        exit(1);\n+    }\n \n     uint64_t id \u003d 0;\n     uint64_t start_time \u003d ms_time();\n@@ -232,9 +240,15 @@ int w2v_single_thread(int m_param, int quantization, uint64_t numele, int massde\n     while(id \u003c numele) {\n         if (fread(\u0026wlen,2,1,fp) \u003d\u003d 0) break;\n         word \u003d malloc(wlen+1);\n-        fread(word,wlen,1,fp);\n+        if (fread(word,wlen,1,fp) \u003c\u003d 0) {\n+            perror(\"unexpected EOF\");\n+            exit(1);\n+        }\n         word[wlen] \u003d 0;\n-        fread(v,300*sizeof(float),1,fp);\n+        if (fread(v,300*sizeof(float),1,fp) \u003c\u003d 0) {\n+            perror(\"unexpected EOF\");\n+            exit(1);\n+        }\n \n         // Plain API that acquires a write lock for the whole time.\n         hnswNode *added \u003d hnsw_insert(index, v, NULL, 0, id++, word, 200);\n@@ -339,9 +353,16 @@ void *threaded_insert(void *ctxptr) {\n         if (fread(\u0026wlen,2,1,ctx-\u003efp) \u003d\u003d 0) break;\n         pthread_mutex_unlock(\u0026ctx-\u003eFileAccessMutex);\n         word \u003d malloc(wlen+1);\n-        fread(word,wlen,1,ctx-\u003efp);\n+        if (fread(word,wlen,1,ctx-\u003efp) \u003c\u003d 0) {\n+            perror(\"Unexpected EOF\");\n+            exit(1);\n+        }\n+\n         word[wlen] \u003d 0;\n-        fread(v,300*sizeof(float),1,ctx-\u003efp);\n+        if (fread(v,300*sizeof(float),1,ctx-\u003efp) \u003c\u003d 0) {\n+            perror(\"Unexpected EOF\");\n+            exit(1);\n+        }\n \n         // Check-and-set API that performs the costly scan for similar\n         // nodes concurrently with other read threads, and finally\n@@ -401,7 +422,10 @@ int w2v_multi_thread(int m_param, int numthreads, int quantization, uint64_t num\n     }\n \n     unsigned char header[8];\n-    fread(header,8,1,ctx.fp); // Skip header\n+    if (fread(header,8,1,ctx.fp) \u003c\u003d 0) { // Skip header\n+        perror(\"Unexpected EOF\");\n+        exit(1);\n+    }\n     pthread_mutex_init(\u0026ctx.FileAccessMutex,NULL);\n \n     uint64_t start_time \u003d ms_time();","expectedMessage":"Vectror Sets: build fixes for the w2v test (#13919)","repository":"redis-antirez","commitHash":"96a0cfdea27fa28f93b8071ec1b3c6ef8b315298","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-c6db0a7c","diff":" Makefile |   6 ++--\n vset.c   | 100 ++++++++++++++++++++++++++++++++++++++++++++++-----------------\n 2 files changed, 76 insertions(+), 30 deletions(-)\n\ndiff --git a/Makefile b/Makefile\nindex ff1b45a..407ed08 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -17,7 +17,7 @@ endif\n endif\n endif\n \n-CFLAGS \u003d -O2 -Wall -Wextra -g -ffast-math $(SAN)\n+CFLAGS \u003d -O2 -Wall -Wextra -g $(SAN) -std\u003dc11\n LDFLAGS \u003d -lm $(SAN)\n \n # Detect OS\n@@ -26,7 +26,7 @@ uname_M :\u003d $(shell sh -c \u0027uname -m 2\u003e/dev/null || echo not\u0027)\n \n # Shared library compile flags for linux / osx\n ifeq ($(uname_S),Linux)\n-\tSHOBJ_CFLAGS ?\u003d -W -Wall -fno-common -g -ggdb -std\u003dc99 -O2\n+\tSHOBJ_CFLAGS ?\u003d -W -Wall -fno-common -g -ggdb -std\u003dc11 -O2\n \tSHOBJ_LDFLAGS ?\u003d -shared\n ifneq (,$(findstring armv,$(uname_M)))\n \tSHOBJ_LDFLAGS +\u003d -latomic\n@@ -35,7 +35,7 @@ ifneq (,$(findstring aarch64,$(uname_M)))\n \tSHOBJ_LDFLAGS +\u003d -latomic\n endif\n else\n-\tSHOBJ_CFLAGS ?\u003d -W -Wall -dynamic -fno-common -g -ggdb -std\u003dc99 -Ofast -ffast-math\n+\tSHOBJ_CFLAGS ?\u003d -W -Wall -dynamic -fno-common -g -ggdb -std\u003dc11 -O3\n \tSHOBJ_LDFLAGS ?\u003d -bundle -undefined dynamic_lookup\n endif\n \ndiff --git a/vset.c b/vset.c\nindex fd5ea57..c83a4a4 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -57,6 +57,43 @@\n  *     our read commands running in the main thread don\u0027t need to use\n  *     hnsw_search() or other HNSW functions using the visited epochs slots\n  *     we are safe.\n+ *\n+ * 4. There is a race from the moment we create a thread, passing the\n+ *    vector set object, to the moment the thread can actually lock the\n+ *    result win the in_use_lock mutex: as the thread starts, in the meanwhile\n+ *    a DEL/expire could trigger and remove the object. For this reason\n+ *    we use an atomic counter that protects our object for this small\n+ *    time in vectorSetWaitAllBackgroundClients(). This prevents removal\n+ *    of objects that are about to be taken by threads.\n+ *\n+ *    Note that other competing soltuions could be used to fix the problem\n+ *    but have their set of issues, however they are worth documenting here\n+ *    and evaluating in the future:\n+ *\n+ *      A. Using a conditional variable we could \"wait\" for the thread to\n+ *         acquire the lock. However this means waiting before returning\n+ *         to the event loop, and would make the command execution slower.\n+ *      B. We could use again an atomic variable, like we did, but this time\n+ *         as a refcount for the object, with a vsetAcquire() vsetRelease().\n+ *         In this case, the command could retain the object in the main thread\n+ *         before starting the thread, and the thread, after the work is done,\n+ *         could release it. This way sometimes the object would be freed by\n+ *         the thread, and it\u0027s while now can be safe to do the kind of resource\n+ *         deallocation that vectorSetReleaseObject() does, given that the\n+ *         Redis Modules API is not always thread safe this solution may not\n+ *         be future-proof. However there is to evaluate it better in the\n+ *         future.\n+ *      C. We could use the \"B\" solution but instead of freeing the object\n+ *         in the thread, in this specific case we could just put it into a\n+ *         list and defer it for later freeing (for instance in the reply\n+ *         callback), so that the object is always freed in the main thread.\n+ *         This would require a list of objects to free.\n+ *\n+ *    However the current solution only disadvantage is the potential busy\n+ *    loop, but this busy loop in practical terms will almost never do\n+ *    much: to trigger it, a number of circumnstances must happen: deleting\n+ *    Vector Set keys while using them, hitting the small window needed to\n+ *    start the thread and read-lock the mutex.\n  */\n \n #define _DEFAULT_SOURCE\n@@ -72,6 +109,7 @@\n #include \u003cstdint.h\u003e\n #include \u003cmath.h\u003e\n #include \u003cpthread.h\u003e\n+#include \u003cstdatomic.h\u003e\n #include \"hnsw.h\"\n \n // We inline directly the expression implementation here so that building\n@@ -107,6 +145,8 @@ struct vsetObject {\n     uint64_t id;                // Unique ID used by threaded VADD to know the\n                                 // object is still the same.\n     uint64_t numattribs;        // Number of nodes associated with an attribute.\n+    atomic_int thread_creation_pending; // Number of threads that are currently\n+                                        // pending to lock the object.\n };\n \n /* Each node has two associated values: the associated string (the item\n@@ -200,6 +240,7 @@ struct vsetObject *createVectorSetObject(unsigned int dim, uint32_t quant_type,\n     o-\u003eproj_matrix \u003d NULL;\n     o-\u003eproj_input_size \u003d 0;\n     o-\u003enumattribs \u003d 0;\n+    o-\u003ethread_creation_pending \u003d 0;\n     RedisModule_Assert(pthread_rwlock_init(\u0026o-\u003ein_use_lock,NULL) \u003d\u003d 0);\n     return o;\n }\n@@ -223,8 +264,19 @@ void vectorSetReleaseObject(struct vsetObject *o) {\n \n /* Wait for all the threads performing operations on this\n  * index to terminate their work (locking for write will\n- * wait for all the other threads). */\n-void vectorSetWaitAllBackgroundClients(struct vsetObject *vset) {\n+ * wait for all the other threads).\n+ *\n+ * if \u0027for_del\u0027 is set to 1, we also wait for all the pending threads\n+ * that still didn\u0027t acquire the lock to finish their work. This\n+ * is useful only if we are going to call this function to delete\n+ * the object, and not if we want to just to modify it. */\n+void vectorSetWaitAllBackgroundClients(struct vsetObject *vset, int for_del) {\n+    if (for_del) {\n+        // If we are going to destroy the object, after this call, let\u0027s\n+        // wait for threads that are being created and still didn\u0027t had\n+        // a chance to acquire the lock.\n+        while (vset-\u003ethread_creation_pending \u003e 0);\n+    }\n     RedisModule_Assert(pthread_rwlock_wrlock(\u0026vset-\u003ein_use_lock) \u003d\u003d 0);\n     pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n }\n@@ -252,7 +304,7 @@ int vectorSetInsert(struct vsetObject *o, float *vec, int8_t *qvec, float qrange\n             /* Wait for clients in the background: background VSIM\n              * operations touch the nodes attributes we are going\n              * to touch. */\n-            vectorSetWaitAllBackgroundClients(o);\n+            vectorSetWaitAllBackgroundClients(o,0);\n \n             struct vsetNodeVal *nv \u003d node-\u003evalue;\n             /* Pass NULL as value-free function. We want to reuse\n@@ -403,6 +455,11 @@ void *VADD_thread(void *arg) {\n     float *vec \u003d targ[3];\n     int ef \u003d (uint64_t)targ[6];\n \n+    /* Lock the object and signal that we are no longer pending\n+     * the lock acquisition. */\n+    RedisModule_Assert(pthread_rwlock_rdlock(\u0026vset-\u003ein_use_lock) \u003d\u003d 0);\n+    vset-\u003ethread_creation_pending--;\n+\n     /* Look for candidates... */\n     InsertContext *ic \u003d hnsw_prepare_insert(vset-\u003ehnsw, vec, NULL, 0, 0, ef);\n     targ[5] \u003d ic; // Pass the context to the reply callback.\n@@ -680,10 +737,6 @@ int VADD_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n      * way, or use a thread to do candidate neighbors selection and only\n      * later, in the reply callback, actually add the element. */\n     if (cas) {\n-        /* Make sure the key does not get deleted during the background\n-         * operation. See VSIM implementation for more information. */\n-        RedisModule_Assert(pthread_rwlock_rdlock(\u0026vset-\u003ein_use_lock) \u003d\u003d 0);\n-\n         RedisModuleBlockedClient *bc \u003d RedisModule_BlockClient(ctx,VADD_CASReply,NULL,NULL,0);\n         pthread_t tid;\n         void **targ \u003d RedisModule_Alloc(sizeof(void*)*8);\n@@ -698,8 +751,9 @@ int VADD_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         RedisModule_RetainString(ctx,val);\n         if (attrib) RedisModule_RetainString(ctx,attrib);\n         RedisModule_BlockedClientMeasureTimeStart(bc);\n+        vset-\u003ethread_creation_pending++;\n         if (pthread_create(\u0026tid,NULL,VADD_thread,targ) !\u003d 0) {\n-            pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n+            vset-\u003ethread_creation_pending--;\n             RedisModule_AbortBlock(bc);\n             RedisModule_Free(targ);\n             RedisModule_FreeString(ctx,val);\n@@ -823,15 +877,20 @@ void *VSIM_thread(void *arg) {\n     RedisModule_Free(targ[4]);\n     RedisModule_Free(targ);\n \n+    /* Lock the object and signal that we are no longer pending\n+     * the lock acquisition. */\n+    RedisModule_Assert(pthread_rwlock_rdlock(\u0026vset-\u003ein_use_lock) \u003d\u003d 0);\n+    vset-\u003ethread_creation_pending--;\n+\n     // Accumulate reply in a thread safe context: no contention.\n     RedisModuleCtx *ctx \u003d RedisModule_GetThreadSafeContext(bc);\n \n     // Run the query.\n     VSIM_execute(ctx, vset, vec, count, epsilon, withscores, ef, filter_expr, filter_ef, ground_truth);\n+    pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n \n     // Cleanup.\n     RedisModule_FreeThreadSafeContext(ctx);\n-    pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n     RedisModule_BlockedClientMeasureTimeEnd(bc);\n     RedisModule_UnblockClient(bc,NULL);\n     return NULL;\n@@ -1022,26 +1081,12 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     }\n \n     if (threaded_request) {\n-        /* Spawn the thread serving the request:\n-         * Acquire the lock here so that the object will not be\n-         * destroyed while we work with it in the thread.\n-         *\n-         * This lock should never block, since:\n-         * 1. If we are in the main thread, the key exists (we looked it up)\n-         * and so there is no deletion in progress.\n-         * 2. If the write lock is taken while destroying the object, another\n-         * command or operation (expire?) from the main thread acquired\n-         * it to delete the object, so *it* will block if there are still\n-         * operations in progress on this key.\n-         *\n-         * Note: even if we create one thread per request, the underlying\n+        /* Note: even if we create one thread per request, the underlying\n          * HNSW library has a fixed number of slots for the threads, as it\u0027s\n          * defined in HNSW_MAX_THREADS (beware that if you increase it,\n          * every node will use more memory). This means that while this request\n          * is threaded, and will NOT block Redis, it may end waiting for a\n          * free slot if all the HNSW_MAX_THREADS slots are used. */\n-        RedisModule_Assert(pthread_rwlock_rdlock(\u0026vset-\u003ein_use_lock) \u003d\u003d 0);\n-\n         RedisModuleBlockedClient *bc \u003d RedisModule_BlockClient(ctx,NULL,NULL,NULL,0);\n         pthread_t tid;\n         void **targ \u003d RedisModule_Alloc(sizeof(void*)*10);\n@@ -1057,8 +1102,9 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         targ[8] \u003d (void*)(unsigned long)filter_ef;\n         targ[9] \u003d (void*)(unsigned long)ground_truth;\n         RedisModule_BlockedClientMeasureTimeStart(bc);\n+        vset-\u003ethread_creation_pending++;\n         if (pthread_create(\u0026tid,NULL,VSIM_thread,targ) !\u003d 0) {\n-            pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n+            vset-\u003ethread_creation_pending--;\n             RedisModule_AbortBlock(bc);\n             RedisModule_Free(targ[4]);\n             RedisModule_Free(targ);\n@@ -1259,7 +1305,7 @@ int VSETATTR_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int arg\n \n     /* Background VSIM operations use the node attributes, so\n      * wait for background operations before messing with them. */\n-    vectorSetWaitAllBackgroundClients(vset);\n+    vectorSetWaitAllBackgroundClients(vset,0);\n \n     /* Set or delete the attribute based on the fact it\u0027s an empty\n      * string or not. */\n@@ -1817,7 +1863,7 @@ size_t VectorSetMemUsage(const void *value) {\n void VectorSetFree(void *value) {\n     struct vsetObject *vset \u003d value;\n \n-    vectorSetWaitAllBackgroundClients(vset);\n+    vectorSetWaitAllBackgroundClients(vset,1);\n     vectorSetReleaseObject(value);\n }\n ","expectedMessage":"Don\u0027t use cross-thread unlocking.","repository":"redis-antirez","commitHash":"c6db0a7c20ff5638f3a0c9ce9c106303daeb2f67","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-3dd48b5b","diff":" README.md | 55 +++++++++++++++++++++++++++++++++++++++++++++++++++++++\n 1 file changed, 55 insertions(+)\n\ndiff --git a/README.md b/README.md\nindex b496f3f..1ed1cb2 100644\n--- a/README.md\n+++ b/README.md\n@@ -537,6 +537,61 @@ Vector Sets, or better, HNSWs, the underlying data structure used by Vector Sets\n * It is possible to gain space (less memory usage) sacrificing time (more CPU time) by using a low `M` (the default of 16, for instance) and a high `EF` (the effort parameter of `VSIM`) in order to scan the graph more deeply.\n * When memory usage is seriosu concern, and there is the suspect the vectors we are storing don\u0027t contain as much information - at least for our use case - to justify the number of components they feature, random projection (the `REDUCE` option of `VADD`) could be tested to see if dimensionality reduction is possible with acceptable precision loss.\n \n+## Random projection tradeoffs\n+\n+Sometimes learned vectors are not as information dense as we could guess, that\n+is there are components having similar meanings in the space, and components\n+having values that don\u0027t really represent features that matter in our use case.\n+\n+At the same time, certain vectors are very big, 1024 components or more. In this cases, it is possible to use the random projection feature of Redis Vector Sets in order to reduce both space (less RAM used) and space (more operstions per second). The feature is accessible via the `REDUCE` option of the `VADD` command. However, keep in mind that you need to test how much reduction impacts the performances of your vectors in term of recall and quality of the results you get back.\n+\n+## What is a random projection?\n+\n+The concept of Random Projection is relatively simple to grasp. For instance, a projection that turns a 100 components vector into a 10 components vector will perform a different linear transformation between the 100 components and each of the target 10 components. Please note that *each of the target components* will get some random amount of all the 100 original components. It is mathematically proved that this process results in a vector space where elements still have similar distances among them, but still some information will get lost.\n+\n+## Examples of projections and loss of precision\n+\n+To show you a bit of a extreme case, let\u0027s take Word2Vec 3 million items and compress them from 300 to 100, 50 and 25 components vectors. Then, we check the recall compared to the ground truth against each of the vector sets produced in this way (using different `REDUCE` parameters of `VADD`). This is the result, obtained asking for the top 10 elements.\n+\n+```\n+----------------------------------------------------------------------\n+Key                            Average Recall % Std Dev\n+----------------------------------------------------------------------\n+word_embeddings_int8           95.98           12.14\n+  ^ This is the same key used for ground truth, but without TRUTH option\n+word_embeddings_reduced_100    40.20           20.13\n+word_embeddings_reduced_50     24.42           16.89\n+word_embeddings_reduced_25     14.31           9.99\n+```\n+\n+Here the dimensionality reduction we are using is quite extreme: from 300 to 100 means that 66.6% of the original information is lost. The recall drops from 96% to 40%, down to 24% and 14% for even more extreme dimension reduction.\n+\n+Reducing the dimension of vectors that are already relatively small, like the above example, of 300 components, will provide only relatively small memory savings, especially because by default Vector Sets use `int8` quantization, that will use only one byte per component:\n+\n+```\n+\u003e MEMORY USAGE word_embeddings_int8\n+(integer) 3107002888\n+\u003e MEMORY USAGE word_embeddings_reduced_100\n+(integer) 2507122888\n+```\n+\n+Of course going, for example, from 2048 component vectors to 1024 would provide a much more sensible memory saving, even with the `int8` quantization used by Vector Sets, assuming the recall loss is acceptable. Other than the memory saving, there is also the reduction in CPU time, translating to more operations per second.\n+\n+Another thing to note is that, with certain embedding models, binary quantization (that offers a 8x reduction of memory usage compared to 8 bit quants, and a very big speedup in computation) performs much better than reducing the dimension of vectors of the same amount via random projections:\n+\n+```\n+word_embeddings_bin            35.48           19.78\n+```\n+\n+Here in the same test did above: we have a 35% recall which is not too far than the 40% obtained with a random projection from 300 to 100 components. However, while the first technique reduces the size by 3 times, the size reduced of binary quantization is by 8 times.\n+\n+```\n+\u003e memory usage word_embeddings_bin\n+(integer) 2327002888\n+```\n+\n+In this specific case the key uses JSON attributes and has a graph connection overhead that is much bigger than the 300 bits each vector takes, but, as already said, for big vectors (1024 components, for instance) or for lower values of `M` (see `VADD`, the `M` parameter connects the level of connectivity, so it changes the amount of pointers used per node) the memory saving is much stronger.\n+\n # Vector Sets troubleshooting and understandability\n \n ## Debugging poor recall or unexpected results","expectedMessage":"README: Random Projection section.","repository":"redis-antirez","commitHash":"3dd48b5b45c4558b01cfe9273a97dc5244e415a0","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-4dca45ad","diff":" cJSON.c | 14 +++++++-------\n 1 file changed, 7 insertions(+), 7 deletions(-)\n\ndiff --git a/cJSON.c b/cJSON.c\nindex d7c7236..bcbb341 100644\n--- a/cJSON.c\n+++ b/cJSON.c\n@@ -124,7 +124,7 @@ CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item)\n CJSON_PUBLIC(const char*) cJSON_Version(void)\n {\n     static char version[15];\n-    sprintf(version, \"%i.%i.%i\", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);\n+    snprintf(version, sizeof(version), \"%i.%i.%i\", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);\n \n     return version;\n }\n@@ -579,26 +579,26 @@ static cJSON_bool print_number(const cJSON * const item, printbuffer * const out\n     /* This checks for NaN and Infinity */\n     if (isnan(d) || isinf(d))\n     {\n-        length \u003d sprintf((char*)number_buffer, \"null\");\n+        length \u003d snprintf((char*)number_buffer, sizeof(number_buffer), \"null\");\n     }\n     else if(d \u003d\u003d (double)item-\u003evalueint)\n     {\n-        length \u003d sprintf((char*)number_buffer, \"%d\", item-\u003evalueint);\n+        length \u003d snprintf((char*)number_buffer, sizeof(number_buffer), \"%d\", item-\u003evalueint);\n     }\n     else\n     {\n         /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */\n-        length \u003d sprintf((char*)number_buffer, \"%1.15g\", d);\n+        length \u003d snprintf((char*)number_buffer, sizeof(number_buffer), \"%1.15g\", d);\n \n         /* Check whether the original double can be recovered */\n         if ((sscanf((char*)number_buffer, \"%lg\", \u0026test) !\u003d 1) || !compare_double((double)test, d))\n         {\n             /* If not, print with 17 decimal places of precision */\n-            length \u003d sprintf((char*)number_buffer, \"%1.17g\", d);\n+            length \u003d snprintf((char*)number_buffer, sizeof(number_buffer), \"%1.17g\", d);\n         }\n     }\n \n-    /* sprintf failed or buffer overrun occurred */\n+    /* snprintf failed or buffer overrun occurred */\n     if ((length \u003c 0) || (length \u003e (int)(sizeof(number_buffer) - 1)))\n     {\n         return false;\n@@ -1028,7 +1028,7 @@ static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffe\n                     break;\n                 default:\n                     /* escape and print as unicode codepoint */\n-                    sprintf((char*)output_pointer, \"u%04x\", *input_pointer);\n+                    snprintf((char*)output_pointer, sizeof(output_pointer), \"u%04x\", *input_pointer);\n                     output_pointer +\u003d 4;\n                     break;\n             }","expectedMessage":"Remove sprintf() from cJSON.","repository":"redis-antirez","commitHash":"4dca45ad2447459b7978fd345e321acde7bfd163","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-b17499f9","diff":" vset.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex 1297e80..fd5ea57 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -663,7 +663,8 @@ int VADD_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n             }\n \n             float *projected \u003d applyProjection(vec, vset-\u003eproj_matrix,\n-                                             vset-\u003eproj_input_size, dim);\n+                                             vset-\u003eproj_input_size,\n+                                             vset-\u003ehnsw-\u003evector_dim);\n             RedisModule_Free(vec);\n             vec \u003d projected;\n             dim \u003d vset-\u003ehnsw-\u003evector_dim;\n@@ -910,7 +911,8 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n             }\n \n             float *projected \u003d applyProjection(vec, vset-\u003eproj_matrix,\n-                                             vset-\u003eproj_input_size, dim);\n+                                             vset-\u003eproj_input_size,\n+                                             vset-\u003ehnsw-\u003evector_dim);\n             RedisModule_Free(vec);\n             vec \u003d projected;\n             dim \u003d vset-\u003ehnsw-\u003evector_dim;","expectedMessage":"Fix projection output len.","repository":"redis-antirez","commitHash":"b17499f90749854c839acc033c9d16a758ffc688","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-29c27bc1","diff":" hnsw.c | 20 ++++++++++----------\n hnsw.h |  4 ++--\n vset.c |  8 +++-----\n w2v.c  |  4 ++--\n 4 files changed, 17 insertions(+), 19 deletions(-)\n\ndiff --git a/hnsw.c b/hnsw.c\nindex e0ea97c..a9a2695 100644\n--- a/hnsw.c\n+++ b/hnsw.c\n@@ -375,7 +375,7 @@ void hnsw_normalize_vector(float *x, float *l2ptr, uint32_t dim) {\n }\n \n /* Helper function to generate random level. */\n-uint32_t random_level() {\n+uint32_t random_level(void) {\n     static const int threshold \u003d HNSW_P * RAND_MAX;\n     uint32_t level \u003d 0;\n \n@@ -1656,7 +1656,7 @@ struct InsertContext {\n  * See hnsw_node_new() for information about \u0027vector\u0027 and \u0027qvector\u0027\n  * arguments, and which one to pass. */\n InsertContext *hnsw_prepare_insert_nolock(HNSW *index, const float *vector,\n-                const int8_t *qvector, float qrange, uint64_t id, void *value,\n+                const int8_t *qvector, float qrange, uint64_t id,\n                 int slot, int ef)\n {\n     InsertContext *ctx \u003d hmalloc(sizeof(*ctx));\n@@ -1673,7 +1673,6 @@ InsertContext *hnsw_prepare_insert_nolock(HNSW *index, const float *vector,\n         hfree(ctx);\n         return NULL;\n     }\n-    ctx-\u003enode-\u003evalue \u003d value;\n \n     hnswNode *curr_ep \u003d index-\u003eenter_point;\n \n@@ -1707,12 +1706,12 @@ InsertContext *hnsw_prepare_insert_nolock(HNSW *index, const float *vector,\n \n /* External API for hnsw_prepare_insert_nolock(), handling locking. */\n InsertContext *hnsw_prepare_insert(HNSW *index, const float *vector,\n-                const int8_t *qvector, float qrange, uint64_t id, void *value,\n+                const int8_t *qvector, float qrange, uint64_t id,\n                 int ef)\n {\n     InsertContext *ctx;\n     int slot \u003d hnsw_acquire_read_slot(index);\n-    ctx \u003d hnsw_prepare_insert_nolock(index,vector,qvector,qrange,id,value,slot,ef);\n+    ctx \u003d hnsw_prepare_insert_nolock(index,vector,qvector,qrange,id,slot,ef);\n     hnsw_release_read_slot(index,slot);\n     return ctx;\n }\n@@ -1738,8 +1737,9 @@ void hnsw_free_insert_context(InsertContext *ctx) {\n  * just inserted node. Out of memory is not possible since no critical\n  * allocation is never performed in this code path: we populate links\n  * on already allocated nodes. */\n-hnswNode *hnsw_commit_insert_nolock(HNSW *index, InsertContext *ctx) {\n+hnswNode *hnsw_commit_insert_nolock(HNSW *index, InsertContext *ctx, void *value) {\n     hnswNode *node \u003d ctx-\u003enode;\n+    node-\u003evalue \u003d value;\n \n     /* Handle first node case. */\n     if (index-\u003eenter_point \u003d\u003d NULL) {\n@@ -1798,7 +1798,7 @@ hnswNode *hnsw_commit_insert_nolock(HNSW *index, InsertContext *ctx) {\n  * index and return its pointer. Otherwise NULL is returned and the operation\n  * should be either performed with the blocking API hnsw_insert() or attempted\n  * again. */\n-hnswNode *hnsw_try_commit_insert(HNSW *index, InsertContext *ctx) {\n+hnswNode *hnsw_try_commit_insert(HNSW *index, InsertContext *ctx, void *value) {\n     /* Check if the version changed since preparation. Note that we\n      * should access index-\u003eversion under the write lock in order to\n      * be sure we can safely commit the write: this is just a fast-path\n@@ -1824,7 +1824,7 @@ hnswNode *hnsw_try_commit_insert(HNSW *index, InsertContext *ctx) {\n \n     /* Commit the change: note that it\u0027s up to hnsw_commit_insert_nolock()\n      * to free the insertion context. */\n-    hnswNode *node \u003d hnsw_commit_insert_nolock(index, ctx);\n+    hnswNode *node \u003d hnsw_commit_insert_nolock(index, ctx, value);\n \n     /* Release the write lock. */\n     pthread_rwlock_unlock(\u0026index-\u003eglobal_lock);\n@@ -1848,14 +1848,14 @@ hnswNode *hnsw_insert(HNSW *index, const float *vector, const int8_t *qvector, f\n \n     // Prepare the insertion - note we pass slot 0 since we\u0027re single threaded.\n     InsertContext *ctx \u003d hnsw_prepare_insert_nolock(index, vector, qvector,\n-                                                   qrange, id, value, 0, ef);\n+                                                   qrange, id, 0, ef);\n     if (!ctx) {\n         pthread_rwlock_unlock(\u0026index-\u003eglobal_lock);\n         return NULL;\n     }\n \n     // Commit the prepared insertion without version checking.\n-    hnswNode *node \u003d hnsw_commit_insert_nolock(index, ctx);\n+    hnswNode *node \u003d hnsw_commit_insert_nolock(index, ctx, value);\n \n     // Release write lock and return our node pointer.\n     pthread_rwlock_unlock(\u0026index-\u003eglobal_lock);\ndiff --git a/hnsw.h b/hnsw.h\nindex deaa671..877302e 100644\n--- a/hnsw.h\n+++ b/hnsw.h\n@@ -144,8 +144,8 @@ int hnsw_acquire_read_slot(HNSW *index);\n void hnsw_release_read_slot(HNSW *index, int slot);\n \n /* Optimistic insertion API. */\n-InsertContext *hnsw_prepare_insert(HNSW *index, const float *vector, const int8_t *qvector, float qrange, uint64_t id, void *value, int ef);\n-hnswNode *hnsw_try_commit_insert(HNSW *index, InsertContext *ctx);\n+InsertContext *hnsw_prepare_insert(HNSW *index, const float *vector, const int8_t *qvector, float qrange, uint64_t id, int ef);\n+hnswNode *hnsw_try_commit_insert(HNSW *index, InsertContext *ctx, void *value);\n void hnsw_free_insert_context(InsertContext *ctx);\n \n /* Serialization. */\ndiff --git a/vset.c b/vset.c\nindex af1026a..1297e80 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -339,7 +339,7 @@ float *parseVector(RedisModuleString **argv, int argc, int start_idx,\n \n     /* Now parse the vector format as before. */\n     float *vec \u003d NULL;\n-    char *vec_format \u003d RedisModule_StringPtrLen(argv[start_idx],NULL);\n+    const char *vec_format \u003d RedisModule_StringPtrLen(argv[start_idx],NULL);\n \n     if (!strcasecmp(vec_format,\"FP32\")) {\n         if (argc \u003c start_idx + 2) return NULL;  // Need FP32 + vector + value.\n@@ -404,7 +404,7 @@ void *VADD_thread(void *arg) {\n     int ef \u003d (uint64_t)targ[6];\n \n     /* Look for candidates... */\n-    InsertContext *ic \u003d hnsw_prepare_insert(vset-\u003ehnsw, vec, NULL, 0, 0, NULL, ef);\n+    InsertContext *ic \u003d hnsw_prepare_insert(vset-\u003ehnsw, vec, NULL, 0, 0, ef);\n     targ[5] \u003d ic; // Pass the context to the reply callback.\n \n     /* Unblock the client so that our read reply will be invoked. */\n@@ -473,15 +473,13 @@ int VADD_CASReply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n          * locking failure (likely impossible in practical terms). */\n         hnswNode *newnode;\n         if (ic \u003d\u003d NULL ||\n-            (newnode \u003d hnsw_try_commit_insert(vset-\u003ehnsw, ic)) \u003d\u003d NULL)\n+            (newnode \u003d hnsw_try_commit_insert(vset-\u003ehnsw, ic, nv)) \u003d\u003d NULL)\n         {\n             /* If we are here, the CAS insert failed. We need to insert\n              * again with full locking for neighbors selection and\n              * actual insertion. This time we can\u0027t fail: */\n             newnode \u003d hnsw_insert(vset-\u003ehnsw, vec, NULL, 0, 0, nv, ef);\n             RedisModule_Assert(newnode !\u003d NULL);\n-        } else {\n-            newnode-\u003evalue \u003d nv;\n         }\n         RedisModule_DictSet(vset-\u003edict,val,newnode);\n         val \u003d NULL; // Don\u0027t free it later.\ndiff --git a/w2v.c b/w2v.c\nindex a8b21dc..8d7614d 100644\n--- a/w2v.c\n+++ b/w2v.c\n@@ -344,8 +344,8 @@ void *threaded_insert(void *ctxptr) {\n         // applies the check if the graph wasn\u0027t modified.\n         InsertContext *ic;\n         uint64_t next_id \u003d ctx-\u003eid++;\n-        ic \u003d hnsw_prepare_insert(ctx-\u003eindex, v, NULL, 0, next_id, word, 200);\n-        if (hnsw_try_commit_insert(ctx-\u003eindex, ic) \u003d\u003d NULL) {\n+        ic \u003d hnsw_prepare_insert(ctx-\u003eindex, v, NULL, 0, next_id, 200);\n+        if (hnsw_try_commit_insert(ctx-\u003eindex, ic, word) \u003d\u003d NULL) {\n             // This time try locking since the start.\n             hnsw_insert(ctx-\u003eindex, v, NULL, 0, next_id, word, 200);\n         }","expectedMessage":"Make HNSW CAS commit atomic.","repository":"redis-antirez","commitHash":"29c27bc13ee27add0c0376aec45cace80c289162","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-c61c535c","diff":" Makefile | 4 ++--\n vset.c   | 7 ++++++-\n 2 files changed, 8 insertions(+), 3 deletions(-)\n\ndiff --git a/Makefile b/Makefile\nindex ed06980..ff1b45a 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -1,5 +1,5 @@\n # Compiler settings\n-CC \u003d gcc\n+CC \u003d cc\n \n ifdef SANITIZER\n ifeq ($(SANITIZER),address)\n@@ -56,7 +56,7 @@ all: vset.so\n vset.xo: redismodule.h expr.c\n \n vset.so: vset.xo hnsw.xo cJSON.xo\n-\t$(CC) -o $@ $^ $(SHOBJ_LDFLAGS) $(LIBS) -lc\n+\t$(CC) -o $@ $^ $(SHOBJ_LDFLAGS) $(LIBS) $(SAN) -lc\n \n # Example sources / objects\n SRCS \u003d hnsw.c w2v.c\ndiff --git a/vset.c b/vset.c\nindex 42748df..af1026a 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -1852,7 +1852,12 @@ void VectorSetDigest(RedisModuleDigest *md, void *value) {\n \n /* This function must be present on each Redis module. It is used in order to\n  * register the commands into the Redis server. */\n-int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n+#ifdef MERGED_REDIS_MODULE\n+#define ONLOAD VectorSets_OnLoad\n+#else\n+#define ONLOAD RedisModule_OnLoad\n+#endif\n+int ONLOAD(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     REDISMODULE_NOT_USED(argv);\n     REDISMODULE_NOT_USED(argc);\n ","expectedMessage":"Make Redis module merging simpler.","repository":"redis-antirez","commitHash":"c61c535c32ed90f3ae7d8bf74c593688d35181a0","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-2f17e4fb","diff":" vset.c | 31 +++++++++++++++++++++----------\n 1 file changed, 21 insertions(+), 10 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex fea614d..42748df 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -311,7 +311,11 @@ int vectorSetInsert(struct vsetObject *o, float *vec, int8_t *qvec, float qrange\n  * Format: [REDUCE dim] FP32|VALUES ...\n  * Returns allocated vector and sets dimension in *dim.\n  * If reduce_dim is not NULL, sets it to the requested reduction dimension.\n- * Returns NULL on parsing error. */\n+ * Returns NULL on parsing error.\n+ *\n+ * The function sets as a reference *consumed_args, so that the caller\n+ * knows how many arguments we consumed in order to parse the input\n+ * vector. Remaining arguments are often command options. */\n float *parseVector(RedisModuleString **argv, int argc, int start_idx,\n                   size_t *dim, uint32_t *reduce_dim, int *consumed_args)\n {\n@@ -335,22 +339,27 @@ float *parseVector(RedisModuleString **argv, int argc, int start_idx,\n \n     /* Now parse the vector format as before. */\n     float *vec \u003d NULL;\n+    char *vec_format \u003d RedisModule_StringPtrLen(argv[start_idx],NULL);\n \n-    if (!strcasecmp(RedisModule_StringPtrLen(argv[start_idx],NULL),\"FP32\")) {\n+    if (!strcasecmp(vec_format,\"FP32\")) {\n         if (argc \u003c start_idx + 2) return NULL;  // Need FP32 + vector + value.\n         size_t vec_raw_len;\n-        const char *blob \u003d RedisModule_StringPtrLen(argv[start_idx+1],\u0026vec_raw_len);\n+        const char *blob \u003d\n+            RedisModule_StringPtrLen(argv[start_idx+1],\u0026vec_raw_len);\n+\n+        // Must be 4 bytes per component.\n         if (vec_raw_len % 4 || vec_raw_len \u003c 4) return NULL;\n         *dim \u003d vec_raw_len/4;\n+\n         vec \u003d RedisModule_Alloc(vec_raw_len);\n         if (!vec) return NULL;\n         memcpy(vec,blob,vec_raw_len);\n         consumed +\u003d 2;\n-    } else if (!strcasecmp(RedisModule_StringPtrLen(argv[start_idx],NULL),\"VALUES\")) {\n-        if (argc \u003c start_idx + 2) return NULL;  // Need at least dimension..\n-        long long vdim;\n-        if (RedisModule_StringToLongLong(argv[start_idx+1],\u0026vdim) !\u003d REDISMODULE_OK\n-            || vdim \u003c 1) return NULL;\n+    } else if (!strcasecmp(vec_format,\"VALUES\")) {\n+        if (argc \u003c start_idx + 2) return NULL;  // Need at least the dimension.\n+        long long vdim; // Vector dimension passed by the user.\n+        if (RedisModule_StringToLongLong(argv[start_idx+1],\u0026vdim)\n+            !\u003d REDISMODULE_OK || vdim \u003c 1) return NULL;\n \n         // Check that all the arguments are available.\n         if (argc \u003c start_idx + 2 + vdim) return NULL;\n@@ -361,7 +370,9 @@ float *parseVector(RedisModuleString **argv, int argc, int start_idx,\n \n         for (int j \u003d 0; j \u003c vdim; j++) {\n             double val;\n-            if (RedisModule_StringToDouble(argv[start_idx+2+j],\u0026val) !\u003d REDISMODULE_OK) {\n+            if (RedisModule_StringToDouble(argv[start_idx+2+j],\u0026val)\n+                !\u003d REDISMODULE_OK)\n+            {\n                 RedisModule_Free(vec);\n                 return NULL;\n             }\n@@ -369,7 +380,7 @@ float *parseVector(RedisModuleString **argv, int argc, int start_idx,\n         }\n         consumed +\u003d vdim + 2;\n     } else {\n-        return NULL;  // Unknown format\n+        return NULL;  // Unknown format.\n     }\n \n     if (consumed_args) *consumed_args \u003d consumed;","expectedMessage":"Prettify parseVector().","repository":"redis-antirez","commitHash":"2f17e4fb046f32f54c394c05be17330846f99070","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-63057253","diff":" vset.c | 79 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------\n 1 file changed, 68 insertions(+), 11 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex 68933c3..fea614d 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -3,6 +3,60 @@\n  *\n  * Copyright(C) 2024-Present, Redis Ltd. All Rights Reserved.\n  * Originally authored by: Salvatore Sanfilippo.\n+ *\n+ * \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d Understand threading model \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n+ * This code implements threaded operarations for two of the commands:\n+ *\n+ * 1. VSIM, by default.\n+ * 2. VADD, if the CAS option is specified.\n+ *\n+ * Note that even if the second operation, VADD, is a write operation, only\n+ * the neighbors collection for the new node is performed in a thread: then,\n+ * the actual insert is performed in the reply callback VADD_CASReply(),\n+ * which is executed in the main thread.\n+ *\n+ * Threaded operations need us to protect various operations with mutexes,\n+ * even if a certain degree of protection is already provided by the HNSW\n+ * library. Here are a few very important things about this implementation\n+ * and the way locking is performed.\n+ *\n+ * 1. All the write operations are performed in the main Redis thread:\n+ *    this also include VADD_CASReply() callback, that is called by Redis\n+ *    internals only in the context of the main thread. However the HNSW\n+ *    library allows background threads in hnsw_search() (VSIM) to modify\n+ *    nodes metadata to speedup search (to understand if a node was already\n+ *    visited), but this only happens after acquiring a specific lock\n+ *    for a given \"read slot\".\n+ *\n+ * 2. We use a global lock for each Vector Set object, called \"in_use\". This\n+ *    lock is a read-write lock, and is acquired in read mode by all the\n+ *    threads that perform reads in the background. It is only acquired in\n+ *    write mode by vectorSetWaitAllBackgroundClients(): the function acquires\n+ *    the lock and immediately releases it, with the effect of waiting all the\n+ *    background threads still running from ending their execution.\n+ *\n+ *    Note that no ther thread can be spawned, since we only call\n+ *    vectorSetWaitAllBackgroundClients() from the main Redis thread, that\n+ *    is also the only thread spawning other threads.\n+ *\n+ *    vectorSetWaitAllBackgroundClients() is used in two ways:\n+ *    A) When we need to delete a vector set because of (DEL) or other\n+ *       operations destroying the object, we need to wait that all the\n+ *       background threads working with this object finished their work.\n+ *    B) When we modify the HNSW nodes bypassing the normal locking\n+ *       provided by the HNSW library. This only happens when we update\n+ *       an existing node attribute so far, in VSETATTR and when we call\n+ *       VADD to update a node with the SETATTR option.\n+ *\n+ *  3. Often during read operations performed by Redis commands in the\n+ *     main thread (VCARD, VEMB, VRANDMEMBER, ...) we don\u0027t acquire any\n+ *     lock at all. The commands run in the main Redis thread, we can only\n+ *     have, at the same time, background reads against the same data\n+ *     structure. Note that VSIM_thread() and VADD_thread() still modify the\n+ *     read slot metadata, that is node-\u003evisited_epoch[slot], but as long as\n+ *     our read commands running in the main thread don\u0027t need to use\n+ *     hnsw_search() or other HNSW functions using the visited epochs slots\n+ *     we are safe.\n  */\n \n #define _DEFAULT_SOURCE\n@@ -240,9 +294,9 @@ int vectorSetInsert(struct vsetObject *o, float *vec, int8_t *qvec, float qrange\n     nv-\u003eattrib \u003d attrib;\n     node \u003d hnsw_insert(o-\u003ehnsw,vec,qvec,qrange,0,nv,ef);\n     if (node \u003d\u003d NULL) {\n-        // XXX Technically in Redis-land we don\u0027t have out of memories as we\n-        // crash. However the HNSW library may fail for error in the locking\n-        // libc call. Probably impossible in practical terms.\n+        // XXX Technically in Redis-land we don\u0027t have out of memory, as we\n+        // crash on OOM. However the HNSW library may fail for error in the\n+        // locking libc call. Probably impossible in practical terms.\n         RedisModule_Free(nv);\n         return 0;\n     }\n@@ -261,26 +315,29 @@ int vectorSetInsert(struct vsetObject *o, float *vec, int8_t *qvec, float qrange\n float *parseVector(RedisModuleString **argv, int argc, int start_idx,\n                   size_t *dim, uint32_t *reduce_dim, int *consumed_args)\n {\n-    int consumed \u003d 0; // Argumnets consumed\n+    int consumed \u003d 0; // Argumnets consumed.\n \n-    /* Check for REDUCE option first */\n+    /* Check for REDUCE option first. */\n     if (reduce_dim) *reduce_dim \u003d 0;\n     if (reduce_dim \u0026\u0026 argc \u003e start_idx + 2 \u0026\u0026\n         !strcasecmp(RedisModule_StringPtrLen(argv[start_idx],NULL),\"REDUCE\"))\n     {\n         long long rdim;\n-        if (RedisModule_StringToLongLong(argv[start_idx+1],\u0026rdim) !\u003d REDISMODULE_OK\n-            || rdim \u003c\u003d 0) return NULL;\n+        if (RedisModule_StringToLongLong(argv[start_idx+1],\u0026rdim)\n+            !\u003d REDISMODULE_OK || rdim \u003c\u003d 0)\n+        {\n+            return NULL;\n+        }\n         if (reduce_dim) *reduce_dim \u003d rdim;\n-        start_idx +\u003d 2;  // Skip REDUCE and its argument\n+        start_idx +\u003d 2;  // Skip REDUCE and its argument.\n         consumed +\u003d 2;\n     }\n \n-    /* Now parse the vector format as before */\n+    /* Now parse the vector format as before. */\n     float *vec \u003d NULL;\n \n     if (!strcasecmp(RedisModule_StringPtrLen(argv[start_idx],NULL),\"FP32\")) {\n-        if (argc \u003c start_idx + 2) return NULL;  // Need FP32 + vector + value\n+        if (argc \u003c start_idx + 2) return NULL;  // Need FP32 + vector + value.\n         size_t vec_raw_len;\n         const char *blob \u003d RedisModule_StringPtrLen(argv[start_idx+1],\u0026vec_raw_len);\n         if (vec_raw_len % 4 || vec_raw_len \u003c 4) return NULL;\n@@ -290,7 +347,7 @@ float *parseVector(RedisModuleString **argv, int argc, int start_idx,\n         memcpy(vec,blob,vec_raw_len);\n         consumed +\u003d 2;\n     } else if (!strcasecmp(RedisModule_StringPtrLen(argv[start_idx],NULL),\"VALUES\")) {\n-        if (argc \u003c start_idx + 2) return NULL;  // Need at least dimension.\n+        if (argc \u003c start_idx + 2) return NULL;  // Need at least dimension..\n         long long vdim;\n         if (RedisModule_StringToLongLong(argv[start_idx+1],\u0026vdim) !\u003d REDISMODULE_OK\n             || vdim \u003c 1) return NULL;","expectedMessage":"Document threading model in a top comment.","repository":"redis-antirez","commitHash":"63057253d84d0efb381992fd6ffcf4def6da9af0","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-3d31fc3b","diff":" vset.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex 33ffb8b..68933c3 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -706,8 +706,6 @@ void VSIM_execute(RedisModuleCtx *ctx, struct vsetObject *vset,\n                         filter_expr, filter_ef);\n         }\n     }\n-    hnsw_release_read_slot(vset-\u003ehnsw,slot);\n-    RedisModule_Free(vec);\n \n     /* Return results */\n     if (withscores)\n@@ -726,12 +724,14 @@ void VSIM_execute(RedisModuleCtx *ctx, struct vsetObject *vset,\n             RedisModule_ReplyWithDouble(ctx, 1.0 - distances[i]/2.0);\n         }\n     }\n+    hnsw_release_read_slot(vset-\u003ehnsw,slot);\n \n     if (withscores)\n         RedisModule_ReplySetMapLength(ctx, arraylen);\n     else\n         RedisModule_ReplySetArrayLength(ctx, arraylen);\n \n+    RedisModule_Free(vec);\n     RedisModule_Free(neighbors);\n     RedisModule_Free(distances);\n     if (filter_expr) exprFree(filter_expr);","expectedMessage":"VSIM thread: manipulate results while still locked.","repository":"redis-antirez","commitHash":"3d31fc3bee6709dc272fe6b0c8aca9a9907f7f64","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-f70dc8ac","diff":" vset.c | 9 ++++++++-\n 1 file changed, 8 insertions(+), 1 deletion(-)\n\ndiff --git a/vset.c b/vset.c\nindex f53e20d..33ffb8b 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -1501,7 +1501,14 @@ int VRANDMEMBER_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int\n             RedisModule_FreeDict(ctx, returned);\n         } else {\n             /* For large samples, get a random starting node and walk\n-             * the list. */\n+             * the list.\n+             *\n+             * IMPORTANT: doing so does not really generate random\n+             * elements: it\u0027s just a linear scan, but we have no choices.\n+             * If we generate too many random elements, more and more would\n+             * fail the check of being novel (not yet collected in the set\n+             * to return) if the % of elements to emit is too large, we would\n+             * spend too much CPU. */\n             hnswNode *start_node \u003d hnsw_random_node(vset-\u003ehnsw, 0);\n             hnswNode *current \u003d start_node;\n ","expectedMessage":"Clarify VRANDMEMBER tradeoff.","repository":"redis-antirez","commitHash":"f70dc8acb242a17a844843d022c77be99825da59","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-9180659f","diff":" vset.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex e18cae9..f53e20d 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -1574,7 +1574,9 @@ void VectorSetRdbSave(RedisModuleIO *rdb, void *value) {\n     }\n }\n \n-/* Load object from RDB */\n+/* Load object from RDB. Please note that we don\u0027t do any cleanup\n+ * on errors, and just return NULL, as Redis will abort completely\n+ * not just the module but the server itself in this case. */\n void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n     if (encver !\u003d 0) return NULL;  // Invalid version\n \n@@ -1647,7 +1649,7 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n         if (node \u003d\u003d NULL) {\n             RedisModule_LogIOError(rdb,\"warning\",\n                                        \"Vector set node index loading error\");\n-            return NULL; // Loading error: abort, no need to free resources.\n+            return NULL; // Loading error.\n         }\n         if (nv-\u003eattrib) vset-\u003enumattribs++;\n         RedisModule_DictSet(vset-\u003edict,ele,node);","expectedMessage":"Clarify failure behaior of VectorSetRdbLoad().","repository":"redis-antirez","commitHash":"9180659f8b80fb843edfe6c7bc5abba0bd935ef1","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-c2d80e8c","diff":" vset.c | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/vset.c b/vset.c\nindex a6544d8..e18cae9 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -407,6 +407,9 @@ int VADD_CASReply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         if (ic \u003d\u003d NULL ||\n             (newnode \u003d hnsw_try_commit_insert(vset-\u003ehnsw, ic)) \u003d\u003d NULL)\n         {\n+            /* If we are here, the CAS insert failed. We need to insert\n+             * again with full locking for neighbors selection and\n+             * actual insertion. This time we can\u0027t fail: */\n             newnode \u003d hnsw_insert(vset-\u003ehnsw, vec, NULL, 0, 0, nv, ef);\n             RedisModule_Assert(newnode !\u003d NULL);\n         } else {","expectedMessage":"Clarify that if CAS fails we insert blocking.","repository":"redis-antirez","commitHash":"c2d80e8ced20bd24611dcb436e77a1ae1b694ce3","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-e3243819","diff":" vset.c | 31 +++++++++++++++++++++----------\n 1 file changed, 21 insertions(+), 10 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex 4197ef5..a6544d8 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -167,6 +167,14 @@ void vectorSetReleaseObject(struct vsetObject *o) {\n     RedisModule_Free(o);\n }\n \n+/* Wait for all the threads performing operations on this\n+ * index to terminate their work (locking for write will\n+ * wait for all the other threads). */\n+void vectorSetWaitAllBackgroundClients(struct vsetObject *vset) {\n+    RedisModule_Assert(pthread_rwlock_wrlock(\u0026vset-\u003ein_use_lock) \u003d\u003d 0);\n+    pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n+}\n+\n /* Return a string representing the quantization type name of a vector set. */\n const char *vectorSetGetQuantName(struct vsetObject *o) {\n     switch(o-\u003ehnsw-\u003equant_type) {\n@@ -187,6 +195,11 @@ int vectorSetInsert(struct vsetObject *o, float *vec, int8_t *qvec, float qrange\n     hnswNode *node \u003d RedisModule_DictGet(o-\u003edict,val,NULL);\n     if (node !\u003d NULL) {\n         if (update) {\n+            /* Wait for clients in the background: background VSIM\n+             * operations touch the nodes attributes we are going\n+             * to touch. */\n+            vectorSetWaitAllBackgroundClients(o);\n+\n             struct vsetNodeVal *nv \u003d node-\u003evalue;\n             /* Pass NULL as value-free function. We want to reuse\n              * the old value. */\n@@ -333,7 +346,9 @@ void *VADD_thread(void *arg) {\n     return NULL;\n }\n \n-/* Reply callback for CAS variant of VADD. */\n+/* Reply callback for CAS variant of VADD.\n+ * Note: this is called in the main thread, in the background thread\n+ * we just do the read operation of gathering the neighbors. */\n int VADD_CASReply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     (void)argc;\n     RedisModule_AutoMemory(ctx); /* Use automatic memory management. */\n@@ -1171,6 +1186,10 @@ int VSETATTR_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int arg\n     struct vsetNodeVal *nv \u003d node-\u003evalue;\n     RedisModuleString *new_attr \u003d argv[3];\n \n+    /* Background VSIM operations use the node attributes, so\n+     * wait for background operations before messing with them. */\n+    vectorSetWaitAllBackgroundClients(vset);\n+\n     /* Set or delete the attribute based on the fact it\u0027s an empty\n      * string or not. */\n     size_t attrlen;\n@@ -1718,15 +1737,7 @@ size_t VectorSetMemUsage(const void *value) {\n void VectorSetFree(void *value) {\n     struct vsetObject *vset \u003d value;\n \n-    // Wait for all the threads performing operations on this\n-    // index to terminate their work (locking for write will\n-    // wait for all the other threads).\n-    RedisModule_Assert(pthread_rwlock_wrlock(\u0026vset-\u003ein_use_lock) \u003d\u003d 0);\n-\n-    // This lock is managed only in the main thread, so we can\n-    // unlock it now, to be able to destroy the mutex later\n-    // in vectorSetReleaseObject().\n-    pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n+    vectorSetWaitAllBackgroundClients(vset);\n     vectorSetReleaseObject(value);\n }\n ","expectedMessage":"Don\u0027t mess with node attributes without protection.","repository":"redis-antirez","commitHash":"e3243819ef980b4379b11f7f8d93c7d8746e4b3c","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-a6c8a15c","diff":" vset.c | 7 +++++--\n 1 file changed, 5 insertions(+), 2 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex 1bf2120..4197ef5 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -617,6 +617,8 @@ int VADD_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n             pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n             RedisModule_AbortBlock(bc);\n             RedisModule_Free(targ);\n+            RedisModule_FreeString(ctx,val);\n+            if (attrib) RedisModule_FreeString(ctx,attrib);\n \n             // Fall back to synchronous insert, see later in the code.\n         } else {\n@@ -1561,7 +1563,8 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n     uint32_t hnsw_m \u003d (hnsw_config \u003e\u003e 8) \u0026 0xffff;\n \n     if (hnsw_m \u003d\u003d 0) hnsw_m \u003d 16; // Default, useful for RDB files predating\n-                                  // this configuration parameter.\n+                                  // this configuration parameter: it was fixed\n+                                  // to 16.\n     struct vsetObject *vset \u003d createVectorSetObject(dim,quant_type,hnsw_m);\n     RedisModule_Assert(vset !\u003d NULL);\n \n@@ -1622,7 +1625,7 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n         if (node \u003d\u003d NULL) {\n             RedisModule_LogIOError(rdb,\"warning\",\n                                        \"Vector set node index loading error\");\n-            return NULL; // Loading error.\n+            return NULL; // Loading error: abort, no need to free resources.\n         }\n         if (nv-\u003eattrib) vset-\u003enumattribs++;\n         RedisModule_DictSet(vset-\u003edict,ele,node);","expectedMessage":"VADD: fix leak on thread creation failure.","repository":"redis-antirez","commitHash":"a6c8a15cad7e759bd4391316eae25f5bc6b077c7","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-3e2649f1","diff":" vset.c | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/vset.c b/vset.c\nindex 0f160de..1bf2120 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -192,6 +192,7 @@ int vectorSetInsert(struct vsetObject *o, float *vec, int8_t *qvec, float qrange\n              * the old value. */\n             hnsw_delete_node(o-\u003ehnsw, node, NULL);\n             node \u003d hnsw_insert(o-\u003ehnsw,vec,qvec,qrange,0,nv,ef);\n+            RedisModule_Assert(node !\u003d NULL);\n             RedisModule_DictReplace(o-\u003edict,val,node);\n \n             /* If attrib !\u003d NULL, the user wants that in case of an update we\n@@ -392,6 +393,7 @@ int VADD_CASReply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n             (newnode \u003d hnsw_try_commit_insert(vset-\u003ehnsw, ic)) \u003d\u003d NULL)\n         {\n             newnode \u003d hnsw_insert(vset-\u003ehnsw, vec, NULL, 0, 0, nv, ef);\n+            RedisModule_Assert(newnode !\u003d NULL);\n         } else {\n             newnode-\u003evalue \u003d nv;\n         }","expectedMessage":"hnsw_insert() should never fail in practice.","repository":"redis-antirez","commitHash":"3e2649f1f1e7aad329493657b79ea9e93a1437fb","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-8dfc501f","diff":" vset.c | 1 -\n 1 file changed, 1 deletion(-)\n\ndiff --git a/vset.c b/vset.c\nindex ce0a3b1..0f160de 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -970,7 +970,6 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         if (pthread_create(\u0026tid,NULL,VSIM_thread,targ) !\u003d 0) {\n             pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n             RedisModule_AbortBlock(bc);\n-            RedisModule_Free(vec);\n             RedisModule_Free(targ[4]);\n             RedisModule_Free(targ);\n             VSIM_execute(ctx, vset, vec, count, epsilon, withscores, ef, filter_expr, filter_ef, ground_truth);","expectedMessage":"VSIM: fix double free if thread creation fails.","repository":"redis-antirez","commitHash":"8dfc501fb81b740d3623d0fa99ab52d1ca923ed6","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-9d4325ee","diff":" README.md |  4 +++-\n vset.c    | 13 +++++++++----\n 2 files changed, 12 insertions(+), 5 deletions(-)\n\ndiff --git a/README.md b/README.md\nindex 9df9c1d..b496f3f 100644\n--- a/README.md\n+++ b/README.md\n@@ -62,7 +62,7 @@ performed in the background, while the command is executed in the main thread.\n \n **VSIM: return elements by vector similarity**\n \n-    VSIM key [ELE|FP32|VALUES] \u003cvector or element\u003e [WITHSCORES] [COUNT num] [EF search-exploration-factor] [FILTER expression] [FILTER-EF max-filtering-effort] [TRUTH]\n+    VSIM key [ELE|FP32|VALUES] \u003cvector or element\u003e [WITHSCORES] [COUNT num] [EF search-exploration-factor] [FILTER expression] [FILTER-EF max-filtering-effort] [TRUTH] [NOTHREAD]\n \n The command returns similar vectors, for simplicity (and verbosity) in the following example, instead of providing a vector using FP32 or VALUES (like in `VADD`), we will ask for elements having a vector similar to a given element already in the sorted set:\n \n@@ -92,6 +92,8 @@ The `EF` argument is the exploration factor: the higher it is, the slower the co\n \n The `TRUTH` option forces the command to perform a linear scan of all the entries inside the set, without using the graph search inside the HNSW, so it returns the best matching elements (the perfect result set) that can be used in order to easily calculate the recall. Of course the linear scan is `O(N)`, so it is much slower than the `log(N)` (considering a small `COUNT`) provided by the HNSW index.\n \n+The `NOTHREAD` option forces the command to execute the search on the data structure in the main thread. Normally `VSIM` spawns a thread instead. This may be useful for benchmarking purposes, or when we work with extremely small vector sets and don\u0027t want to pay the cost of spawning a thread. It is possible that in the future this option will be automatically used by Redis when we detect small vector sets. Note that this option blocks the server for all the time needed to complete the command, so it is a source of potential latency issues: if you are in doubt, never use it.\n+\n For `FILTER` and `FILTER-EF` options, please check the filtered search section of this documentation.\n \n **VDIM: return the dimension of the vectors inside the vector set**\ndiff --git a/vset.c b/vset.c\nindex 077e637..ce0a3b1 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -762,6 +762,7 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     long long ef \u003d 0;       /* Exploration factor (see HNSW paper) */\n     double epsilon \u003d 2.0;   /* Max cosine distance */\n     long long ground_truth \u003d 0; /* Linear scan instead of HNSW search? */\n+    int no_thread \u003d 0;       /* NOTHREAD option: exec on main thread. */\n \n     /* Things computed later. */\n     long long filter_ef \u003d 0;\n@@ -862,6 +863,9 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         } else if (!strcasecmp(opt, \"TRUTH\")) {\n             ground_truth \u003d 1;\n             j++;\n+        } else if (!strcasecmp(opt, \"NOTHREAD\")) {\n+            no_thread \u003d 1;\n+            j++;\n         } else if (!strcasecmp(opt, \"COUNT\") \u0026\u0026 j+1 \u003c argc) {\n             if (RedisModule_StringToLongLong(argv[j+1], \u0026count)\n                 !\u003d REDISMODULE_OK || count \u003c\u003d 0)\n@@ -918,10 +922,11 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     int threaded_request \u003d 1; // Run on a thread, by default.\n     if (filter_ef \u003d\u003d 0) filter_ef \u003d count * 100; // Max filter visited nodes.\n \n-    // Disable threaded for MULTI/EXEC and Lua.\n-    if (RedisModule_GetContextFlags(ctx) \u0026\n-             (REDISMODULE_CTX_FLAGS_LUA|\n-             REDISMODULE_CTX_FLAGS_MULTI))\n+    /* Disable threaded for MULTI/EXEC and Lua, or if explicitly\n+     * requsted by the user via the NOTHREAD option. */\n+    if (no_thread || (RedisModule_GetContextFlags(ctx) \u0026\n+                      (REDISMODULE_CTX_FLAGS_LUA|\n+                       REDISMODULE_CTX_FLAGS_MULTI)))\n     {\n         threaded_request \u003d 0;\n     }","expectedMessage":"VSIM NOTHREAD, mainly for testing goals.","repository":"redis-antirez","commitHash":"9d4325ee2548f410a322ec18feaf612611f5469d","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-707c1323","diff":" vset.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\ndiff --git a/vset.c b/vset.c\nindex 1b0bffb..077e637 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -327,6 +327,7 @@ void *VADD_thread(void *arg) {\n \n     /* Unblock the client so that our read reply will be invoked. */\n     pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n+    RedisModule_BlockedClientMeasureTimeEnd(bc);\n     RedisModule_UnblockClient(bc,targ); // Use targ as privdata.\n     return NULL;\n }\n@@ -609,6 +610,7 @@ int VADD_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         targ[7] \u003d attrib;\n         RedisModule_RetainString(ctx,val);\n         if (attrib) RedisModule_RetainString(ctx,attrib);\n+        RedisModule_BlockedClientMeasureTimeStart(bc);\n         if (pthread_create(\u0026tid,NULL,VADD_thread,targ) !\u003d 0) {\n             pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n             RedisModule_AbortBlock(bc);\n@@ -741,6 +743,7 @@ void *VSIM_thread(void *arg) {\n     // Cleanup.\n     RedisModule_FreeThreadSafeContext(ctx);\n     pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n+    RedisModule_BlockedClientMeasureTimeEnd(bc);\n     RedisModule_UnblockClient(bc,NULL);\n     return NULL;\n }\n@@ -958,6 +961,7 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         targ[7] \u003d (void*)filter_expr;\n         targ[8] \u003d (void*)(unsigned long)filter_ef;\n         targ[9] \u003d (void*)(unsigned long)ground_truth;\n+        RedisModule_BlockedClientMeasureTimeStart(bc);\n         if (pthread_create(\u0026tid,NULL,VSIM_thread,targ) !\u003d 0) {\n             pthread_rwlock_unlock(\u0026vset-\u003ein_use_lock);\n             RedisModule_AbortBlock(bc);","expectedMessage":"Count threaded exec time in stats.","repository":"redis-antirez","commitHash":"707c13239232b65d0584b44902a2968a29136187","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-08e3f958","diff":" README.md | 1 -\n 1 file changed, 1 deletion(-)\n\ndiff --git a/README.md b/README.md\nindex bf08507..9df9c1d 100644\n--- a/README.md\n+++ b/README.md\n@@ -562,7 +562,6 @@ Switching from `VALUES` to `FP32` as a method for transmitting vectors may easil\n \n # Known bugs\n \n-* When `VADD` with `REDUCE` is replicated, we should probably send the replicas the random matrix, in order for `VEMB` to read the same things. This is not critical, because the behavior of `VADD` / `VSIM` should be transparent if you don\u0027t look at the transformed vectors, but still probably worth doing.\n * Replication code is pretty much untested, and very vanilla (replicating the commands verbatim).\n \n # Implementation details","expectedMessage":"README: remove no longer valid RP issue.","repository":"redis-antirez","commitHash":"08e3f958fa8641f7e3b8712aae221ebbaca56d1b","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-23b3e218","diff":" README.md | 11 +++++++++++\n 1 file changed, 11 insertions(+)\n\ndiff --git a/README.md b/README.md\nindex f93b494..bf08507 100644\n--- a/README.md\n+++ b/README.md\n@@ -537,6 +537,8 @@ Vector Sets, or better, HNSWs, the underlying data structure used by Vector Sets\n \n # Vector Sets troubleshooting and understandability\n \n+## Debugging poor recall or unexpected results\n+\n Vector graphs and similarity queries pose many challenges mainly due to the following three problems:\n \n 1. The error due to the approximated nature of Vector Sets is hard to evaluate.\n@@ -549,6 +551,15 @@ The only way to debug such problems, is the ability to inspect step by step what\n 2. The `VLINKS` command allows to explore the graph to see if the connections among nodes make sense, and to investigate why a given node may be more isolated than expected. Such command can also be used in a different way, when we want very fast \"similar items\" without paying the HNSW traversal time. It exploits the fact that we have a direct reference from each element in our vector set to each node in our HNSW graph.\n 3. The `WITHSCORES` option, in the supported commands, return a value that is directly related to the *cosine similarity* between the query and the items vectors, the interval of the similarity is simply rescaled from the -1, 1 original range to 0, 1, otherwise the metric is identical.\n \n+## Clients, latency and bandwidth usage\n+\n+During Vector Sets testing, we discovered that often clients introduce considerable latecy and CPU usage (in the client side, not in Redis) for two main reasons:\n+\n+1. Often the serialization to `VALUES ... list of floats ...` can be very slow.\n+2. The vector payload of floats represented as strings is very large, resulting in high bandwidth usage and latency, compared to other Redis commands.\n+\n+Switching from `VALUES` to `FP32` as a method for transmitting vectors may easily provide 10-20x speedups.\n+\n # Known bugs\n \n * When `VADD` with `REDUCE` is replicated, we should probably send the replicas the random matrix, in order for `VEMB` to read the same things. This is not critical, because the behavior of `VADD` / `VSIM` should be transparent if you don\u0027t look at the transformed vectors, but still probably worth doing.","expectedMessage":"README: suggest using FP32 vs VALUES.","repository":"redis-antirez","commitHash":"23b3e2181704e77a35c3b951ff741e5b4aec61b8","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-16e3c5a8","diff":" hnsw.c | 16 ++++++++++++----\n hnsw.h |  2 +-\n vset.c | 20 ++++++++++++--------\n 3 files changed, 25 insertions(+), 13 deletions(-)\n\ndiff --git a/hnsw.c b/hnsw.c\nindex a0a918d..e0ea97c 100644\n--- a/hnsw.c\n+++ b/hnsw.c\n@@ -1555,9 +1555,12 @@ void hnsw_unlink_node(HNSW *index, hnswNode *node) {\n  * This will get the write lock, will delete the node, free it,\n  * reconnect the node neighbors among themselves, and unlock again.\n  * If free_value function pointer is not NULL, then the function provided is\n- * used to free node-\u003evalue. */\n-void hnsw_delete_node(HNSW *index, hnswNode *node, void(*free_value)(void*value)) {\n-    pthread_rwlock_wrlock(\u0026index-\u003eglobal_lock);\n+ * used to free node-\u003evalue.\n+ *\n+ * The function returns 0 on error (inability to acquire the lock), otherwise\n+ * 1 is returned. */\n+int hnsw_delete_node(HNSW *index, hnswNode *node, void(*free_value)(void*value)) {\n+    if (pthread_rwlock_wrlock(\u0026index-\u003eglobal_lock) !\u003d 0) return 0;\n     hnsw_unlink_node(index,node);\n     if (free_value \u0026\u0026 node-\u003evalue) free_value(node-\u003evalue);\n \n@@ -1569,6 +1572,7 @@ void hnsw_delete_node(HNSW *index, hnswNode *node, void(*free_value)(void*value)\n     }\n     hnsw_node_free(node);\n     pthread_rwlock_unlock(\u0026index-\u003eglobal_lock);\n+    return 1;\n }\n \n /* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d Threaded API \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n@@ -2299,7 +2303,11 @@ hnswCursor *hnsw_cursor_init(HNSW *index) {\n /* Free the cursor. Can be called both at the end of the iteration, when\n  * hnsw_cursor_next() returned NULL, or before. */\n void hnsw_cursor_free(hnswCursor *cursor) {\n-    pthread_rwlock_wrlock(\u0026cursor-\u003eindex-\u003eglobal_lock); // Best effort.\n+    if (pthread_rwlock_wrlock(\u0026cursor-\u003eindex-\u003eglobal_lock) !\u003d 0) {\n+        // No easy way to recover from that. We will leak memory.\n+        return;\n+    }\n+\n     hnswCursor *x \u003d cursor-\u003eindex-\u003ecursors;\n     hnswCursor *prev \u003d NULL;\n     while(x) {\ndiff --git a/hnsw.h b/hnsw.h\nindex 14da597..deaa671 100644\n--- a/hnsw.h\n+++ b/hnsw.h\n@@ -136,7 +136,7 @@ int hnsw_search_with_filter\n                 int (*filter_callback)(void *value, void *privdata),\n                 void *filter_privdata, uint32_t max_candidates);\n void hnsw_get_node_vector(HNSW *index, hnswNode *node, float *vec);\n-void hnsw_delete_node(HNSW *index, hnswNode *node, void(*free_value)(void*value));\n+int hnsw_delete_node(HNSW *index, hnswNode *node, void(*free_value)(void*value));\n hnswNode *hnsw_random_node(HNSW *index, int slot);\n \n /* Thread safety functions. */\ndiff --git a/vset.c b/vset.c\nindex 4100545..1b0bffb 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -146,7 +146,7 @@ struct vsetObject *createVectorSetObject(unsigned int dim, uint32_t quant_type,\n     o-\u003eproj_matrix \u003d NULL;\n     o-\u003eproj_input_size \u003d 0;\n     o-\u003enumattribs \u003d 0;\n-    pthread_rwlock_init(\u0026o-\u003ein_use_lock,NULL);\n+    RedisModule_Assert(pthread_rwlock_init(\u0026o-\u003ein_use_lock,NULL) \u003d\u003d 0);\n     return o;\n }\n \n@@ -228,7 +228,7 @@ int vectorSetInsert(struct vsetObject *o, float *vec, int8_t *qvec, float qrange\n     if (node \u003d\u003d NULL) {\n         // XXX Technically in Redis-land we don\u0027t have out of memories as we\n         // crash. However the HNSW library may fail for error in the locking\n-        // libc call. There is understand if this may actually happen or not.\n+        // libc call. Probably impossible in practical terms.\n         RedisModule_Free(nv);\n         return 0;\n     }\n@@ -383,9 +383,13 @@ int VADD_CASReply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n         nv-\u003eitem \u003d val;\n         nv-\u003eattrib \u003d attrib;\n \n-        // Then: insert the node in the HNSW data structure.\n+        /* Then: insert the node in the HNSW data structure. Note that\n+         * \u0027ic\u0027 could be NULL in case hnsw_prepare_insert() failed because of\n+         * locking failure (likely impossible in practical terms). */\n         hnswNode *newnode;\n-        if ((newnode \u003d hnsw_try_commit_insert(vset-\u003ehnsw, ic)) \u003d\u003d NULL) {\n+        if (ic \u003d\u003d NULL ||\n+            (newnode \u003d hnsw_try_commit_insert(vset-\u003ehnsw, ic)) \u003d\u003d NULL)\n+        {\n             newnode \u003d hnsw_insert(vset-\u003ehnsw, vec, NULL, 0, 0, nv, ef);\n         } else {\n             newnode-\u003evalue \u003d nv;\n@@ -590,7 +594,7 @@ int VADD_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     if (cas) {\n         /* Make sure the key does not get deleted during the background\n          * operation. See VSIM implementation for more information. */\n-        pthread_rwlock_rdlock(\u0026vset-\u003ein_use_lock);\n+        RedisModule_Assert(pthread_rwlock_rdlock(\u0026vset-\u003ein_use_lock) \u003d\u003d 0);\n \n         RedisModuleBlockedClient *bc \u003d RedisModule_BlockClient(ctx,VADD_CASReply,NULL,NULL,0);\n         pthread_t tid;\n@@ -938,7 +942,7 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n          * every node will use more memory). This means that while this request\n          * is threaded, and will NOT block Redis, it may end waiting for a\n          * free slot if all the HNSW_MAX_THREADS slots are used. */\n-        pthread_rwlock_rdlock(\u0026vset-\u003ein_use_lock);\n+        RedisModule_Assert(pthread_rwlock_rdlock(\u0026vset-\u003ein_use_lock) \u003d\u003d 0);\n \n         RedisModuleBlockedClient *bc \u003d RedisModule_BlockClient(ctx,NULL,NULL,NULL,0);\n         pthread_t tid;\n@@ -1049,7 +1053,7 @@ int VREM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n      * free function since the strings were retained at insertion time. */\n     struct vsetNodeVal *nv \u003d node-\u003evalue;\n     if (nv-\u003eattrib !\u003d NULL) vset-\u003enumattribs--;\n-    hnsw_delete_node(vset-\u003ehnsw, node, vectorSetReleaseNodeValue);\n+    RedisModule_Assert(hnsw_delete_node(vset-\u003ehnsw, node, vectorSetReleaseNodeValue) \u003d\u003d 1);\n \n     /* Destroy empty vector set. */\n     if (RedisModule_DictSize(vset-\u003edict) \u003d\u003d 0) {\n@@ -1704,7 +1708,7 @@ void VectorSetFree(void *value) {\n     // Wait for all the threads performing operations on this\n     // index to terminate their work (locking for write will\n     // wait for all the other threads).\n-    pthread_rwlock_wrlock(\u0026vset-\u003ein_use_lock);\n+    RedisModule_Assert(pthread_rwlock_wrlock(\u0026vset-\u003ein_use_lock) \u003d\u003d 0);\n \n     // This lock is managed only in the main thread, so we can\n     // unlock it now, to be able to destroy the mutex later","expectedMessage":"Locks error checking improved.","repository":"redis-antirez","commitHash":"16e3c5a8f9aacab2ef5e94988a91373369783753","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-adfd2dc7","diff":" vset.c | 26 +++++++++++++-------------\n 1 file changed, 13 insertions(+), 13 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex d2251da..4100545 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -64,7 +64,8 @@ struct vsetNodeVal {\n };\n \n /* Count the number of set bits in an integer (population count/Hamming weight).\n- * This is a portable implementation that doesn\u0027t rely on compiler extensions. */\n+ * This is a portable implementation that doesn\u0027t rely on compiler\n+ * extensions. */\n static inline uint32_t bit_count(uint32_t n) {\n     uint32_t count \u003d 0;\n     while (n) {\n@@ -109,16 +110,14 @@ float *createProjectionMatrix(uint32_t input_dim, uint32_t output_dim) {\n             matrix[pos] \u003d value * scale;\n         }\n     }\n-\n     return matrix;\n }\n \n-/* Apply random projection to input vector. Returns new allocated vector or NULL. */\n+/* Apply random projection to input vector. Returns new allocated vector. */\n float *applyProjection(const float *input, const float *proj_matrix,\n                       uint32_t input_dim, uint32_t output_dim)\n {\n     float *output \u003d RedisModule_Alloc(sizeof(float) * output_dim);\n-    if (!output) return NULL;\n \n     for (uint32_t i \u003d 0; i \u003c output_dim; i++) {\n         const float *row \u003d \u0026proj_matrix[i * input_dim];\n@@ -135,22 +134,15 @@ float *applyProjection(const float *input, const float *proj_matrix,\n struct vsetObject *createVectorSetObject(unsigned int dim, uint32_t quant_type, uint32_t hnsw_M) {\n     struct vsetObject *o;\n     o \u003d RedisModule_Alloc(sizeof(*o));\n-    if (!o) return NULL;\n \n     o-\u003eid \u003d VectorSetTypeNextId++;\n     o-\u003ehnsw \u003d hnsw_new(dim,quant_type,hnsw_M);\n-    if (!o-\u003ehnsw) {\n+    if (!o-\u003ehnsw) { // May fail because of mutex creation.\n         RedisModule_Free(o);\n         return NULL;\n     }\n \n     o-\u003edict \u003d RedisModule_CreateDict(NULL);\n-    if (!o-\u003edict) {\n-        hnsw_free(o-\u003ehnsw,NULL);\n-        RedisModule_Free(o);\n-        return NULL;\n-    }\n-\n     o-\u003eproj_matrix \u003d NULL;\n     o-\u003eproj_input_size \u003d 0;\n     o-\u003enumattribs \u003d 0;\n@@ -510,6 +502,14 @@ int VADD_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n                   * does not return. It\u0027s also pointless to try try\n                   * doing threaded first elemetn insertion. */\n         vset \u003d createVectorSetObject(reduce_dim ? reduce_dim : dim, quant_type, hnsw_create_M);\n+        if (vset \u003d\u003d NULL) {\n+            // We can\u0027t fail for OOM in Redis, but the mutex initialization\n+            // at least theoretically COULD fail. Likely this code path\n+            // is not reachable in practical terms.\n+            RedisModule_Free(vec);\n+            return RedisModule_ReplyWithError(ctx,\n+                \"ERR unable to create a Vector Set: system resources issue?\");\n+        }\n \n         /* Initialize projection if requested */\n         if (reduce_dim) {\n@@ -1549,7 +1549,7 @@ void *VectorSetRdbLoad(RedisModuleIO *rdb, int encver) {\n     if (hnsw_m \u003d\u003d 0) hnsw_m \u003d 16; // Default, useful for RDB files predating\n                                   // this configuration parameter.\n     struct vsetObject *vset \u003d createVectorSetObject(dim,quant_type,hnsw_m);\n-    if (!vset) return NULL;\n+    RedisModule_Assert(vset !\u003d NULL);\n \n     /* Load projection matrix if present */\n     uint32_t save_flags \u003d RedisModule_LoadUnsigned(rdb);","expectedMessage":"Remove useless OOM checks, but handle mutex creation failure.","repository":"redis-antirez","commitHash":"adfd2dc7c02ba292b1ba745ed871f86a7fe4d348","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-8bf9b8ab","diff":" vset.c | 52 ++++++++++++++++++++++++++++++++++++++++++----------\n 1 file changed, 42 insertions(+), 10 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex 8376dcb..d2251da 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -63,21 +63,53 @@ struct vsetNodeVal {\n     RedisModuleString *attrib;\n };\n \n-/* Create a random projection matrix for dimensionality reduction.\n- * Returns NULL on allocation failure. Matrix is scaled by 1/sqrt(input_dim). */\n+/* Count the number of set bits in an integer (population count/Hamming weight).\n+ * This is a portable implementation that doesn\u0027t rely on compiler extensions. */\n+static inline uint32_t bit_count(uint32_t n) {\n+    uint32_t count \u003d 0;\n+    while (n) {\n+        count +\u003d n \u0026 1;\n+        n \u003e\u003e\u003d 1;\n+    }\n+    return count;\n+}\n+\n+/* Create a Hadamard-based projection matrix for dimensionality reduction.\n+ * Uses {-1, +1} entries with a pattern based on bit operations.\n+ * The pattern is matrix[i][j] \u003d (i \u0026 j) % 2 \u003d\u003d 0 ? 1 : -1\n+ * Matrix is scaled by 1/sqrt(input_dim) for normalization.\n+ * Returns NULL on allocation failure.\n+ *\n+ * Note that compared to other approaches (random gaussian weights), what\n+ * we have here is deterministic, it means that our replicas will have\n+ * the same set of weights. Also this approach seems to work much better\n+ * in pratice, and the distances between elements are better guaranteed.\n+ *\n+ * Note that we still save the projection matrix in the RDB file, because\n+ * in the future we may change the weights generation, and we want everything\n+ * to be backward compatible. */\n float *createProjectionMatrix(uint32_t input_dim, uint32_t output_dim) {\n     float *matrix \u003d RedisModule_Alloc(sizeof(float) * input_dim * output_dim);\n-    if (!matrix) return NULL;\n \n+    /* Scale factor to normalize the projection. */\n     const float scale \u003d 1.0f / sqrt(input_dim);\n-    for (uint32_t i \u003d 0; i \u003c input_dim * output_dim; i++) {\n-        /* Box-Muller transform for normal distribution */\n-        float u1 \u003d (float)rand() / RAND_MAX;\n-        float u2 \u003d (float)rand() / RAND_MAX;\n-        float r \u003d sqrt(-2.0f * log(u1));\n-        float theta \u003d 2.0f * M_PI * u2;\n-        matrix[i] \u003d r * cos(theta) * scale;\n+\n+    /* Fill the matrix using Hadamard pattern. */\n+    for (uint32_t i \u003d 0; i \u003c output_dim; i++) {\n+        for (uint32_t j \u003d 0; j \u003c input_dim; j++) {\n+            /* Calculate position in the flattened matrix. */\n+            uint32_t pos \u003d i * input_dim + j;\n+\n+            /* Hadamard pattern: use bit operations to determine sign\n+             * If the count of 1-bits in the bitwise AND of i and j is even,\n+             * the value is 1, otherwise -1. */\n+            int value \u003d (bit_count(i \u0026 j) % 2 \u003d\u003d 0) ? 1 : -1;\n+\n+            /* Store the scaled value. */\n+            matrix[pos] \u003d value * scale;\n+        }\n     }\n+\n     return matrix;\n }\n ","expectedMessage":"Use Hadamard-based projection.","repository":"redis-antirez","commitHash":"8bf9b8abc16d43d606df5bdc1df7e5e8a5009ce1","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-958ebee0","diff":" README.md | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/README.md b/README.md\nindex c53ad75..f93b494 100644\n--- a/README.md\n+++ b/README.md\n@@ -42,7 +42,7 @@ Meaning of the options:\n \n `REDUCE` implements random projection, in order to reduce the\n dimensionality of the vector. The projection matrix is saved and reloaded\n-along with the vector set.\n+along with the vector set. **Please note that** the `REDUCE` option must be passed immediately before the vector, like in `REDUCE 50 VALUES ...`.\n \n `CAS` performs the operation partially using threads, in a\n check-and-set style. The neighbor candidates collection, which is slow, is","expectedMessage":"README: specify how to add REDUCE in VADD.","repository":"redis-antirez","commitHash":"958ebee0912e4d9b4869b56a61a09c418f029e02","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-8007ccd5","diff":" vset.c | 16 ++++++++--------\n 1 file changed, 8 insertions(+), 8 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex 5ba3935..8376dcb 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -374,7 +374,7 @@ int VADD_CASReply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     }\n \n     // Whatever happens is a success... :D\n-    RedisModule_ReplyWithLongLong(ctx,1);\n+    RedisModule_ReplyWithBool(ctx,1);\n     if (val) RedisModule_FreeString(ctx,val); // Not added? Free it.\n     if (attrib) RedisModule_FreeString(ctx,attrib); // Not added? Free it.\n     RedisModule_Free(vec);\n@@ -589,7 +589,7 @@ int VADD_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     int added \u003d vectorSetInsert(vset,vec,NULL,0,val,attrib,1,ef);\n     RedisModule_Free(vec);\n \n-    RedisModule_ReplyWithLongLong(ctx,added);\n+    RedisModule_ReplyWithBool(ctx,added);\n     if (added) RedisModule_ReplicateVerbatim(ctx);\n     return REDISMODULE_OK;\n }\n@@ -994,7 +994,7 @@ int VREM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n \n     /* Handle non-existing key or wrong type */\n     if (type \u003d\u003d REDISMODULE_KEYTYPE_EMPTY) {\n-        return RedisModule_ReplyWithLongLong(ctx, 0);\n+        return RedisModule_ReplyWithBool(ctx, 0);\n     }\n     if (RedisModule_ModuleTypeGetType(keyptr) !\u003d VectorSetType) {\n         return RedisModule_ReplyWithError(ctx, REDISMODULE_ERRORMSG_WRONGTYPE);\n@@ -1006,7 +1006,7 @@ int VREM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     /* Find the node for this element */\n     hnswNode *node \u003d RedisModule_DictGet(vset-\u003edict, element, NULL);\n     if (!node) {\n-        return RedisModule_ReplyWithLongLong(ctx, 0);\n+        return RedisModule_ReplyWithBool(ctx, 0);\n     }\n \n     /* Remove from dictionary */\n@@ -1025,7 +1025,7 @@ int VREM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     }\n \n     /* Reply and propagate the command */\n-    RedisModule_ReplyWithLongLong(ctx, 1);\n+    RedisModule_ReplyWithBool(ctx, 1);\n     RedisModule_ReplicateVerbatim(ctx);\n     return REDISMODULE_OK;\n }\n@@ -1110,7 +1110,7 @@ int VSETATTR_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int arg\n     int type \u003d RedisModule_KeyType(key);\n \n     if (type \u003d\u003d REDISMODULE_KEYTYPE_EMPTY)\n-        return RedisModule_ReplyWithLongLong(ctx, 0);\n+        return RedisModule_ReplyWithBool(ctx, 0);\n \n     if (RedisModule_ModuleTypeGetType(key) !\u003d VectorSetType)\n         return RedisModule_ReplyWithError(ctx, REDISMODULE_ERRORMSG_WRONGTYPE);\n@@ -1118,7 +1118,7 @@ int VSETATTR_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int arg\n     struct vsetObject *vset \u003d RedisModule_ModuleTypeGetValue(key);\n     hnswNode *node \u003d RedisModule_DictGet(vset-\u003edict, argv[2], NULL);\n     if (!node)\n-        return RedisModule_ReplyWithLongLong(ctx, 0);\n+        return RedisModule_ReplyWithBool(ctx, 0);\n \n     struct vsetNodeVal *nv \u003d node-\u003evalue;\n     RedisModuleString *new_attr \u003d argv[3];\n@@ -1147,7 +1147,7 @@ int VSETATTR_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int arg\n         nv-\u003eattrib \u003d new_attr;\n     }\n \n-    RedisModule_ReplyWithLongLong(ctx, 1);\n+    RedisModule_ReplyWithBool(ctx, 1);\n     RedisModule_ReplicateVerbatim(ctx);\n     return REDISMODULE_OK;\n }","expectedMessage":"Use RESP3-friendly bool replies.","repository":"redis-antirez","commitHash":"8007ccd51b4d141db8ef7dd9ae26b5f4b65ecf49","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-9cc750fd","diff":" tests/dimension_validation.py | 44 +++++++++++++++++++++----------------------\n 1 file changed, 21 insertions(+), 23 deletions(-)\n\ndiff --git a/tests/dimension_validation.py b/tests/dimension_validation.py\nindex a90be65..f081152 100644\n--- a/tests/dimension_validation.py\n+++ b/tests/dimension_validation.py\n@@ -4,7 +4,7 @@ import redis.exceptions\n \n class DimensionValidation(TestCase):\n     def getname(self):\n-        return \"Dimension Validation with Projection\"\n+        return \"[regression] Dimension Validation with Projection\"\n \n     def estimated_runtime(self):\n         return 0.5\n@@ -13,57 +13,55 @@ class DimensionValidation(TestCase):\n         # Test scenario 1: Create a set with projection\n         original_dim \u003d 100\n         reduced_dim \u003d 50\n-        \n+\n         # Create the initial vector and set with projection\n         vec1 \u003d generate_random_vector(original_dim)\n         vec1_bytes \u003d struct.pack(f\u0027{original_dim}f\u0027, *vec1)\n-        \n+\n         # Add first vector with projection\n-        result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key, \n+        result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key,\n                                           \u0027REDUCE\u0027, reduced_dim,\n                                           \u0027FP32\u0027, vec1_bytes, f\u0027{self.test_key}:item:1\u0027)\n         assert result \u003d\u003d 1, \"First VADD with REDUCE should return 1\"\n-        \n+\n         # Check VINFO returns the correct projection information\n         info \u003d self.redis.execute_command(\u0027VINFO\u0027, self.test_key)\n-        assert isinstance(info, dict), \"VINFO should return a dictionary\"\n-        assert \u0027vector-dim\u0027 in info, \"VINFO should contain vector-dim\"\n-        assert info[\u0027vector-dim\u0027] \u003d\u003d reduced_dim, f\"Expected reduced dimension {reduced_dim}, got {info[\u0027vector-dim\u0027]}\"\n-        assert \u0027proj-input-dim\u0027 in info, \"VINFO should contain proj-input-dim\"\n-        assert info[\u0027proj-input-dim\u0027] \u003d\u003d original_dim, f\"Expected original dimension {original_dim}, got {info[\u0027proj-input-dim\u0027]}\"\n-        assert \u0027proj-enabled\u0027 in info, \"VINFO should contain proj-enabled\"\n-        assert info[\u0027proj-enabled\u0027] is True, \"Projection should be enabled\"\n-        \n+        info_map \u003d {k.decode(\u0027utf-8\u0027): v for k, v in zip(info[::2], info[1::2])}\n+        assert \u0027vector-dim\u0027 in info_map, \"VINFO should contain vector-dim\"\n+        assert info_map[\u0027vector-dim\u0027] \u003d\u003d reduced_dim, f\"Expected reduced dimension {reduced_dim}, got {info[\u0027vector-dim\u0027]}\"\n+        assert \u0027projection-input-dim\u0027 in info_map, \"VINFO should contain projection-input-dim\"\n+        assert info_map[\u0027projection-input-dim\u0027] \u003d\u003d original_dim, f\"Expected original dimension {original_dim}, got {info[\u0027projection-input-dim\u0027]}\"\n+\n         # Test scenario 2: Try adding a mismatched vector - should fail\n         wrong_dim \u003d 80\n         wrong_vec \u003d generate_random_vector(wrong_dim)\n         wrong_vec_bytes \u003d struct.pack(f\u0027{wrong_dim}f\u0027, *wrong_vec)\n-        \n+\n         # This should fail with dimension mismatch error\n         try:\n-            self.redis.execute_command(\u0027VADD\u0027, self.test_key, \n-                                     \u0027REDUCE\u0027, reduced_dim, \n+            self.redis.execute_command(\u0027VADD\u0027, self.test_key,\n+                                     \u0027REDUCE\u0027, reduced_dim,\n                                      \u0027FP32\u0027, wrong_vec_bytes, f\u0027{self.test_key}:item:2\u0027)\n             assert False, \"VADD with wrong dimension should fail\"\n         except redis.exceptions.ResponseError as e:\n             assert \"Input dimension mismatch for projection\" in str(e), f\"Expected dimension mismatch error, got: {e}\"\n-            \n+\n         # Test scenario 3: Add a correctly-sized vector\n         vec2 \u003d generate_random_vector(original_dim)\n         vec2_bytes \u003d struct.pack(f\u0027{original_dim}f\u0027, *vec2)\n-        \n+\n         # This should succeed\n-        result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key, \n+        result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key,\n                                           \u0027REDUCE\u0027, reduced_dim,\n                                           \u0027FP32\u0027, vec2_bytes, f\u0027{self.test_key}:item:3\u0027)\n         assert result \u003d\u003d 1, \"VADD with correct dimensions should succeed\"\n-        \n+\n         # Check VSIM also validates input dimensions\n         wrong_query \u003d generate_random_vector(wrong_dim)\n         try:\n-            self.redis.execute_command(\u0027VSIM\u0027, self.test_key, \n-                                     \u0027VALUES\u0027, wrong_dim, *[str(x) for x in wrong_query], \n+            self.redis.execute_command(\u0027VSIM\u0027, self.test_key,\n+                                     \u0027VALUES\u0027, wrong_dim, *[str(x) for x in wrong_query],\n                                      \u0027COUNT\u0027, 10)\n             assert False, \"VSIM with wrong dimension should fail\"\n         except redis.exceptions.ResponseError as e:\n-            assert \"Input dimension mismatch for projection\" in str(e), f\"Expected dimension mismatch error in VSIM, got: {e}\" \n\\ No newline at end of file\n+            assert \"Input dimension mismatch for projection\" in str(e), f\"Expected dimension mismatch error in VSIM, got: {e}\"","expectedMessage":"Test: projection regression test fixed.","repository":"redis-antirez","commitHash":"9cc750fd66060448f8cb8463b701e4008cb2031d","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-aa92b375","diff":" vset.c | 24 +++++++-----------------\n 1 file changed, 7 insertions(+), 17 deletions(-)\n\ndiff --git a/vset.c b/vset.c\nindex ef00c53..5ba3935 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -538,7 +538,7 @@ int VADD_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n                     \"ERR Input dimension mismatch for projection - got %d but projection expects %d\",\n                     (int)dim, (int)vset-\u003eproj_input_size);\n             }\n-            \n+\n             float *projected \u003d applyProjection(vec, vset-\u003eproj_matrix,\n                                              vset-\u003eproj_input_size, dim);\n             RedisModule_Free(vec);\n@@ -780,7 +780,7 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n                     \"ERR Input dimension mismatch for projection - got %d but projection expects %d\",\n                     (int)dim, (int)vset-\u003eproj_input_size);\n             }\n-            \n+\n             float *projected \u003d applyProjection(vec, vset-\u003eproj_matrix,\n                                              vset-\u003eproj_input_size, dim);\n             RedisModule_Free(vec);\n@@ -1268,12 +1268,8 @@ int VINFO_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n \n     struct vsetObject *vset \u003d RedisModule_ModuleTypeGetValue(key);\n \n-    /* Calculate map size based on projection presence */\n-    int map_size \u003d 8;  /* Base fields */\n-    if (vset-\u003eproj_matrix) map_size +\u003d 2;  /* Additional fields for projection */\n-\n     /* Reply with hash */\n-    RedisModule_ReplyWithMap(ctx, map_size);\n+    RedisModule_ReplyWithMap(ctx, 9);\n \n     /* Quantization type */\n     RedisModule_ReplyWithSimpleString(ctx, \"quant-type\");\n@@ -1287,16 +1283,10 @@ int VINFO_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)\n     RedisModule_ReplyWithSimpleString(ctx, \"vector-dim\");\n     RedisModule_ReplyWithLongLong(ctx, vset-\u003ehnsw-\u003evector_dim);\n \n-    /* Add projection information if present */\n-    if (vset-\u003eproj_matrix) {\n-        /* Original input dimension before projection */\n-        RedisModule_ReplyWithSimpleString(ctx, \"projection-input-dim\");\n-        RedisModule_ReplyWithLongLong(ctx, vset-\u003eproj_input_size);\n-        \n-        /* Projection enabled flag */\n-        RedisModule_ReplyWithSimpleString(ctx, \"projection-enabled\");\n-        RedisModule_ReplyWithBool(ctx, 1);\n-    }\n+    /* Original input dimension before projection.\n+     * This is zero for vector sets without a random projection matrix. */\n+    RedisModule_ReplyWithSimpleString(ctx, \"projection-input-dim\");\n+    RedisModule_ReplyWithLongLong(ctx, vset-\u003eproj_input_size);\n \n     /* Number of elements. */\n     RedisModule_ReplyWithSimpleString(ctx, \"size\");","expectedMessage":"VINFO: use a single field for random projection info.","repository":"redis-antirez","commitHash":"aa92b37589e2555061a6034f19b97257b22f616d","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-8f479b22","diff":" test.py              | 36 ++++++++++++++++++++\n tests/replication.py | 92 ++++++++++++++++++++++++++++++++++++++++++++++++++++\n 2 files changed, 128 insertions(+)\n\ndiff --git a/test.py b/test.py\nindex afc5d7f..2e38ba0 100755\n--- a/test.py\n+++ b/test.py\n@@ -85,7 +85,12 @@ class TestCase:\n         self.error_msg \u003d None\n         self.error_details \u003d None\n         self.test_key \u003d f\"test:{self.__class__.__name__.lower()}\"\n+        # Primary Redis instance (default port)\n         self.redis \u003d redis.Redis()\n+        # Replica Redis instance (port 6380)\n+        self.replica \u003d redis.Redis(port\u003d6380)\n+        # Replication status\n+        self.replication_setup \u003d False\n \n     def setup(self):\n         self.redis.delete(self.test_key)\n@@ -93,6 +98,36 @@ class TestCase:\n     def teardown(self):\n         self.redis.delete(self.test_key)\n \n+    def setup_replication(self) -\u003e bool:\n+        \"\"\"\n+        Setup replication between primary and replica Redis instances.\n+        Returns True if replication is successfully established, False otherwise.\n+        \"\"\"\n+        # Configure replica to replicate from primary\n+        self.replica.execute_command(\u0027REPLICAOF\u0027, \u0027127.0.0.1\u0027, 6379)\n+\n+        # Wait for replication to be established\n+        max_attempts \u003d 10\n+        for attempt in range(max_attempts):\n+            # Check replication info\n+            repl_info \u003d self.replica.info(\u0027replication\u0027)\n+\n+            # Check if replication is established\n+            if (repl_info.get(\u0027role\u0027) \u003d\u003d \u0027slave\u0027 and\n+                repl_info.get(\u0027master_host\u0027) \u003d\u003d \u0027127.0.0.1\u0027 and\n+                repl_info.get(\u0027master_port\u0027) \u003d\u003d 6379 and\n+                repl_info.get(\u0027master_link_status\u0027) \u003d\u003d \u0027up\u0027):\n+\n+                self.replication_setup \u003d True\n+                return True\n+\n+            # Wait before next attempt\n+            time.sleep(0.5)\n+\n+        # If we get here, replication wasn\u0027t established\n+        self.error_msg \u003d \"Failed to establish replication between primary and replica\"\n+        return False\n+\n     def test(self):\n         raise NotImplementedError(\"Subclasses must implement test method\")\n \n@@ -146,6 +181,7 @@ def run_tests():\n     print(\"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\"+\n           \"Make sure to have Redis running in the localhost\\n\"+\n           \"with --enable-debug-command yes\\n\"+\n+          \"Both primary (6379) and replica (6380) instances\\n\"+\n           \"\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\\n\")\n \n     tests \u003d find_test_classes()\ndiff --git a/tests/replication.py b/tests/replication.py\nnew file mode 100644\nindex 0000000..91dfdf7\n--- /dev/null\n+++ b/tests/replication.py\n@@ -0,0 +1,92 @@\n+from test import TestCase, generate_random_vector\n+import struct\n+import random\n+import time\n+\n+class ComprehensiveReplicationTest(TestCase):\n+    def getname(self):\n+        return \"Comprehensive Replication Test with mixed operations\"\n+\n+    def estimated_runtime(self):\n+        # This test will take longer than the default 100ms\n+        return 20.0  # 20 seconds estimate\n+\n+    def test(self):\n+        # Setup replication between primary and replica\n+        assert self.setup_replication(), \"Failed to setup replication\"\n+\n+        # Test parameters\n+        num_vectors \u003d 5000\n+        vector_dim \u003d 8\n+        delete_probability \u003d 0.1\n+        cas_probability \u003d 0.3\n+\n+        # Keep track of added items for potential deletion\n+        added_items \u003d []\n+\n+        # Add vectors and occasionally delete\n+        for i in range(num_vectors):\n+            # Generate a random vector\n+            vec \u003d generate_random_vector(vector_dim)\n+            vec_bytes \u003d struct.pack(f\u0027{vector_dim}f\u0027, *vec)\n+            item_name \u003d f\"{self.test_key}:item:{i}\"\n+\n+            # Decide whether to use CAS or not\n+            use_cas \u003d random.random() \u003c cas_probability\n+\n+            if use_cas and added_items:\n+                # Get an existing item for CAS reference (if available)\n+                cas_item \u003d random.choice(added_items)\n+                try:\n+                    # Add with CAS\n+                    result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027FP32\u0027, vec_bytes,\n+                                                   item_name, \u0027CAS\u0027)\n+                    # Only add to our list if actually added (CAS might fail)\n+                    if result \u003d\u003d 1:\n+                        added_items.append(item_name)\n+                except Exception as e:\n+                    print(f\"  CAS VADD failed: {e}\")\n+            else:\n+                try:\n+                    # Add without CAS\n+                    result \u003d self.redis.execute_command(\u0027VADD\u0027, self.test_key, \u0027FP32\u0027, vec_bytes, item_name)\n+                    # Only add to our list if actually added\n+                    if result \u003d\u003d 1:\n+                        added_items.append(item_name)\n+                except Exception as e:\n+                    print(f\"  VADD failed: {e}\")\n+\n+            # Randomly delete items (with 10% probability)\n+            if random.random() \u003c delete_probability and added_items:\n+                try:\n+                    # Select a random item to delete\n+                    item_to_delete \u003d random.choice(added_items)\n+                    # Delete the item using VREM (not VDEL)\n+                    self.redis.execute_command(\u0027VREM\u0027, self.test_key, item_to_delete)\n+                    # Remove from our list\n+                    added_items.remove(item_to_delete)\n+                except Exception as e:\n+                    print(f\"  VREM failed: {e}\")\n+\n+        # Allow time for replication to complete\n+        time.sleep(2.0)\n+\n+        # Verify final VCARD matches\n+        primary_card \u003d self.redis.execute_command(\u0027VCARD\u0027, self.test_key)\n+        replica_card \u003d self.replica.execute_command(\u0027VCARD\u0027, self.test_key)\n+        assert primary_card \u003d\u003d replica_card, f\"Final VCARD mismatch: primary\u003d{primary_card}, replica\u003d{replica_card}\"\n+\n+        # Verify VDIM matches\n+        primary_dim \u003d self.redis.execute_command(\u0027VDIM\u0027, self.test_key)\n+        replica_dim \u003d self.replica.execute_command(\u0027VDIM\u0027, self.test_key)\n+        assert primary_dim \u003d\u003d replica_dim, f\"VDIM mismatch: primary\u003d{primary_dim}, replica\u003d{replica_dim}\"\n+\n+        # Verify digests match using DEBUG DIGEST\n+        primary_digest \u003d self.redis.execute_command(\u0027DEBUG\u0027, \u0027DIGEST-VALUE\u0027, self.test_key)\n+        replica_digest \u003d self.replica.execute_command(\u0027DEBUG\u0027, \u0027DIGEST-VALUE\u0027, self.test_key)\n+        assert primary_digest \u003d\u003d replica_digest, f\"Digest mismatch: primary\u003d{primary_digest}, replica\u003d{replica_digest}\"\n+\n+        # Print summary\n+        print(f\"\\n  Added and maintained {len(added_items)} vectors with dimension {vector_dim}\")\n+        print(f\"  Final vector count: {primary_card}\")\n+        print(f\"  Final digest: {primary_digest[0].decode()}\")","expectedMessage":"Tests: replication test.","repository":"redis-antirez","commitHash":"8f479b22b9db4c829b3923eea167fad24dd6e27d","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-854c7fdd","diff":" tests/dimension_validation.py | 69 +++++++++++++++++++++++++++++++++++++++++++\n vset.c                        | 36 ++++++++++++++++++++--\n 2 files changed, 103 insertions(+), 2 deletions(-)","expectedMessage":"Merge pull request #6 from rowantrollope/main","repository":"redis-antirez","commitHash":"854c7fdddb5bf5301f9bac7f6545cc00e904dff2","metadata":{"author":"Salvatore Sanfilippo \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-f330d617","diff":" vset.c | 9 ++++++++-\n 1 file changed, 8 insertions(+), 1 deletion(-)\n\ndiff --git a/vset.c b/vset.c\nindex 7ccd6da..34df75a 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -881,7 +881,14 @@ int VSIM_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n          * 2. If the write lock is taken while destroying the object, another\n          * command or operation (expire?) from the main thread acquired\n          * it to delete the object, so *it* will block if there are still\n-         * operations in progress on this key. */\n+         * operations in progress on this key.\n+         *\n+         * Note: even if we create one thread per request, the underlying\n+         * HNSW library has a fixed number of slots for the threads, as it\u0027s\n+         * defined in HNSW_MAX_THREADS (beware that if you increase it,\n+         * every node will use more memory). This means that while this request\n+         * is threaded, and will NOT block Redis, it may end waiting for a\n+         * free slot if all the HNSW_MAX_THREADS slots are used. */\n         pthread_rwlock_rdlock(\u0026vset-\u003ein_use_lock);\n \n         RedisModuleBlockedClient *bc \u003d RedisModule_BlockClient(ctx,NULL,NULL,NULL,0);","expectedMessage":"Clarify HNSW_MAX_THREADS vs one thread per request.","repository":"redis-antirez","commitHash":"f330d6175a36fe663c2044099fa0adf385e1aced","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-758e963a","diff":" README.md | 66 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++---\n 1 file changed, 63 insertions(+), 3 deletions(-)\n\ndiff --git a/README.md b/README.md\nindex f147b26..c53ad75 100644\n--- a/README.md\n+++ b/README.md\n@@ -214,6 +214,68 @@ are set or updated.\n The command returns the JSON attribute associated with an element, or\n null if there is no element associated, or no element at all, or no key.\n \n+**VRANDMEMBER: return random members from a vector set**\n+\n+    VRANDMEMBER key [count]\n+\n+Return one or more random elements from a vector set.\n+\n+The semantics of this command are similar to Redis\u0027s native SRANDMEMBER command:\n+\n+- When called without count, returns a single random element from the set, as a single string (no array reply).\n+- When called with a positive count, returns up to count distinct random elements (no duplicates).\n+- When called with a negative count, returns count random elements, potentially with duplicates.\n+- If the count value is larger than the set size (and positive), only the entire set is returned.\n+\n+If the key doesn\u0027t exist, returns a Null reply if count is not given, or an empty array if a count is provided.\n+\n+Examples:\n+\n+    \u003e VADD vset VALUES 3 1 0 0 elem1\n+    (integer) 1\n+    \u003e VADD vset VALUES 3 0 1 0 elem2\n+    (integer) 1\n+    \u003e VADD vset VALUES 3 0 0 1 elem3\n+    (integer) 1\n+\n+    # Return a single random element\n+    \u003e VRANDMEMBER vset\n+    \"elem2\"\n+\n+    # Return 2 distinct random elements\n+    \u003e VRANDMEMBER vset 2\n+    1) \"elem1\"\n+    2) \"elem3\"\n+\n+    # Return 3 random elements with possible duplicates\n+    \u003e VRANDMEMBER vset -3\n+    1) \"elem2\"\n+    2) \"elem2\"\n+    3) \"elem1\"\n+\n+    # Return more elements than in the set (returns all elements)\n+    \u003e VRANDMEMBER vset 10\n+    1) \"elem1\"\n+    2) \"elem2\"\n+    3) \"elem3\"\n+\n+    # When key doesn\u0027t exist\n+    \u003e VRANDMEMBER nonexistent\n+    (nil)\n+    \u003e VRANDMEMBER nonexistent 3\n+    (empty array)\n+\n+This command is particularly useful for:\n+\n+1. Selecting random samples from a vector set for testing or training.\n+2. Performance testing by retrieving random elements for subsequent similarity searches.\n+\n+When the user asks for unique elements (positev count) the implementation optimizes for two scenarios:\n+- For small sample sizes (less than 20% of the set size), it uses a dictionary to avoid duplicates, and performs a real random walk inside the graph.\n+- For large sample sizes (more than 20% of the set size), it starts from a random node and sequentially traverses the internal list, providing faster performances but not really \"random\" elements.\n+\n+The command has `O(N)` worst-case time complexity when requesting many unique elements (it uses linear scanning), or `O(M*log(N))` complexity when the users asks for `M` random elements in a sorted set of `N` elements, with `M` much smaller than `N`.\n+\n # Filtered search\n \n Each element of the vector set can be associated with a set of attributes specified as a JSON blob:\n@@ -225,7 +287,7 @@ Each element of the vector set can be associated with a set of attributes specif\n \n Specifying an attribute with the `SETATTR` option of `VADD` is exactly equivalent to adding an element and then setting (or updating, if already set) the attributes JSON string. Also the symmetrical `VGETATTR` command returns the attribute associated to a given element.\n \n-    \u003e VAD vset VALUES 3 0 1 0 c\n+    \u003e VADD vset VALUES 3 0 1 0 c\n     (integer) 1\n     \u003e VSETATTR vset c \u0027{\"year\": 1952}\u0027\n     (integer) 1\n@@ -244,8 +306,6 @@ The expressions are similar to what you would write inside the `if` statement of\n \n Elements with invalid JSON or not having a given specified field **are considered as not matching** the expression, but will not generate any error at runtime.\n \n-I\u0027ll draft the missing sections for the README following the style and format of the existing content.\n-\n ## FILTER expressions capabilities\n \n FILTER expressions allow you to perform complex filtering on vector similarity results using a JavaScript-like syntax. The expression is evaluated against each element\u0027s JSON attributes, with only elements that satisfy the expression being included in the results.","expectedMessage":"VRANDMEMBER documentation.","repository":"redis-antirez","commitHash":"758e963a4e619260042b19ed7f61471a464f10a0","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-3424757f","diff":" tests/concurrent_vadd_cas_del_vsim.py | 156 ++++++++++++++++++++++++++++++++++\n 1 file changed, 156 insertions(+)\n\ndiff --git a/tests/concurrent_vadd_cas_del_vsim.py b/tests/concurrent_vadd_cas_del_vsim.py\nnew file mode 100644\nindex 0000000..f4b3a12\n--- /dev/null\n+++ b/tests/concurrent_vadd_cas_del_vsim.py\n@@ -0,0 +1,156 @@\n+from test import TestCase, generate_random_vector\n+import threading\n+import time\n+import struct\n+\n+class ThreadingStressTest(TestCase):\n+    def getname(self):\n+        return \"Concurrent VADD/DEL/VSIM operations stress test\"\n+\n+    def estimated_runtime(self):\n+        return 10  # Test runs for 10 seconds\n+\n+    def test(self):\n+        # Constants - easy to modify if needed\n+        NUM_VADD_THREADS \u003d 10\n+        NUM_VSIM_THREADS \u003d 1\n+        NUM_DEL_THREADS \u003d 1\n+        TEST_DURATION \u003d 10  # seconds\n+        VECTOR_DIM \u003d 100\n+        DEL_INTERVAL \u003d 1  # seconds\n+\n+        # Shared flags and state\n+        stop_event \u003d threading.Event()\n+        error_list \u003d []\n+        error_lock \u003d threading.Lock()\n+\n+        def log_error(thread_name, error):\n+            with error_lock:\n+                error_list.append(f\"{thread_name}: {error}\")\n+\n+        def vadd_worker(thread_id):\n+            \"\"\"Thread function to perform VADD operations\"\"\"\n+            thread_name \u003d f\"VADD-{thread_id}\"\n+            try:\n+                vector_count \u003d 0\n+                while not stop_event.is_set():\n+                    try:\n+                        # Generate random vector\n+                        vec \u003d generate_random_vector(VECTOR_DIM)\n+                        vec_bytes \u003d struct.pack(f\u0027{VECTOR_DIM}f\u0027, *vec)\n+\n+                        # Add vector with CAS option\n+                        self.redis.execute_command(\n+                            \u0027VADD\u0027,\n+                            self.test_key,\n+                            \u0027FP32\u0027,\n+                            vec_bytes,\n+                            f\u0027{self.test_key}:item:{thread_id}:{vector_count}\u0027,\n+                            \u0027CAS\u0027\n+                        )\n+\n+                        vector_count +\u003d 1\n+\n+                        # Small sleep to reduce CPU pressure\n+                        if vector_count % 10 \u003d\u003d 0:\n+                            time.sleep(0.001)\n+                    except Exception as e:\n+                        log_error(thread_name, f\"Error: {str(e)}\")\n+                        time.sleep(0.1)  # Slight backoff on error\n+            except Exception as e:\n+                log_error(thread_name, f\"Thread error: {str(e)}\")\n+\n+        def del_worker():\n+            \"\"\"Thread function that deletes the key periodically\"\"\"\n+            thread_name \u003d \"DEL\"\n+            try:\n+                del_count \u003d 0\n+                while not stop_event.is_set():\n+                    try:\n+                        # Sleep first, then delete\n+                        time.sleep(DEL_INTERVAL)\n+                        if stop_event.is_set():\n+                            break\n+\n+                        self.redis.delete(self.test_key)\n+                        del_count +\u003d 1\n+                    except Exception as e:\n+                        log_error(thread_name, f\"Error: {str(e)}\")\n+            except Exception as e:\n+                log_error(thread_name, f\"Thread error: {str(e)}\")\n+\n+        def vsim_worker(thread_id):\n+            \"\"\"Thread function to perform VSIM operations\"\"\"\n+            thread_name \u003d f\"VSIM-{thread_id}\"\n+            try:\n+                search_count \u003d 0\n+                while not stop_event.is_set():\n+                    try:\n+                        # Generate query vector\n+                        query_vec \u003d generate_random_vector(VECTOR_DIM)\n+                        query_str \u003d [str(x) for x in query_vec]\n+\n+                        # Perform similarity search\n+                        args \u003d [\u0027VSIM\u0027, self.test_key, \u0027VALUES\u0027, VECTOR_DIM]\n+                        args.extend(query_str)\n+                        args.extend([\u0027COUNT\u0027, 10])\n+                        self.redis.execute_command(*args)\n+\n+                        search_count +\u003d 1\n+\n+                        # Small sleep to reduce CPU pressure\n+                        if search_count % 10 \u003d\u003d 0:\n+                            time.sleep(0.005)\n+                    except Exception as e:\n+                        # Don\u0027t log empty array errors, as they\u0027re expected when key doesn\u0027t exist\n+                        if \"empty array\" not in str(e).lower():\n+                            log_error(thread_name, f\"Error: {str(e)}\")\n+                        time.sleep(0.1)  # Slight backoff on error\n+            except Exception as e:\n+                log_error(thread_name, f\"Thread error: {str(e)}\")\n+\n+        # Start all threads\n+        threads \u003d []\n+\n+        # VADD threads\n+        for i in range(NUM_VADD_THREADS):\n+            thread \u003d threading.Thread(target\u003dvadd_worker, args\u003d(i,))\n+            thread.start()\n+            threads.append(thread)\n+\n+        # DEL threads\n+        for _ in range(NUM_DEL_THREADS):\n+            thread \u003d threading.Thread(target\u003ddel_worker)\n+            thread.start()\n+            threads.append(thread)\n+\n+        # VSIM threads\n+        for i in range(NUM_VSIM_THREADS):\n+            thread \u003d threading.Thread(target\u003dvsim_worker, args\u003d(i,))\n+            thread.start()\n+            threads.append(thread)\n+\n+        # Let the test run for the specified duration\n+        time.sleep(TEST_DURATION)\n+\n+        # Signal all threads to stop\n+        stop_event.set()\n+\n+        # Wait for threads to finish\n+        for thread in threads:\n+            thread.join(timeout\u003d2.0)\n+\n+        # Check if Redis is still responsive\n+        try:\n+            ping_result \u003d self.redis.ping()\n+            assert ping_result, \"Redis did not respond to PING after stress test\"\n+        except Exception as e:\n+            assert False, f\"Redis connection failed after stress test: {str(e)}\"\n+\n+        # Report any errors for diagnosis, but don\u0027t fail the test unless PING fails\n+        if error_list:\n+            error_count \u003d len(error_list)\n+            print(f\"\\nEncountered {error_count} errors during stress test.\")\n+            print(\"First 5 errors:\")\n+            for error in error_list[:5]:\n+                print(f\"- {error}\")","expectedMessage":"Test: added another threading stress test.","repository":"redis-antirez","commitHash":"3424757f4da4bbd5edbc5a70f9aac25c713f4767","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
{"id":"redis-antirez-70ffa8ce","diff":" vset.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\ndiff --git a/vset.c b/vset.c\nindex 3be8e2f..7ccd6da 100644\n--- a/vset.c\n+++ b/vset.c\n@@ -340,7 +340,8 @@ int VADD_CASReply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n          * the other insert won. We don\u0027t even start a threaded VADD\n          * if this was an udpate, since the deletion of the element itself\n          * in order to perform the update would invalidate the CAS state. */\n-        if (RedisModule_DictGet(vset-\u003edict,val,NULL) !\u003d NULL) vset \u003d NULL;\n+        if (vset \u0026\u0026 RedisModule_DictGet(vset-\u003edict,val,NULL) !\u003d NULL)\n+            vset \u003d NULL;\n     }\n \n     if (vset \u003d\u003d NULL) {","expectedMessage":"Fix VADD_CASReply() NULL reference on ID mismatch.","repository":"redis-antirez","commitHash":"70ffa8ce5c6510bd7bf257a477e684d9a32ec1ac","metadata":{"author":"antirez \u003cantirez@gmail.com\u003e"}}
