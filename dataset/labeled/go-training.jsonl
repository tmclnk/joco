{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/go/internal/work/exec.go     | 8 ++++++++\n src/cmd/go/internal/work/security.go | 1 +\n 2 files changed, 9 insertions(+)\n\ndiff --git a/src/cmd/go/internal/work/exec.go b/src/cmd/go/internal/work/exec.go\nindex 0afdce23..c4971356 100644\n--- a/src/cmd/go/internal/work/exec.go\n+++ b/src/cmd/go/internal/work/exec.go\n@@ -1788,6 +1788,14 @@ func (b *Builder) getPkgConfigFlags(a *Action, p *load.Package) (cflags, ldflags\n \t\t\t\treturn nil, nil, fmt.Errorf(\"invalid pkg-config package name: %s\", pkg)\n \t\t\t}\n \t\t}\n+\n+\t\t// Running 'pkg-config' can cause execution of\n+\t\t// arbitrary code using flags that are not in\n+\t\t// the safelist.\n+\t\tif err := checkCompilerFlags(\"CFLAGS\", \"pkg-config --cflags\", pcflags); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\n \t\tvar out []byte\n \t\tout, err = sh.runOut(p.Dir, nil, b.PkgconfigCmd(), \"--cflags\", pcflags, \"--\", pkgs)\n \t\tif err != nil {\ndiff --git a/src/cmd/go/internal/work/security.go b/src/cmd/go/internal/work/security.go\nindex ffa83e05..80b3f879 100644\n--- a/src/cmd/go/internal/work/security.go\n+++ b/src/cmd/go/internal/work/security.go\n@@ -129,6 +129,7 @@ var validCompilerFlags = []*lazyregexp.Regexp{\n \tre(`-pedantic(-errors)?`),\n \tre(`-pipe`),\n \tre(`-pthread`),\n+\tre(`--static`),\n \tre(`-?-std=([^@\\-].*)`),\n \tre(`-?-stdlib=([^@\\-].*)`),\n \tre(`--sysroot=([^@\\-].*)`),","output":"fix(security): validate pkg-config cflags and allow --static flag","metadata":{"id":"go-5e1ad12d","repository":"go","commit_hash":"5e1ad12db93611b13d2be176fdc276330dc52b98"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/go/internal/modcmd/edit.go           |  10 +-\n src/cmd/go/internal/modfetch/codehost/git.go |  20 +-\n src/cmd/go/internal/modfetch/codehost/vcs.go |  26 +-\n src/cmd/go/internal/modget/query.go          |   5 +-\n src/cmd/go/internal/modload/build.go         |  12 +-\n src/cmd/go/internal/modload/list.go          |  30 ++-\n src/cmd/go/internal/toolchain/select.go      |   7 +-\n src/cmd/go/internal/vcs/vcs.go               | 353 +++------------------------\n src/cmd/go/internal/vcs/vcs_test.go          |  36 +++\n src/cmd/go/internal/workcmd/edit.go          |   5 +-\n 10 files changed, 157 insertions(+), 347 deletions(-)\n\ndiff --git a/src/cmd/go/internal/modcmd/edit.go b/src/cmd/go/internal/modcmd/edit.go\nindex 69ebb148..cd15b822 100644\n--- a/src/cmd/go/internal/modcmd/edit.go\n+++ b/src/cmd/go/internal/modcmd/edit.go\n@@ -328,7 +328,10 @@ func runEdit(ctx context.Context, cmd *base.Command, args []string) {\n \n // parsePathVersion parses -flag=arg expecting arg to be path@version.\n func parsePathVersion(flag, arg string) (path, version string) {\n-\tbefore, after, found := strings.Cut(arg, \"@\")\n+\tbefore, after, found, err := modload.ParsePathVersion(arg)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: -%s=%s: %v\", flag, arg, err)\n+\t}\n \tif !found {\n \t\tbase.Fatalf(\"go: -%s=%s: need path@version\", flag, arg)\n \t}\n@@ -362,7 +365,10 @@ func parsePathVersionOptional(adj, arg string, allowDirPath bool) (path, version\n \tif allowDirPath && modfile.IsDirectoryPath(arg) {\n \t\treturn arg, \"\", nil\n \t}\n-\tbefore, after, found := strings.Cut(arg, \"@\")\n+\tbefore, after, found, err := modload.ParsePathVersion(arg)\n+\tif err != nil {\n+\t\treturn \"\", \"\", err\n+\t}\n \tif !found {\n \t\tpath = arg\n \t} else {\ndiff --git a/src/cmd/go/internal/modfetch/codehost/git.go b/src/cmd/go/internal/modfetch/codehost/git.go\nindex 3d50dca3..6eb61772 100644\n--- a/src/cmd/go/internal/modfetch/codehost/git.go\n+++ b/src/cmd/go/internal/modfetch/codehost/git.go\n@@ -261,7 +261,7 @@ func (r *gitRepo) loadRefs(ctx context.Context) (map[string]string, error) {\n \t\t\tr.refsErr = err\n \t\t\treturn\n \t\t}\n-\t\tout, gitErr := r.runGit(ctx, \"git\", \"ls-remote\", \"-q\", r.remote)\n+\t\tout, gitErr := r.runGit(ctx, \"git\", \"ls-remote\", \"-q\", \"--end-of-options\", r.remote)\n \t\trelease()\n \n \t\tif gitErr != nil {\n@@ -530,7 +530,7 @@ func (r *gitRepo) stat(ctx context.Context, rev string) (info *RevInfo, err erro\n \t\t\tif fromTag && !slices.Contains(info.Tags, tag) {\n \t\t\t\t// The local repo includes the commit hash we want, but it is missing\n \t\t\t\t// the corresponding tag. Add that tag and try again.\n-\t\t\t\t_, err := r.runGit(ctx, \"git\", \"tag\", tag, hash)\n+\t\t\t\t_, err := r.runGit(ctx, \"git\", \"tag\", \"--end-of-options\", tag, hash)\n \t\t\t\tif err != nil {\n \t\t\t\t\treturn nil, err\n \t\t\t\t}\n@@ -579,7 +579,7 @@ func (r *gitRepo) stat(ctx context.Context, rev string) (info *RevInfo, err erro\n \t\t// an apparent Git bug introduced in Git 2.21 (commit 61c771),\n \t\t// which causes the handler for protocol version 1 to sometimes miss\n \t\t// tags that point to the requested commit (see https://go.dev/issue/56881).\n-\t\t_, err = r.runGit(ctx, \"git\", \"-c\", \"protocol.version=2\", \"fetch\", \"-f\", \"--depth=1\", r.remote, refspec)\n+\t\t_, err = r.runGit(ctx, \"git\", \"-c\", \"protocol.version=2\", \"fetch\", \"-f\", \"--depth=1\", \"--end-of-options\", r.remote, refspec)\n \t\trelease()\n \n \t\tif err == nil {\n@@ -625,12 +625,12 @@ func (r *gitRepo) fetchRefsLocked(ctx context.Context) error {\n \t\t}\n \t\tdefer release()\n \n-\t\tif _, err := r.runGit(ctx, \"git\", \"fetch\", \"-f\", r.remote, \"refs/heads/*:refs/heads/*\", \"refs/tags/*:refs/tags/*\"); err != nil {\n+\t\tif _, err := r.runGit(ctx, \"git\", \"fetch\", \"-f\", \"--end-of-options\", r.remote, \"refs/heads/*:refs/heads/*\", \"refs/tags/*:refs/tags/*\"); err != nil {\n \t\t\treturn err\n \t\t}\n \n \t\tif _, err := os.Stat(filepath.Join(r.dir, \"shallow\")); err == nil {\n-\t\t\tif _, err := r.runGit(ctx, \"git\", \"fetch\", \"--unshallow\", \"-f\", r.remote); err != nil {\n+\t\t\tif _, err := r.runGit(ctx, \"git\", \"fetch\", \"--unshallow\", \"-f\", \"--end-of-options\", r.remote); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n@@ -643,7 +643,7 @@ func (r *gitRepo) fetchRefsLocked(ctx context.Context) error {\n // statLocal returns a new RevInfo describing rev in the local git repository.\n // It uses version as info.Version.\n func (r *gitRepo) statLocal(ctx context.Context, version, rev string) (*RevInfo, error) {\n-\tout, err := r.runGit(ctx, \"git\", \"-c\", \"log.showsignature=false\", \"log\", \"--no-decorate\", \"-n1\", \"--format=format:%H %ct %D\", rev, \"--\")\n+\tout, err := r.runGit(ctx, \"git\", \"-c\", \"log.showsignature=false\", \"log\", \"--no-decorate\", \"-n1\", \"--format=format:%H %ct %D\", \"--end-of-options\", rev, \"--\")\n \tif err != nil {\n \t\t// Return info with Origin.RepoSum if possible to allow caching of negative lookup.\n \t\tvar info *RevInfo\n@@ -733,7 +733,7 @@ func (r *gitRepo) ReadFile(ctx context.Context, rev, file string, maxSize int64)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tout, err := r.runGit(ctx, \"git\", \"cat-file\", \"blob\", info.Name+\":\"+file)\n+\tout, err := r.runGit(ctx, \"git\", \"cat-file\", \"--end-of-options\", \"blob\", info.Name+\":\"+file)\n \tif err != nil {\n \t\treturn nil, fs.ErrNotExist\n \t}\n@@ -751,7 +751,7 @@ func (r *gitRepo) RecentTag(ctx context.Context, rev, prefix string, allowed fun\n \t// result is definitive.\n \tdescribe := func() (definitive bool) {\n \t\tvar out []byte\n-\t\tout, err = r.runGit(ctx, \"git\", \"for-each-ref\", \"--format\", \"%(refname)\", \"refs/tags\", \"--merged\", rev)\n+\t\tout, err = r.runGit(ctx, \"git\", \"for-each-ref\", \"--format=%(refname)\", \"--merged=\"+rev)\n \t\tif err != nil {\n \t\t\treturn true\n \t\t}\n@@ -903,7 +903,7 @@ func (r *gitRepo) ReadZip(ctx context.Context, rev, subdir string, maxSize int64\n \t// TODO: Use maxSize or drop it.\n \targs := []string{}\n \tif subdir != \"\" {\n-\t\targs = append(args, \"--\", subdir)\n+\t\targs = append(args, subdir)\n \t}\n \tinfo, err := r.Stat(ctx, rev) // download rev into local git repo\n \tif err != nil {\n@@ -925,7 +925,7 @@ func (r *gitRepo) ReadZip(ctx context.Context, rev, subdir string, maxSize int64\n \t// text file line endings. Setting -c core.autocrlf=input means only\n \t// translate files on the way into the repo, not on the way out (archive).\n \t// The -c core.eol=lf should be unnecessary but set it anyway.\n-\tarchive, err := r.runGit(ctx, \"git\", \"-c\", \"core.autocrlf=input\", \"-c\", \"core.eol=lf\", \"archive\", \"--format=zip\", \"--prefix=prefix/\", info.Name, args)\n+\tarchive, err := r.runGit(ctx, \"git\", \"-c\", \"core.autocrlf=input\", \"-c\", \"core.eol=lf\", \"archive\", \"--format=zip\", \"--prefix=prefix/\", \"--end-of-options\", info.Name, args)\n \tif err != nil {\n \t\tif bytes.Contains(err.(*RunError).Stderr, []byte(\"did not match any files\")) {\n \t\t\treturn nil, fs.ErrNotExist\ndiff --git a/src/cmd/go/internal/modfetch/codehost/vcs.go b/src/cmd/go/internal/modfetch/codehost/vcs.go\nindex aae1a60b..59264a3b 100644\n--- a/src/cmd/go/internal/modfetch/codehost/vcs.go\n+++ b/src/cmd/go/internal/modfetch/codehost/vcs.go\n@@ -188,6 +188,7 @@ var vcsCmds = map[string]*vcsCmd{\n \t\t\t\t\"hg\",\n \t\t\t\t\"--config=extensions.goreposum=\" + filepath.Join(cfg.GOROOT, \"lib/hg/goreposum.py\"),\n \t\t\t\t\"goreposum\",\n+\t\t\t\t\"--\",\n \t\t\t\tremote,\n \t\t\t}\n \t\t},\n@@ -196,6 +197,7 @@ var vcsCmds = map[string]*vcsCmd{\n \t\t\t\t\"hg\",\n \t\t\t\t\"--config=extensions.goreposum=\" + filepath.Join(cfg.GOROOT, \"lib/hg/goreposum.py\"),\n \t\t\t\t\"golookup\",\n+\t\t\t\t\"--\",\n \t\t\t\tremote,\n \t\t\t\tref,\n \t\t\t}\n@@ -216,26 +218,26 @@ var vcsCmds = map[string]*vcsCmd{\n \t\tbranchRE:           re(`(?m)^[^\\n]+$`),\n \t\tbadLocalRevRE:      re(`(?m)^(tip)$`),\n \t\tstatLocal: func(rev, remote string) []string {\n-\t\t\treturn []string{\"hg\", \"log\", \"-l1\", \"-r\", rev, \"--template\", \"{node} {date|hgdate} {tags}\"}\n+\t\t\treturn []string{\"hg\", \"log\", \"-l1\", fmt.Sprintf(\"--rev=%s\", rev), \"--template\", \"{node} {date|hgdate} {tags}\"}\n \t\t},\n \t\tparseStat: hgParseStat,\n \t\tfetch:     []string{\"hg\", \"pull\", \"-f\"},\n \t\tlatest:    \"tip\",\n \t\tdescendsFrom: func(rev, tag string) []string {\n-\t\t\treturn []string{\"hg\", \"log\", \"-r\", \"ancestors(\" + rev + \") and \" + tag}\n+\t\t\treturn []string{\"hg\", \"log\", \"--rev=ancestors(\" + rev + \") and \" + tag}\n \t\t},\n \t\trecentTags: func(rev string) []string {\n-\t\t\treturn []string{\"hg\", \"log\", \"-r\", \"ancestors(\" + rev + \") and tag()\", \"--template\", \"{tags}\\n\"}\n+\t\t\treturn []string{\"hg\", \"log\", \"--rev=ancestors(\" + rev + \") and tag()\", \"--template\", \"{tags}\\n\"}\n \t\t},\n \t\treadFile: func(rev, file, remote string) []string {\n-\t\t\treturn []string{\"hg\", \"cat\", \"-r\", rev, file}\n+\t\t\treturn []string{\"hg\", \"cat\", fmt.Sprintf(\"--rev=%s\", rev), \"--\", file}\n \t\t},\n \t\treadZip: func(rev, subdir, remote, target string) []string {\n \t\t\tpattern := []string{}\n \t\t\tif subdir != \"\" {\n-\t\t\t\tpattern = []string{\"-I\", subdir + \"/**\"}\n+\t\t\t\tpattern = []string{fmt.Sprintf(\"--include=%s\", subdir+\"/**\")}\n \t\t\t}\n-\t\t\treturn str.StringList(\"hg\", \"archive\", \"-t\", \"zip\", \"--no-decode\", \"-r\", rev, \"--prefix=prefix/\", pattern, \"--\", target)\n+\t\t\treturn str.StringList(\"hg\", \"archive\", \"-t\", \"zip\", \"--no-decode\", fmt.Sprintf(\"--rev=%s\", rev), \"--prefix=prefix/\", pattern, \"--\", target)\n \t\t},\n \t},\n \n@@ -275,19 +277,19 @@ var vcsCmds = map[string]*vcsCmd{\n \t\ttagRE:         re(`(?m)^\\S+`),\n \t\tbadLocalRevRE: re(`^revno:-`),\n \t\tstatLocal: func(rev, remote string) []string {\n-\t\t\treturn []string{\"bzr\", \"log\", \"-l1\", \"--long\", \"--show-ids\", \"-r\", rev}\n+\t\t\treturn []string{\"bzr\", \"log\", \"-l1\", \"--long\", \"--show-ids\", fmt.Sprintf(\"--revision=%s\", rev)}\n \t\t},\n \t\tparseStat: bzrParseStat,\n \t\tlatest:    \"revno:-1\",\n \t\treadFile: func(rev, file, remote string) []string {\n-\t\t\treturn []string{\"bzr\", \"cat\", \"-r\", rev, file}\n+\t\t\treturn []string{\"bzr\", \"cat\", fmt.Sprintf(\"--revision=%s\", rev), \"--\", file}\n \t\t},\n \t\treadZip: func(rev, subdir, remote, target string) []string {\n \t\t\textra := []string{}\n \t\t\tif subdir != \"\" {\n \t\t\t\textra = []string{\"./\" + subdir}\n \t\t\t}\n-\t\t\treturn str.StringList(\"bzr\", \"export\", \"--format=zip\", \"-r\", rev, \"--root=prefix/\", \"--\", target, extra)\n+\t\t\treturn str.StringList(\"bzr\", \"export\", \"--format=zip\", fmt.Sprintf(\"--revision=%s\", rev), \"--root=prefix/\", \"--\", target, extra)\n \t\t},\n \t},\n \n@@ -302,17 +304,17 @@ var vcsCmds = map[string]*vcsCmd{\n \t\t},\n \t\ttagRE: re(`XXXTODO`),\n \t\tstatLocal: func(rev, remote string) []string {\n-\t\t\treturn []string{\"fossil\", \"info\", \"-R\", \".fossil\", rev}\n+\t\t\treturn []string{\"fossil\", \"info\", \"-R\", \".fossil\", \"--\", rev}\n \t\t},\n \t\tparseStat: fossilParseStat,\n \t\tlatest:    \"trunk\",\n \t\treadFile: func(rev, file, remote string) []string {\n-\t\t\treturn []string{\"fossil\", \"cat\", \"-R\", \".fossil\", \"-r\", rev, file}\n+\t\t\treturn []string{\"fossil\", \"cat\", \"-R\", \".fossil\", fmt.Sprintf(\"-r=%s\", rev), \"--\", file}\n \t\t},\n \t\treadZip: func(rev, subdir, remote, target string) []string {\n \t\t\textra := []string{}\n \t\t\tif subdir != \"\" && !strings.ContainsAny(subdir, \"*?[],\") {\n-\t\t\t\textra = []string{\"--include\", subdir}\n+\t\t\t\textra = []string{fmt.Sprintf(\"--include=%s\", subdir)}\n \t\t\t}\n \t\t\t// Note that vcsRepo.ReadZip below rewrites this command\n \t\t\t// to run in a different directory, to work around a fossil bug.\ndiff --git a/src/cmd/go/internal/modget/query.go b/src/cmd/go/internal/modget/query.go\nindex 3086dbc1..e9807edd 100644\n--- a/src/cmd/go/internal/modget/query.go\n+++ b/src/cmd/go/internal/modget/query.go\n@@ -140,7 +140,10 @@ func errSet(err error) pathSet { return pathSet{err: err} }\n // newQuery returns a new query parsed from the raw argument,\n // which must be either path or path@version.\n func newQuery(loaderstate *modload.State, raw string) (*query, error) {\n-\tpattern, rawVers, found := strings.Cut(raw, \"@\")\n+\tpattern, rawVers, found, err := modload.ParsePathVersion(raw)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \tif found && (strings.Contains(rawVers, \"@\") || rawVers == \"\") {\n \t\treturn nil, fmt.Errorf(\"invalid module version syntax %q\", raw)\n \t}\ndiff --git a/src/cmd/go/internal/modload/build.go b/src/cmd/go/internal/modload/build.go\nindex b560dd6a..cb437135 100644\n--- a/src/cmd/go/internal/modload/build.go\n+++ b/src/cmd/go/internal/modload/build.go\n@@ -12,7 +12,6 @@ import (\n \t\"io/fs\"\n \t\"os\"\n \t\"path/filepath\"\n-\t\"strings\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n@@ -88,7 +87,16 @@ func ModuleInfo(loaderstate *State, ctx context.Context, path string) *modinfo.M\n \t\treturn nil\n \t}\n \n-\tif path, vers, found := strings.Cut(path, \"@\"); found {\n+\tpath, vers, found, err := ParsePathVersion(path)\n+\tif err != nil {\n+\t\treturn &modinfo.ModulePublic{\n+\t\t\tPath: path,\n+\t\t\tError: &modinfo.ModuleError{\n+\t\t\t\tErr: err.Error(),\n+\t\t\t},\n+\t\t}\n+\t}\n+\tif found {\n \t\tm := module.Version{Path: path, Version: vers}\n \t\treturn moduleInfo(loaderstate, ctx, nil, m, 0, nil)\n \t}\ndiff --git a/src/cmd/go/internal/modload/list.go b/src/cmd/go/internal/modload/list.go\nindex 316fda40..32f8c5fe 100644\n--- a/src/cmd/go/internal/modload/list.go\n+++ b/src/cmd/go/internal/modload/list.go\n@@ -150,7 +150,11 @@ func listModules(loaderstate *State, ctx context.Context, rs *Requirements, args\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n-\t\tif path, vers, found := strings.Cut(arg, \"@\"); found {\n+\t\tpath, vers, found, err := ParsePathVersion(arg)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t}\n+\t\tif found {\n \t\t\tif vers == \"upgrade\" || vers == \"patch\" {\n \t\t\t\tif _, ok := rs.rootSelected(loaderstate, path); !ok || rs.pruning == unpruned {\n \t\t\t\t\tneedFullGraph = true\n@@ -176,7 +180,11 @@ func listModules(loaderstate *State, ctx context.Context, rs *Requirements, args\n \n \tmatchedModule := map[module.Version]bool{}\n \tfor _, arg := range args {\n-\t\tif path, vers, found := strings.Cut(arg, \"@\"); found {\n+\t\tpath, vers, found, err := ParsePathVersion(arg)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n+\t\t}\n+\t\tif found {\n \t\t\tvar current string\n \t\t\tif mg == nil {\n \t\t\t\tcurrent, _ = rs.rootSelected(loaderstate, path)\n@@ -317,3 +325,21 @@ func modinfoError(path, vers string, err error) *modinfo.ModuleError {\n \n \treturn &modinfo.ModuleError{Err: err.Error()}\n }\n+\n+// ParsePathVersion parses arg expecting arg to be path@version. If there is no\n+// '@' in arg, found is false, vers is \"\", and path is arg. This mirrors the\n+// typical usage of strings.Cut. ParsePathVersion is meant to be a general\n+// replacement for strings.Cut in module version parsing. If the version is\n+// invalid, an error is returned. The version is considered invalid if it is\n+// prefixed with '-' or '/', which can cause security problems when constructing\n+// commands to execute that use the version.\n+func ParsePathVersion(arg string) (path, vers string, found bool, err error) {\n+\tpath, vers, found = strings.Cut(arg, \"@\")\n+\tif !found {\n+\t\treturn arg, \"\", false, nil\n+\t}\n+\tif len(vers) > 0 && (vers[0] == '-' || vers[0] == '/') {\n+\t\treturn \"\", \"\", false, fmt.Errorf(\"invalid module version %q\", vers)\n+\t}\n+\treturn path, vers, true, nil\n+}\ndiff --git a/src/cmd/go/internal/toolchain/select.go b/src/cmd/go/internal/toolchain/select.go\nindex 192fb62f..0cb93f67 100644\n--- a/src/cmd/go/internal/toolchain/select.go\n+++ b/src/cmd/go/internal/toolchain/select.go\n@@ -667,7 +667,10 @@ func maybeSwitchForGoInstallVersion(loaderstate *modload.State, minVers string)\n \tif !strings.Contains(pkgArg, \"@\") || build.IsLocalImport(pkgArg) || filepath.IsAbs(pkgArg) {\n \t\treturn\n \t}\n-\tpath, version, _ := strings.Cut(pkgArg, \"@\")\n+\tpath, version, _, err := modload.ParsePathVersion(pkgArg)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n \tif path == \"\" || version == \"\" || gover.IsToolchain(path) {\n \t\treturn\n \t}\n@@ -702,7 +705,7 @@ func maybeSwitchForGoInstallVersion(loaderstate *modload.State, minVers string)\n \t\tallowed = nil\n \t}\n \tnoneSelected := func(path string) (version string) { return \"none\" }\n-\t_, err := modload.QueryPackages(loaderstate, ctx, path, version, noneSelected, allowed)\n+\t_, err = modload.QueryPackages(loaderstate, ctx, path, version, noneSelected, allowed)\n \tif errors.Is(err, gover.ErrTooNew) {\n \t\t// Run early switch, same one go install or go run would eventually do,\n \t\t// if it understood all the command-line flags.\ndiff --git a/src/cmd/go/internal/vcs/vcs.go b/src/cmd/go/internal/vcs/vcs.go\nindex 7c198c5f..9e8efaf2 100644\n--- a/src/cmd/go/internal/vcs/vcs.go\n+++ b/src/cmd/go/internal/vcs/vcs.go\n@@ -17,7 +17,6 @@ import (\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n-\t\"regexp\"\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n@@ -41,20 +40,10 @@ type Cmd struct {\n \tEnv       []string   // any environment values to set/override\n \tRootNames []rootName // filename and mode indicating the root of a checkout directory\n \n-\tCreateCmd   []string // commands to download a fresh copy of a repository\n-\tDownloadCmd []string // commands to download updates into an existing repository\n-\n-\tTagCmd         []tagCmd // commands to list tags\n-\tTagLookupCmd   []tagCmd // commands to lookup tags before running tagSyncCmd\n-\tTagSyncCmd     []string // commands to sync to specific tag\n-\tTagSyncDefault []string // commands to sync to default tag\n-\n \tScheme  []string\n \tPingCmd string\n \n-\tRemoteRepo  func(v *Cmd, rootDir string) (remoteRepo string, err error)\n-\tResolveRepo func(v *Cmd, rootDir, remoteRepo string) (realRepo string, err error)\n-\tStatus      func(v *Cmd, rootDir string) (Status, error)\n+\tStatus func(v *Cmd, rootDir string) (Status, error)\n }\n \n // Status is the current state of a local repository.\n@@ -157,40 +146,16 @@ var vcsHg = &Cmd{\n \tName: \"Mercurial\",\n \tCmd:  \"hg\",\n \n-\t// HGPLAIN=1 turns off additional output that a user may have enabled via\n-\t// config options or certain extensions.\n-\tEnv: []string{\"HGPLAIN=1\"},\n+\t// HGPLAIN=+strictflags turns off additional output that a user may have\n+\t// enabled via config options or certain extensions.\n+\tEnv: []string{\"HGPLAIN=+strictflags\"},\n \tRootNames: []rootName{\n \t\t{filename: \".hg\", isDir: true},\n \t},\n \n-\tCreateCmd:   []string{\"clone -U -- {repo} {dir}\"},\n-\tDownloadCmd: []string{\"pull\"},\n-\n-\t// We allow both tag and branch names as 'tags'\n-\t// for selecting a version. This lets people have\n-\t// a go.release.r60 branch and a go1 branch\n-\t// and make changes in both, without constantly\n-\t// editing .hgtags.\n-\tTagCmd: []tagCmd{\n-\t\t{\"tags\", `^(\\S+)`},\n-\t\t{\"branches\", `^(\\S+)`},\n-\t},\n-\tTagSyncCmd:     []string{\"update -r {tag}\"},\n-\tTagSyncDefault: []string{\"update default\"},\n-\n-\tScheme:     []string{\"https\", \"http\", \"ssh\"},\n-\tPingCmd:    \"identify -- {scheme}://{repo}\",\n-\tRemoteRepo: hgRemoteRepo,\n-\tStatus:     hgStatus,\n-}\n-\n-func hgRemoteRepo(vcsHg *Cmd, rootDir string) (remoteRepo string, err error) {\n-\tout, err := vcsHg.runOutput(rootDir, \"paths default\")\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\treturn strings.TrimSpace(string(out)), nil\n+\tScheme:  []string{\"https\", \"http\", \"ssh\"},\n+\tPingCmd: \"identify -- {scheme}://{repo}\",\n+\tStatus:  hgStatus,\n }\n \n func hgStatus(vcsHg *Cmd, rootDir string) (Status, error) {\n@@ -253,25 +218,6 @@ var vcsGit = &Cmd{\n \t\t{filename: \".git\", isDir: true},\n \t},\n \n-\tCreateCmd:   []string{\"clone -- {repo} {dir}\", \"-go-internal-cd {dir} submodule update --init --recursive\"},\n-\tDownloadCmd: []string{\"pull --ff-only\", \"submodule update --init --recursive\"},\n-\n-\tTagCmd: []tagCmd{\n-\t\t// tags/xxx matches a git tag named xxx\n-\t\t// origin/xxx matches a git branch named xxx on the default remote repository\n-\t\t{\"show-ref\", `(?:tags|origin)/(\\S+)$`},\n-\t},\n-\tTagLookupCmd: []tagCmd{\n-\t\t{\"show-ref tags/{tag} origin/{tag}\", `((?:tags|origin)/\\S+)$`},\n-\t},\n-\tTagSyncCmd: []string{\"checkout {tag}\", \"submodule update --init --recursive\"},\n-\t// both createCmd and downloadCmd update the working dir.\n-\t// No need to do more here. We used to 'checkout master'\n-\t// but that doesn't work if the default branch is not named master.\n-\t// DO NOT add 'checkout master' here.\n-\t// See golang.org/issue/9032.\n-\tTagSyncDefault: []string{\"submodule update --init --recursive\"},\n-\n \tScheme: []string{\"git\", \"https\", \"http\", \"git+ssh\", \"ssh\"},\n \n \t// Leave out the '--' separator in the ls-remote command: git 2.7.4 does not\n@@ -280,54 +226,7 @@ var vcsGit = &Cmd{\n \t// See golang.org/issue/33836.\n \tPingCmd: \"ls-remote {scheme}://{repo}\",\n \n-\tRemoteRepo: gitRemoteRepo,\n-\tStatus:     gitStatus,\n-}\n-\n-// scpSyntaxRe matches the SCP-like addresses used by Git to access\n-// repositories by SSH.\n-var scpSyntaxRe = lazyregexp.New(`^(\\w+)@([\\w.-]+):(.*)$`)\n-\n-func gitRemoteRepo(vcsGit *Cmd, rootDir string) (remoteRepo string, err error) {\n-\tconst cmd = \"config remote.origin.url\"\n-\toutb, err := vcsGit.run1(rootDir, cmd, nil, false)\n-\tif err != nil {\n-\t\t// if it doesn't output any message, it means the config argument is correct,\n-\t\t// but the config value itself doesn't exist\n-\t\tif outb != nil && len(outb) == 0 {\n-\t\t\treturn \"\", errors.New(\"remote origin not found\")\n-\t\t}\n-\t\treturn \"\", err\n-\t}\n-\tout := strings.TrimSpace(string(outb))\n-\n-\tvar repoURL *urlpkg.URL\n-\tif m := scpSyntaxRe.FindStringSubmatch(out); m != nil {\n-\t\t// Match SCP-like syntax and convert it to a URL.\n-\t\t// Eg, \"git@github.com:user/repo\" becomes\n-\t\t// \"ssh://git@github.com/user/repo\".\n-\t\trepoURL = &urlpkg.URL{\n-\t\t\tScheme: \"ssh\",\n-\t\t\tUser:   urlpkg.User(m[1]),\n-\t\t\tHost:   m[2],\n-\t\t\tPath:   m[3],\n-\t\t}\n-\t} else {\n-\t\trepoURL, err = urlpkg.Parse(out)\n-\t\tif err != nil {\n-\t\t\treturn \"\", err\n-\t\t}\n-\t}\n-\n-\t// Iterate over insecure schemes too, because this function simply\n-\t// reports the state of the repo. If we can't see insecure schemes then\n-\t// we can't report the actual repo URL.\n-\tfor _, s := range vcsGit.Scheme {\n-\t\tif repoURL.Scheme == s {\n-\t\t\treturn repoURL.String(), nil\n-\t\t}\n-\t}\n-\treturn \"\", errors.New(\"unable to parse output of git \" + cmd)\n+\tStatus: gitStatus,\n }\n \n func gitStatus(vcsGit *Cmd, rootDir string) (Status, error) {\n@@ -367,62 +266,9 @@ var vcsBzr = &Cmd{\n \t\t{filename: \".bzr\", isDir: true},\n \t},\n \n-\tCreateCmd: []string{\"branch -- {repo} {dir}\"},\n-\n-\t// Without --overwrite bzr will not pull tags that changed.\n-\t// Replace by --overwrite-tags after http://pad.lv/681792 goes in.\n-\tDownloadCmd: []string{\"pull --overwrite\"},\n-\n-\tTagCmd:         []tagCmd{{\"tags\", `^(\\S+)`}},\n-\tTagSyncCmd:     []string{\"update -r {tag}\"},\n-\tTagSyncDefault: []string{\"update -r revno:-1\"},\n-\n-\tScheme:      []string{\"https\", \"http\", \"bzr\", \"bzr+ssh\"},\n-\tPingCmd:     \"info -- {scheme}://{repo}\",\n-\tRemoteRepo:  bzrRemoteRepo,\n-\tResolveRepo: bzrResolveRepo,\n-\tStatus:      bzrStatus,\n-}\n-\n-func bzrRemoteRepo(vcsBzr *Cmd, rootDir string) (remoteRepo string, err error) {\n-\toutb, err := vcsBzr.runOutput(rootDir, \"config parent_location\")\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\treturn strings.TrimSpace(string(outb)), nil\n-}\n-\n-func bzrResolveRepo(vcsBzr *Cmd, rootDir, remoteRepo string) (realRepo string, err error) {\n-\toutb, err := vcsBzr.runOutput(rootDir, \"info \"+remoteRepo)\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tout := string(outb)\n-\n-\t// Expect:\n-\t// ...\n-\t//   (branch root|repository branch): <URL>\n-\t// ...\n-\n-\tfound := false\n-\tfor _, prefix := range []string{\"\\n  branch root: \", \"\\n  repository branch: \"} {\n-\t\ti := strings.Index(out, prefix)\n-\t\tif i >= 0 {\n-\t\t\tout = out[i+len(prefix):]\n-\t\t\tfound = true\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tif !found {\n-\t\treturn \"\", fmt.Errorf(\"unable to parse output of bzr info\")\n-\t}\n-\n-\ti := strings.Index(out, \"\\n\")\n-\tif i < 0 {\n-\t\treturn \"\", fmt.Errorf(\"unable to parse output of bzr info\")\n-\t}\n-\tout = out[:i]\n-\treturn strings.TrimSpace(out), nil\n+\tScheme:  []string{\"https\", \"http\", \"bzr\", \"bzr+ssh\"},\n+\tPingCmd: \"info -- {scheme}://{repo}\",\n+\tStatus:  bzrStatus,\n }\n \n func bzrStatus(vcsBzr *Cmd, rootDir string) (Status, error) {\n@@ -490,46 +336,12 @@ var vcsSvn = &Cmd{\n \t\t{filename: \".svn\", isDir: true},\n \t},\n \n-\tCreateCmd:   []string{\"checkout -- {repo} {dir}\"},\n-\tDownloadCmd: []string{\"update\"},\n-\n \t// There is no tag command in subversion.\n \t// The branch information is all in the path names.\n \n-\tScheme:     []string{\"https\", \"http\", \"svn\", \"svn+ssh\"},\n-\tPingCmd:    \"info -- {scheme}://{repo}\",\n-\tRemoteRepo: svnRemoteRepo,\n-\tStatus:     svnStatus,\n-}\n-\n-func svnRemoteRepo(vcsSvn *Cmd, rootDir string) (remoteRepo string, err error) {\n-\toutb, err := vcsSvn.runOutput(rootDir, \"info\")\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tout := string(outb)\n-\n-\t// Expect:\n-\t//\n-\t//\t ...\n-\t// \tURL: <URL>\n-\t// \t...\n-\t//\n-\t// Note that we're not using the Repository Root line,\n-\t// because svn allows checking out subtrees.\n-\t// The URL will be the URL of the subtree (what we used with 'svn co')\n-\t// while the Repository Root may be a much higher parent.\n-\ti := strings.Index(out, \"\\nURL: \")\n-\tif i < 0 {\n-\t\treturn \"\", fmt.Errorf(\"unable to parse output of svn info\")\n-\t}\n-\tout = out[i+len(\"\\nURL: \"):]\n-\ti = strings.Index(out, \"\\n\")\n-\tif i < 0 {\n-\t\treturn \"\", fmt.Errorf(\"unable to parse output of svn info\")\n-\t}\n-\tout = out[:i]\n-\treturn strings.TrimSpace(out), nil\n+\tScheme:  []string{\"https\", \"http\", \"svn\", \"svn+ssh\"},\n+\tPingCmd: \"info -- {scheme}://{repo}\",\n+\tStatus:  svnStatus,\n }\n \n func svnStatus(vcsSvn *Cmd, rootDir string) (Status, error) {\n@@ -574,24 +386,8 @@ var vcsFossil = &Cmd{\n \t\t{filename: \"_FOSSIL_\", isDir: false},\n \t},\n \n-\tCreateCmd:   []string{\"-go-internal-mkdir {dir} clone -- {repo} \" + filepath.Join(\"{dir}\", fossilRepoName), \"-go-internal-cd {dir} open .fossil\"},\n-\tDownloadCmd: []string{\"up\"},\n-\n-\tTagCmd:         []tagCmd{{\"tag ls\", `(.*)`}},\n-\tTagSyncCmd:     []string{\"up tag:{tag}\"},\n-\tTagSyncDefault: []string{\"up trunk\"},\n-\n-\tScheme:     []string{\"https\", \"http\"},\n-\tRemoteRepo: fossilRemoteRepo,\n-\tStatus:     fossilStatus,\n-}\n-\n-func fossilRemoteRepo(vcsFossil *Cmd, rootDir string) (remoteRepo string, err error) {\n-\tout, err := vcsFossil.runOutput(rootDir, \"remote-url\")\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\treturn strings.TrimSpace(string(out)), nil\n+\tScheme: []string{\"https\", \"http\"},\n+\tStatus: fossilStatus,\n }\n \n var errFossilInfo = errors.New(\"unable to parse output of fossil info\")\n@@ -692,7 +488,7 @@ func (v *Cmd) run1(dir string, cmdline string, keyval []string, verbose bool) ([\n \t\targs[i] = expand(m, arg)\n \t}\n \n-\tif len(args) >= 2 && args[0] == \"-go-internal-mkdir\" {\n+\tif len(args) >= 2 && args[0] == \"--go-internal-mkdir\" {\n \t\tvar err error\n \t\tif filepath.IsAbs(args[1]) {\n \t\t\terr = os.Mkdir(args[1], fs.ModePerm)\n@@ -705,7 +501,7 @@ func (v *Cmd) run1(dir string, cmdline string, keyval []string, verbose bool) ([\n \t\targs = args[2:]\n \t}\n \n-\tif len(args) >= 2 && args[0] == \"-go-internal-cd\" {\n+\tif len(args) >= 2 && args[0] == \"--go-internal-cd\" {\n \t\tif filepath.IsAbs(args[1]) {\n \t\t\tdir = args[1]\n \t\t} else {\n@@ -766,99 +562,6 @@ func (v *Cmd) Ping(scheme, repo string) error {\n \treturn v.runVerboseOnly(dir, v.PingCmd, \"scheme\", scheme, \"repo\", repo)\n }\n \n-// Create creates a new copy of repo in dir.\n-// The parent of dir must exist; dir must not.\n-func (v *Cmd) Create(dir, repo string) error {\n-\trelease, err := base.AcquireNet()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tdefer release()\n-\n-\tfor _, cmd := range v.CreateCmd {\n-\t\tif err := v.run(filepath.Dir(dir), cmd, \"dir\", dir, \"repo\", repo); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// Download downloads any new changes for the repo in dir.\n-func (v *Cmd) Download(dir string) error {\n-\trelease, err := base.AcquireNet()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tdefer release()\n-\n-\tfor _, cmd := range v.DownloadCmd {\n-\t\tif err := v.run(dir, cmd); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// Tags returns the list of available tags for the repo in dir.\n-func (v *Cmd) Tags(dir string) ([]string, error) {\n-\tvar tags []string\n-\tfor _, tc := range v.TagCmd {\n-\t\tout, err := v.runOutput(dir, tc.cmd)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tre := regexp.MustCompile(`(?m-s)` + tc.pattern)\n-\t\tfor _, m := range re.FindAllStringSubmatch(string(out), -1) {\n-\t\t\ttags = append(tags, m[1])\n-\t\t}\n-\t}\n-\treturn tags, nil\n-}\n-\n-// TagSync syncs the repo in dir to the named tag,\n-// which either is a tag returned by tags or is v.tagDefault.\n-func (v *Cmd) TagSync(dir, tag string) error {\n-\tif v.TagSyncCmd == nil {\n-\t\treturn nil\n-\t}\n-\tif tag != \"\" {\n-\t\tfor _, tc := range v.TagLookupCmd {\n-\t\t\tout, err := v.runOutput(dir, tc.cmd, \"tag\", tag)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tre := regexp.MustCompile(`(?m-s)` + tc.pattern)\n-\t\t\tm := re.FindStringSubmatch(string(out))\n-\t\t\tif len(m) > 1 {\n-\t\t\t\ttag = m[1]\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\trelease, err := base.AcquireNet()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tdefer release()\n-\n-\tif tag == \"\" && v.TagSyncDefault != nil {\n-\t\tfor _, cmd := range v.TagSyncDefault {\n-\t\t\tif err := v.run(dir, cmd); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t}\n-\t\treturn nil\n-\t}\n-\n-\tfor _, cmd := range v.TagSyncCmd {\n-\t\tif err := v.run(dir, cmd, \"tag\", tag); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n // A vcsPath describes how to convert an import path into a\n // version control system and repository name.\n type vcsPath struct {\n@@ -1385,6 +1088,10 @@ func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.Se\n \t\t}\n \t}\n \n+\tif err := validateRepoSubDir(mmi.SubDir); err != nil {\n+\t\treturn nil, fmt.Errorf(\"%s: invalid subdirectory %q: %v\", resp.URL, mmi.SubDir, err)\n+\t}\n+\n \tif err := validateRepoRoot(mmi.RepoRoot); err != nil {\n \t\treturn nil, fmt.Errorf(\"%s: invalid repo root %q: %v\", resp.URL, mmi.RepoRoot, err)\n \t}\n@@ -1416,6 +1123,22 @@ func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.Se\n \treturn rr, nil\n }\n \n+// validateRepoSubDir returns an error if subdir is not a valid subdirectory path.\n+// We consider a subdirectory path to be valid as long as it doesn't have a leading\n+// slash (/) or hyphen (-).\n+func validateRepoSubDir(subdir string) error {\n+\tif subdir == \"\" {\n+\t\treturn nil\n+\t}\n+\tif subdir[0] == '/' {\n+\t\treturn errors.New(\"leading slash\")\n+\t}\n+\tif subdir[0] == '-' {\n+\t\treturn errors.New(\"leading hyphen\")\n+\t}\n+\treturn nil\n+}\n+\n // validateRepoRoot returns an error if repoRoot does not seem to be\n // a valid URL with scheme.\n func validateRepoRoot(repoRoot string) error {\ndiff --git a/src/cmd/go/internal/vcs/vcs_test.go b/src/cmd/go/internal/vcs/vcs_test.go\nindex 361d85bc..ab70e517 100644\n--- a/src/cmd/go/internal/vcs/vcs_test.go\n+++ b/src/cmd/go/internal/vcs/vcs_test.go\n@@ -507,6 +507,42 @@ func TestValidateRepoRoot(t *testing.T) {\n \t}\n }\n \n+func TestValidateRepoSubDir(t *testing.T) {\n+\ttests := []struct {\n+\t\tsubdir string\n+\t\tok     bool\n+\t}{\n+\t\t{\n+\t\t\tsubdir: \"\",\n+\t\t\tok:     true,\n+\t\t},\n+\t\t{\n+\t\t\tsubdir: \"sub/dir\",\n+\t\t\tok:     true,\n+\t\t},\n+\t\t{\n+\t\t\tsubdir: \"/leading/slash\",\n+\t\t\tok:     false,\n+\t\t},\n+\t\t{\n+\t\t\tsubdir: \"-leading/hyphen\",\n+\t\t\tok:     false,\n+\t\t},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\terr := validateRepoSubDir(test.subdir)\n+\t\tok := err == nil\n+\t\tif ok != test.ok {\n+\t\t\twant := \"error\"\n+\t\t\tif test.ok {\n+\t\t\t\twant = \"nil\"\n+\t\t\t}\n+\t\t\tt.Errorf(\"validateRepoSubDir(%q) = %q, want %s\", test.subdir, err, want)\n+\t\t}\n+\t}\n+}\n+\n var govcsTests = []struct {\n \tgovcs string\n \tpath  string\ndiff --git a/src/cmd/go/internal/workcmd/edit.go b/src/cmd/go/internal/workcmd/edit.go\nindex b18098ba..9b62dbb1 100644\n--- a/src/cmd/go/internal/workcmd/edit.go\n+++ b/src/cmd/go/internal/workcmd/edit.go\n@@ -279,7 +279,10 @@ func allowedVersionArg(arg string) bool {\n // parsePathVersionOptional parses path[@version], using adj to\n // describe any errors.\n func parsePathVersionOptional(adj, arg string, allowDirPath bool) (path, version string, err error) {\n-\tbefore, after, found := strings.Cut(arg, \"@\")\n+\tbefore, after, found, err := modload.ParsePathVersion(arg)\n+\tif err != nil {\n+\t\treturn \"\", \"\", err\n+\t}\n \tif !found {\n \t\tpath = arg\n \t} else {","output":"fix(modload): add ParsePathVersion to reject versions prefixed with - or","metadata":{"id":"go-94a1296a","repository":"go","commit_hash":"94a1296a457387d1fd6eca1a9bcd44e89bdd9d55"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/crypto/tls/common.go                 |   7 ++-\n src/crypto/tls/handshake_server.go       |   9 ++-\n src/crypto/tls/handshake_server_test.go  | 101 +++++++++++++++++++++++++++++++\n src/crypto/tls/handshake_server_tls13.go |  10 ++-\n src/crypto/tls/tls_test.go               |  11 +++-\n 5 files changed, 132 insertions(+), 6 deletions(-)\n\ndiff --git a/src/crypto/tls/common.go b/src/crypto/tls/common.go\nindex 099a11ca..093869ac 100644\n--- a/src/crypto/tls/common.go\n+++ b/src/crypto/tls/common.go\n@@ -980,6 +980,10 @@ const maxSessionTicketLifetime = 7 * 24 * time.Hour\n \n // Clone returns a shallow clone of c or nil if c is nil. It is safe to clone a [Config] that is\n // being used concurrently by a TLS client or server.\n+//\n+// If Config.SessionTicketKey is unpopulated, and Config.SetSessionTicketKeys has not been\n+// called, the clone will not share the same auto-rotated session ticket keys as the original\n+// Config in order to prevent sessions from being resumed across Configs.\n func (c *Config) Clone() *Config {\n \tif c == nil {\n \t\treturn nil\n@@ -1020,7 +1024,8 @@ func (c *Config) Clone() *Config {\n \t\tEncryptedClientHelloRejectionVerify: c.EncryptedClientHelloRejectionVerify,\n \t\tEncryptedClientHelloKeys:            c.EncryptedClientHelloKeys,\n \t\tsessionTicketKeys:                   c.sessionTicketKeys,\n-\t\tautoSessionTicketKeys:               c.autoSessionTicketKeys,\n+\t\t// We explicitly do not copy autoSessionTicketKeys, so that Configs do\n+\t\t// not share the same auto-rotated keys.\n \t}\n }\n \ndiff --git a/src/crypto/tls/handshake_server.go b/src/crypto/tls/handshake_server.go\nindex efdaeae6..06675a8c 100644\n--- a/src/crypto/tls/handshake_server.go\n+++ b/src/crypto/tls/handshake_server.go\n@@ -520,8 +520,13 @@ func (hs *serverHandshakeState) checkForResumption() error {\n \tif sessionHasClientCerts && c.config.ClientAuth == NoClientCert {\n \t\treturn nil\n \t}\n-\tif sessionHasClientCerts && c.config.time().After(sessionState.peerCertificates[0].NotAfter) {\n-\t\treturn nil\n+\tif sessionHasClientCerts {\n+\t\tnow := c.config.time()\n+\t\tfor _, c := range sessionState.peerCertificates {\n+\t\t\tif now.After(c.NotAfter) {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n \t}\n \tif sessionHasClientCerts && c.config.ClientAuth >= VerifyClientCertIfGiven &&\n \t\tlen(sessionState.verifiedChains) == 0 {\ndiff --git a/src/crypto/tls/handshake_server_test.go b/src/crypto/tls/handshake_server_test.go\nindex 7e35c252..41ae8705 100644\n--- a/src/crypto/tls/handshake_server_test.go\n+++ b/src/crypto/tls/handshake_server_test.go\n@@ -13,6 +13,7 @@ import (\n \t\"crypto/rand\"\n \t\"crypto/tls/internal/fips140tls\"\n \t\"crypto/x509\"\n+\t\"crypto/x509/pkix\"\n \t\"encoding/pem\"\n \t\"errors\"\n \t\"fmt\"\n@@ -2153,3 +2154,103 @@ func TestHandshakeContextHierarchy(t *testing.T) {\n \t\tt.Errorf(\"Unexpected client error: %v\", err)\n \t}\n }\n+\n+func TestHandshakeChainExpiryResumptionTLS12(t *testing.T) {\n+\tt.Run(\"TLS1.2\", func(t *testing.T) {\n+\t\ttestHandshakeChainExpiryResumption(t, VersionTLS12)\n+\t})\n+\tt.Run(\"TLS1.3\", func(t *testing.T) {\n+\t\ttestHandshakeChainExpiryResumption(t, VersionTLS13)\n+\t})\n+}\n+\n+func testHandshakeChainExpiryResumption(t *testing.T, version uint16) {\n+\tnow := time.Now()\n+\tcreateChain := func(leafNotAfter, rootNotAfter time.Time) (certDER []byte, root *x509.Certificate) {\n+\t\ttmpl := &x509.Certificate{\n+\t\t\tSubject:               pkix.Name{CommonName: \"root\"},\n+\t\t\tNotBefore:             rootNotAfter.Add(-time.Hour * 24),\n+\t\t\tNotAfter:              rootNotAfter,\n+\t\t\tIsCA:                  true,\n+\t\t\tBasicConstraintsValid: true,\n+\t\t}\n+\t\trootDER, err := x509.CreateCertificate(rand.Reader, tmpl, tmpl, &testECDSAPrivateKey.PublicKey, testECDSAPrivateKey)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"CreateCertificate: %v\", err)\n+\t\t}\n+\t\troot, err = x509.ParseCertificate(rootDER)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"ParseCertificate: %v\", err)\n+\t\t}\n+\n+\t\ttmpl = &x509.Certificate{\n+\t\t\tSubject:   pkix.Name{},\n+\t\t\tDNSNames:  []string{\"expired-resume.example.com\"},\n+\t\t\tNotBefore: leafNotAfter.Add(-time.Hour * 24),\n+\t\t\tNotAfter:  leafNotAfter,\n+\t\t\tKeyUsage:  x509.KeyUsageDigitalSignature,\n+\t\t}\n+\t\tcertDER, err = x509.CreateCertificate(rand.Reader, tmpl, root, &testECDSAPrivateKey.PublicKey, testECDSAPrivateKey)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"CreateCertificate: %v\", err)\n+\t\t}\n+\n+\t\treturn certDER, root\n+\t}\n+\n+\tinitialLeafDER, initialRoot := createChain(now.Add(time.Hour), now.Add(2*time.Hour))\n+\n+\tserverConfig := testConfig.Clone()\n+\tserverConfig.MaxVersion = version\n+\tserverConfig.Certificates = []Certificate{{\n+\t\tCertificate: [][]byte{initialLeafDER},\n+\t\tPrivateKey:  testECDSAPrivateKey,\n+\t}}\n+\tserverConfig.ClientCAs = x509.NewCertPool()\n+\tserverConfig.ClientCAs.AddCert(initialRoot)\n+\tserverConfig.ClientAuth = RequireAndVerifyClientCert\n+\tserverConfig.Time = func() time.Time {\n+\t\treturn now\n+\t}\n+\n+\tclientConfig := testConfig.Clone()\n+\tclientConfig.MaxVersion = version\n+\tclientConfig.Certificates = []Certificate{{\n+\t\tCertificate: [][]byte{initialLeafDER},\n+\t\tPrivateKey:  testECDSAPrivateKey,\n+\t}}\n+\tclientConfig.RootCAs = x509.NewCertPool()\n+\tclientConfig.RootCAs.AddCert(initialRoot)\n+\tclientConfig.ServerName = \"expired-resume.example.com\"\n+\tclientConfig.ClientSessionCache = NewLRUClientSessionCache(32)\n+\n+\ttestResume := func(t *testing.T, sc, cc *Config, expectResume bool) {\n+\t\tt.Helper()\n+\t\tss, cs, err := testHandshake(t, cc, sc)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"handshake: %v\", err)\n+\t\t}\n+\t\tif cs.DidResume != expectResume {\n+\t\t\tt.Fatalf(\"DidResume = %v; want %v\", cs.DidResume, expectResume)\n+\t\t}\n+\t\tif ss.DidResume != expectResume {\n+\t\t\tt.Fatalf(\"DidResume = %v; want %v\", cs.DidResume, expectResume)\n+\t\t}\n+\t}\n+\n+\ttestResume(t, serverConfig, clientConfig, false)\n+\ttestResume(t, serverConfig, clientConfig, true)\n+\n+\tfreshLeafDER, freshRoot := createChain(now.Add(2*time.Hour), now.Add(3*time.Hour))\n+\tclientConfig.Certificates = []Certificate{{\n+\t\tCertificate: [][]byte{freshLeafDER},\n+\t\tPrivateKey:  testECDSAPrivateKey,\n+\t}}\n+\tserverConfig.Time = func() time.Time {\n+\t\treturn now.Add(1*time.Hour + 30*time.Minute)\n+\t}\n+\tserverConfig.ClientCAs = x509.NewCertPool()\n+\tserverConfig.ClientCAs.AddCert(freshRoot)\n+\n+\ttestResume(t, serverConfig, clientConfig, false)\n+}\ndiff --git a/src/crypto/tls/handshake_server_tls13.go b/src/crypto/tls/handshake_server_tls13.go\nindex b066924e..0033164f 100644\n--- a/src/crypto/tls/handshake_server_tls13.go\n+++ b/src/crypto/tls/handshake_server_tls13.go\n@@ -314,6 +314,7 @@ func (hs *serverHandshakeStateTLS13) checkForResumption() error {\n \t\treturn nil\n \t}\n \n+pskIdentityLoop:\n \tfor i, identity := range hs.clientHello.pskIdentities {\n \t\tif i >= maxClientPSKIdentities {\n \t\t\tbreak\n@@ -366,8 +367,13 @@ func (hs *serverHandshakeStateTLS13) checkForResumption() error {\n \t\tif sessionHasClientCerts && c.config.ClientAuth == NoClientCert {\n \t\t\tcontinue\n \t\t}\n-\t\tif sessionHasClientCerts && c.config.time().After(sessionState.peerCertificates[0].NotAfter) {\n-\t\t\tcontinue\n+\t\tif sessionHasClientCerts {\n+\t\t\tnow := c.config.time()\n+\t\t\tfor _, c := range sessionState.peerCertificates {\n+\t\t\t\tif now.After(c.NotAfter) {\n+\t\t\t\t\tcontinue pskIdentityLoop\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tif sessionHasClientCerts && c.config.ClientAuth >= VerifyClientCertIfGiven &&\n \t\t\tlen(sessionState.verifiedChains) == 0 {\ndiff --git a/src/crypto/tls/tls_test.go b/src/crypto/tls/tls_test.go\nindex 39ebb9d2..48428e4c 100644\n--- a/src/crypto/tls/tls_test.go\n+++ b/src/crypto/tls/tls_test.go\n@@ -935,8 +935,8 @@ func TestCloneNonFuncFields(t *testing.T) {\n \t\t}\n \t}\n \t// Set the unexported fields related to session ticket keys, which are copied with Clone().\n-\tc1.autoSessionTicketKeys = []ticketKey{c1.ticketKeyFromBytes(c1.SessionTicketKey)}\n \tc1.sessionTicketKeys = []ticketKey{c1.ticketKeyFromBytes(c1.SessionTicketKey)}\n+\t// We explicitly don't copy autoSessionTicketKeys in Clone, so don't set it.\n \n \tc2 := c1.Clone()\n \tif !reflect.DeepEqual(&c1, c2) {\n@@ -2461,3 +2461,12 @@ func (s messageOnlySigner) SignMessage(rand io.Reader, msg []byte, opts crypto.S\n \tdigest := h.Sum(nil)\n \treturn s.Signer.Sign(rand, digest, opts)\n }\n+\n+func TestConfigCloneAutoSessionTicketKeys(t *testing.T) {\n+\torig := &Config{}\n+\torig.ticketKeys(nil)\n+\tclone := orig.Clone()\n+\tif slices.Equal(orig.autoSessionTicketKeys, clone.autoSessionTicketKeys) {\n+\t\tt.Fatal(\"autoSessionTicketKeys slice copied in Clone\")\n+\t}\n+}","output":"fix(tls): check all chain certs for expiry on session resumption","metadata":{"id":"go-bba24719","repository":"go","commit_hash":"bba24719a4cad5cc8d771fc9cfff5a38019d554a"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/sort/sort.go | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/sort/sort.go b/src/sort/sort.go\nindex fd3cd6da..087e7d03 100644\n--- a/src/sort/sort.go\n+++ b/src/sort/sort.go\n@@ -197,7 +197,7 @@ func Float64sAreSorted(x []float64) bool { return slices.IsSorted(x) }\n func StringsAreSorted(x []string) bool { return slices.IsSorted(x) }\n \n // Notes on stable sorting:\n-// The used algorithms are simple and provable correct on all input and use\n+// The used algorithms are simple and provably correct on all input and use\n // only logarithmic additional stack space. They perform well if compared\n // experimentally to other stable in-place sorting algorithms.\n //","output":"docs: fix typo in sort package comments","metadata":{"id":"go-9ef26e96","repository":"go","commit_hash":"9ef26e96e3ae1e3a3d5e01a9b7fd1fa4dc5d6dd5"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" .../internal/fips140test/cast_fips140v1.26_test.go | 16 -----------\n ...ast_fips140v1.0_test.go => fips140v1.0_test.go} |  4 +++\n .../internal/fips140test/fips140v1.26_test.go      | 33 ++++++++++++++++++++++\n src/crypto/internal/fips140test/fips_test.go       |  2 ++\n 4 files changed, 39 insertions(+), 16 deletions(-)\n\ndiff --git a/src/crypto/internal/fips140test/cast_fips140v1.26_test.go b/src/crypto/internal/fips140test/cast_fips140v1.26_test.go\ndeleted file mode 100644\nindex ef79068c..00000000\n--- a/src/crypto/internal/fips140test/cast_fips140v1.26_test.go\n+++ /dev/null\n@@ -1,16 +0,0 @@\n-// Copyright 2024 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-//go:build !fips140v1.0\n-\n-package fipstest\n-\n-import \"crypto/internal/fips140/mldsa\"\n-\n-func fips140v126Conditionals() {\n-\t// ML-DSA sign and verify PCT\n-\tkMLDSA := mldsa.GenerateKey44()\n-\t// ML-DSA-44\n-\tmldsa.SignDeterministic(kMLDSA, make([]byte, 32), \"\")\n-}\ndiff --git a/src/crypto/internal/fips140test/cast_fips140v1.0_test.go b/src/crypto/internal/fips140test/fips140v1.0_test.go\nsimilarity index 75%\nrename from src/crypto/internal/fips140test/cast_fips140v1.0_test.go\nrename to src/crypto/internal/fips140test/fips140v1.0_test.go\nindex b9ddfe4d..262ef61d 100644\n--- a/src/crypto/internal/fips140test/cast_fips140v1.0_test.go\n+++ b/src/crypto/internal/fips140test/fips140v1.0_test.go\n@@ -6,4 +6,8 @@\n \n package fipstest\n \n+import \"testing\"\n+\n func fips140v126Conditionals() {}\n+\n+func testFIPS140v126(t *testing.T, plaintext []byte) {}\ndiff --git a/src/crypto/internal/fips140test/fips140v1.26_test.go b/src/crypto/internal/fips140test/fips140v1.26_test.go\nnew file mode 100644\nindex 00000000..6cd9f4fe\n--- /dev/null\n+++ b/src/crypto/internal/fips140test/fips140v1.26_test.go\n@@ -0,0 +1,33 @@\n+// Copyright 2024 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//go:build !fips140v1.0\n+\n+package fipstest\n+\n+import (\n+\t\"crypto/internal/fips140/mldsa\"\n+\t\"testing\"\n+)\n+\n+func fips140v126Conditionals() {\n+\t// ML-DSA sign and verify PCT\n+\tkMLDSA := mldsa.GenerateKey44()\n+\t// ML-DSA-44\n+\tmldsa.SignDeterministic(kMLDSA, make([]byte, 32), \"\")\n+}\n+\n+func testFIPS140v126(t *testing.T, plaintext []byte) {\n+\tt.Run(\"ML-DSA KeyGen, SigGen, SigVer\", func(t *testing.T) {\n+\t\tensureServiceIndicator(t)\n+\t\tk := mldsa.GenerateKey44()\n+\n+\t\tsig, err := mldsa.SignDeterministic(k, plaintext, \"\")\n+\t\tfatalIfErr(t, err)\n+\t\tt.Logf(\"ML-DSA signature: %x\", sig)\n+\n+\t\terr = mldsa.Verify(k.PublicKey(), plaintext, sig, \"\")\n+\t\tfatalIfErr(t, err)\n+\t})\n+}\ndiff --git a/src/crypto/internal/fips140test/fips_test.go b/src/crypto/internal/fips140test/fips_test.go\nindex 52fc9d34..7f2824ca 100644\n--- a/src/crypto/internal/fips140test/fips_test.go\n+++ b/src/crypto/internal/fips140test/fips_test.go\n@@ -101,6 +101,8 @@ func TestFIPS140(t *testing.T) {\n \taesBlock, err := aes.New(aesKey)\n \tfatalIfErr(t, err)\n \n+\ttestFIPS140v126(t, plaintext)\n+\n \tt.Run(\"AES-CTR\", func(t *testing.T) {\n \t\tensureServiceIndicator(t)\n \t\tctr := aes.NewCTR(aesBlock, aesIV)","output":"test(fips140): add ML-DSA tests and reorganize version conditionals","metadata":{"id":"go-2bc4315d","repository":"go","commit_hash":"2bc4315d92a70d9a5e895d60defba4f799798806"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/simd/archsimd/_gen/simdgen/gen_simdTypes.go |  97 ++++++++++++++++++-\n src/simd/archsimd/_gen/simdgen/xed.go           | 121 +++++++++++++++---------\n src/simd/archsimd/cpu.go                        |  38 ++++++--\n src/simd/archsimd/ops_amd64.go                  |  12 +--\n 4 files changed, 205 insertions(+), 63 deletions(-)\n\ndiff --git a/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go b/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go\nindex dd3a75eb..4f1c70e2 100644\n--- a/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go\n+++ b/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go\n@@ -189,6 +189,7 @@ type X86Features struct {}\n var X86 X86Features\n \n {{range .}}\n+{{$f := .}}\n {{- if eq .Feature \"AVX512\"}}\n // {{.Feature}} returns whether the CPU supports the AVX512F+CD+BW+DQ+VL features.\n //\n@@ -199,11 +200,19 @@ var X86 X86Features\n {{- else -}}\n // {{.Feature}} returns whether the CPU supports the {{.Feature}} feature.\n {{- end}}\n+{{- if ne .ImpliesAll \"\"}}\n+//\n+// If it returns true, then the CPU also supports {{.ImpliesAll}}.\n+{{- end}}\n //\n // {{.Feature}} is defined on all GOARCHes, but will only return true on\n // GOARCH {{.GoArch}}.\n-func (X86Features) {{.Feature}}() bool {\n-\treturn cpu.X86.Has{{.Feature}}\n+func ({{.FeatureVar}}Features) {{.Feature}}() bool {\n+{{- if .Virtual}}\n+\treturn {{range $i, $dep := .Implies}}{{if $i}} && {{end}}cpu.{{$f.FeatureVar}}.Has{{$dep}}{{end}}\n+{{- else}}\n+\treturn cpu.{{.FeatureVar}}.Has{{.Feature}}\n+{{- end}}\n }\n {{end}}\n `\n@@ -591,6 +600,65 @@ func writeSIMDTypes(typeMap simdTypeMap) *bytes.Buffer {\n \treturn buffer\n }\n \n+type goarchFeatures struct {\n+\t// featureVar is the name of the exported feature-check variable for this\n+\t// architecture.\n+\tfeatureVar string\n+\n+\t// features records per-feature information.\n+\tfeatures map[string]featureInfo\n+}\n+\n+type featureInfo struct {\n+\t// Implies is a list of other CPU features that are required for this\n+\t// feature. These are allowed to chain.\n+\t//\n+\t// For example, if the Frob feature lists \"Baz\", then if X.Frob() returns\n+\t// true, it must also be true that the CPU has feature Baz.\n+\tImplies []string\n+\n+\t// Virtual means this feature is not represented directly in internal/cpu,\n+\t// but is instead the logical AND of the features in Implies.\n+\tVirtual bool\n+}\n+\n+// goarchFeatureInfo maps from GOARCH to CPU feature to additional information\n+// about that feature. Not all features need to be in this map.\n+var goarchFeatureInfo = make(map[string]goarchFeatures)\n+\n+func registerFeatureInfo(goArch string, features goarchFeatures) {\n+\tgoarchFeatureInfo[goArch] = features\n+}\n+\n+func featureImplies(goarch string, base string) string {\n+\t// Compute the transitive closure of base.\n+\tvar list []string\n+\tvar visit func(f string)\n+\tvisit = func(f string) {\n+\t\tlist = append(list, f)\n+\t\tfor _, dep := range goarchFeatureInfo[goarch].features[f].Implies {\n+\t\t\tvisit(dep)\n+\t\t}\n+\t}\n+\tvisit(base)\n+\t// Drop base\n+\tlist = list[1:]\n+\t// Put in \"nice\" order\n+\tslices.Reverse(list)\n+\t// Combine into a comment-ready form\n+\tswitch len(list) {\n+\tcase 0:\n+\t\treturn \"\"\n+\tcase 1:\n+\t\treturn list[0]\n+\tcase 2:\n+\t\treturn list[0] + \" and \" + list[1]\n+\tdefault:\n+\t\tlist[len(list)-1] = \"and \" + list[len(list)-1]\n+\t\treturn strings.Join(list, \", \")\n+\t}\n+}\n+\n func writeSIMDFeatures(ops []Operation) *bytes.Buffer {\n \t// Gather all features\n \ttype featureKey struct {\n@@ -606,13 +674,36 @@ func writeSIMDFeatures(ops []Operation) *bytes.Buffer {\n \t\t\tfeatureSet[featureKey{op.GoArch, feature}] = struct{}{}\n \t\t}\n \t}\n-\tfeatures := slices.SortedFunc(maps.Keys(featureSet), func(a, b featureKey) int {\n+\tfeatureKeys := slices.SortedFunc(maps.Keys(featureSet), func(a, b featureKey) int {\n \t\tif c := cmp.Compare(a.GoArch, b.GoArch); c != 0 {\n \t\t\treturn c\n \t\t}\n \t\treturn compareNatural(a.Feature, b.Feature)\n \t})\n \n+\t// TODO: internal/cpu doesn't enforce these at all. You can even do\n+\t// GODEBUG=cpu.avx=off and it will happily turn off AVX without turning off\n+\t// AVX2. We need to push these dependencies into it somehow.\n+\ttype feature struct {\n+\t\tfeatureKey\n+\t\tFeatureVar string\n+\t\tVirtual    bool\n+\t\tImplies    []string\n+\t\tImpliesAll string\n+\t}\n+\tvar features []feature\n+\tfor _, k := range featureKeys {\n+\t\tfeatureVar := goarchFeatureInfo[k.GoArch].featureVar\n+\t\tfi := goarchFeatureInfo[k.GoArch].features[k.Feature]\n+\t\tfeatures = append(features, feature{\n+\t\t\tfeatureKey: k,\n+\t\t\tFeatureVar: featureVar,\n+\t\t\tVirtual:    fi.Virtual,\n+\t\t\tImplies:    fi.Implies,\n+\t\t\tImpliesAll: featureImplies(k.GoArch, k.Feature),\n+\t\t})\n+\t}\n+\n \t// If we ever have the same feature name on more than one GOARCH, we'll have\n \t// to be more careful about this.\n \tt := templateOf(simdFeaturesTemplate, \"features\")\ndiff --git a/src/simd/archsimd/_gen/simdgen/xed.go b/src/simd/archsimd/_gen/simdgen/xed.go\nindex 4ba6738e..49bedc9b 100644\n--- a/src/simd/archsimd/_gen/simdgen/xed.go\n+++ b/src/simd/archsimd/_gen/simdgen/xed.go\n@@ -5,7 +5,6 @@\n package main\n \n import (\n-\t\"cmp\"\n \t\"fmt\"\n \t\"log\"\n \t\"maps\"\n@@ -210,16 +209,9 @@ func loadXED(xedPath string) []*unify.Value {\n \t\t\t}\n \t\t\tlog.Printf(\"%d unhandled CPU features for %d instructions (use -v for details)\", len(unknownFeatures), nInst)\n \t\t} else {\n-\t\t\tkeys := slices.SortedFunc(maps.Keys(unknownFeatures), func(a, b cpuFeatureKey) int {\n-\t\t\t\treturn cmp.Or(cmp.Compare(a.Extension, b.Extension),\n-\t\t\t\t\tcmp.Compare(a.ISASet, b.ISASet))\n-\t\t\t})\n+\t\t\tkeys := slices.Sorted(maps.Keys(unknownFeatures))\n \t\t\tfor _, key := range keys {\n-\t\t\t\tif key.ISASet == \"\" || key.ISASet == key.Extension {\n-\t\t\t\t\tlog.Printf(\"unhandled Extension %s\", key.Extension)\n-\t\t\t\t} else {\n-\t\t\t\t\tlog.Printf(\"unhandled Extension %s and ISASet %s\", key.Extension, key.ISASet)\n-\t\t\t\t}\n+\t\t\t\tlog.Printf(\"unhandled ISASet %s\", key)\n \t\t\t\tlog.Printf(\"  opcodes: %s\", slices.Sorted(maps.Keys(unknownFeatures[key])))\n \t\t\t}\n \t\t}\n@@ -763,16 +755,24 @@ func instToUVal1(inst *xeddata.Inst, ops []operand, feature string, variant inst\n // decodeCPUFeature returns the CPU feature name required by inst. These match\n // the names of the \"Has*\" feature checks in the simd package.\n func decodeCPUFeature(inst *xeddata.Inst) (string, bool) {\n-\tkey := cpuFeatureKey{\n-\t\tExtension: inst.Extension,\n-\t\tISASet:    isaSetStrip.ReplaceAllLiteralString(inst.ISASet, \"\"),\n+\tisaSet := inst.ISASet\n+\tif isaSet == \"\" {\n+\t\t// Older instructions don't have an ISA set. Use their \"extension\"\n+\t\t// instead.\n+\t\tisaSet = inst.Extension\n+\t}\n+\t// We require AVX512VL to use AVX512 at all, so strip off the vector length\n+\t// suffixes.\n+\tif strings.HasPrefix(isaSet, \"AVX512\") {\n+\t\tisaSet = isaSetVL.ReplaceAllLiteralString(isaSet, \"\")\n \t}\n-\tfeat, ok := cpuFeatureMap[key]\n+\n+\tfeat, ok := cpuFeatureMap[isaSet]\n \tif !ok {\n-\t\timap := unknownFeatures[key]\n+\t\timap := unknownFeatures[isaSet]\n \t\tif imap == nil {\n \t\t\timap = make(map[string]struct{})\n-\t\t\tunknownFeatures[key] = imap\n+\t\t\tunknownFeatures[isaSet] = imap\n \t\t}\n \t\timap[inst.Opcode()] = struct{}{}\n \t\treturn \"\", false\n@@ -783,45 +783,74 @@ func decodeCPUFeature(inst *xeddata.Inst) (string, bool) {\n \treturn feat, true\n }\n \n-var isaSetStrip = regexp.MustCompile(\"_(128N?|256N?|512)$\")\n-\n-type cpuFeatureKey struct {\n-\tExtension, ISASet string\n-}\n-\n-// cpuFeatureMap maps from XED's \"EXTENSION\" and \"ISA_SET\" to a CPU feature name\n-// that can be used in the SIMD API.\n-var cpuFeatureMap = map[cpuFeatureKey]string{\n-\t{\"SHA\", \"SHA\"}: \"SHA\",\n+var isaSetVL = regexp.MustCompile(\"_(128N?|256N?|512)$\")\n \n-\t{\"AVX\", \"\"}:              \"AVX\",\n-\t{\"AVX_VNNI\", \"AVX_VNNI\"}: \"AVXVNNI\",\n-\t{\"AVX2\", \"\"}:             \"AVX2\",\n-\t{\"AVXAES\", \"\"}:           \"AVX, AES\",\n+// cpuFeatureMap maps from XED's \"ISA_SET\" (or \"EXTENSION\") to a CPU feature\n+// name to expose in the SIMD feature check API.\n+//\n+// See XED's datafiles/*/cpuid.xed.txt for how ISA set names map to CPUID flags.\n+var cpuFeatureMap = map[string]string{\n+\t\"AVX\":      \"AVX\",\n+\t\"AVX_VNNI\": \"AVXVNNI\",\n+\t\"AVX2\":     \"AVX2\",\n+\t\"AVXAES\":   \"AVXAES\",\n+\t\"SHA\":      \"SHA\",\n \n \t// AVX-512 foundational features. We combine all of these into one \"AVX512\" feature.\n-\t{\"AVX512EVEX\", \"AVX512F\"}:  \"AVX512\",\n-\t{\"AVX512EVEX\", \"AVX512CD\"}: \"AVX512\",\n-\t{\"AVX512EVEX\", \"AVX512BW\"}: \"AVX512\",\n-\t{\"AVX512EVEX\", \"AVX512DQ\"}: \"AVX512\",\n-\t// AVX512VL doesn't appear explicitly in the ISASet. I guess it's implied by\n-\t// the vector length suffix.\n+\t\"AVX512F\":  \"AVX512\",\n+\t\"AVX512BW\": \"AVX512\",\n+\t\"AVX512CD\": \"AVX512\",\n+\t\"AVX512DQ\": \"AVX512\",\n+\t// AVX512VL doesn't appear as its own ISASet; instead, the CPUID flag is\n+\t// required by the *_128 and *_256 ISASets. We fold it into \"AVX512\" anyway.\n \n \t// AVX-512 extension features\n-\t{\"AVX512EVEX\", \"AVX512_BITALG\"}:     \"AVX512BITALG\",\n-\t{\"AVX512EVEX\", \"AVX512_GFNI\"}:       \"AVX512GFNI\",\n-\t{\"AVX512EVEX\", \"AVX512_VBMI2\"}:      \"AVX512VBMI2\",\n-\t{\"AVX512EVEX\", \"AVX512_VBMI\"}:       \"AVX512VBMI\",\n-\t{\"AVX512EVEX\", \"AVX512_VNNI\"}:       \"AVX512VNNI\",\n-\t{\"AVX512EVEX\", \"AVX512_VPOPCNTDQ\"}:  \"AVX512VPOPCNTDQ\",\n-\t{\"AVX512EVEX\", \"AVX512_VAES\"}:       \"AVX512VAES\",\n-\t{\"AVX512EVEX\", \"AVX512_VPCLMULQDQ\"}: \"AVX512VPCLMULQDQ\",\n+\t\"AVX512_BITALG\":     \"AVX512BITALG\",\n+\t\"AVX512_GFNI\":       \"AVX512GFNI\",\n+\t\"AVX512_VBMI\":       \"AVX512VBMI\",\n+\t\"AVX512_VBMI2\":      \"AVX512VBMI2\",\n+\t\"AVX512_VNNI\":       \"AVX512VNNI\",\n+\t\"AVX512_VPOPCNTDQ\":  \"AVX512VPOPCNTDQ\",\n+\t\"AVX512_VAES\":       \"AVX512VAES\",\n+\t\"AVX512_VPCLMULQDQ\": \"AVX512VPCLMULQDQ\",\n \n \t// AVX 10.2 (not yet supported)\n-\t{\"AVX512EVEX\", \"AVX10_2_RC\"}: \"ignore\",\n+\t\"AVX10_2_RC\": \"ignore\",\n+}\n+\n+func init() {\n+\t// TODO: In general, Intel doesn't make any guarantees about what flags are\n+\t// set, so this means our feature checks need to ensure these, just to be\n+\t// sure.\n+\tvar features = map[string]featureInfo{\n+\t\t\"AVX2\":   {Implies: []string{\"AVX\"}},\n+\t\t\"AVX512\": {Implies: []string{\"AVX2\"}},\n+\n+\t\t\"AVXAES\": {Virtual: true, Implies: []string{\"AVX\", \"AES\"}},\n+\n+\t\t// AVX-512 subfeatures.\n+\t\t\"AVX512BITALG\":    {Implies: []string{\"AVX512\"}},\n+\t\t\"AVX512GFNI\":      {Implies: []string{\"AVX512\"}},\n+\t\t\"AVX512VBMI\":      {Implies: []string{\"AVX512\"}},\n+\t\t\"AVX512VBMI2\":     {Implies: []string{\"AVX512\"}},\n+\t\t\"AVX512VNNI\":      {Implies: []string{\"AVX512\"}},\n+\t\t\"AVX512VPOPCNTDQ\": {Implies: []string{\"AVX512\"}},\n+\t\t\"AVX512VAES\":      {Implies: []string{\"AVX512\"}},\n+\n+\t\t// AVX-VNNI and AVX-IFMA are \"backports\" of the AVX512-VNNI/IFMA\n+\t\t// instructions to VEX encoding, limited to 256 bit vectors. They're\n+\t\t// intended for lower end CPUs that want to support VNNI/IFMA without\n+\t\t// supporting AVX-512. As such, they're built on AVX2's VEX encoding.\n+\t\t\"AVXVNNI\": {Implies: []string{\"AVX2\"}},\n+\t\t\"AVXIFMA\": {Implies: []string{\"AVX2\"}},\n+\t}\n+\tregisterFeatureInfo(\"amd64\", goarchFeatures{\n+\t\tfeatureVar: \"X86\",\n+\t\tfeatures:   features,\n+\t})\n }\n \n-var unknownFeatures = map[cpuFeatureKey]map[string]struct{}{}\n+var unknownFeatures = map[string]map[string]struct{}{}\n \n // hasOptionalMask returns whether there is an optional mask operand in ops.\n func hasOptionalMask(ops []operand) bool {\ndiff --git a/src/simd/archsimd/cpu.go b/src/simd/archsimd/cpu.go\nindex d0c0ff54..1cd76526 100644\n--- a/src/simd/archsimd/cpu.go\n+++ b/src/simd/archsimd/cpu.go\n@@ -10,14 +10,6 @@ type X86Features struct{}\n \n var X86 X86Features\n \n-// AES returns whether the CPU supports the AES feature.\n-//\n-// AES is defined on all GOARCHes, but will only return true on\n-// GOARCH amd64.\n-func (X86Features) AES() bool {\n-\treturn cpu.X86.HasAES\n-}\n-\n // AVX returns whether the CPU supports the AVX feature.\n //\n // AVX is defined on all GOARCHes, but will only return true on\n@@ -28,6 +20,8 @@ func (X86Features) AVX() bool {\n \n // AVX2 returns whether the CPU supports the AVX2 feature.\n //\n+// If it returns true, then the CPU also supports AVX.\n+//\n // AVX2 is defined on all GOARCHes, but will only return true on\n // GOARCH amd64.\n func (X86Features) AVX2() bool {\n@@ -41,6 +35,8 @@ func (X86Features) AVX2() bool {\n // Nearly every CPU that has shipped with any support for AVX-512 has\n // supported all five of these features.\n //\n+// If it returns true, then the CPU also supports AVX and AVX2.\n+//\n // AVX512 is defined on all GOARCHes, but will only return true on\n // GOARCH amd64.\n func (X86Features) AVX512() bool {\n@@ -49,6 +45,8 @@ func (X86Features) AVX512() bool {\n \n // AVX512BITALG returns whether the CPU supports the AVX512BITALG feature.\n //\n+// If it returns true, then the CPU also supports AVX, AVX2, and AVX512.\n+//\n // AVX512BITALG is defined on all GOARCHes, but will only return true on\n // GOARCH amd64.\n func (X86Features) AVX512BITALG() bool {\n@@ -57,6 +55,8 @@ func (X86Features) AVX512BITALG() bool {\n \n // AVX512GFNI returns whether the CPU supports the AVX512GFNI feature.\n //\n+// If it returns true, then the CPU also supports AVX, AVX2, and AVX512.\n+//\n // AVX512GFNI is defined on all GOARCHes, but will only return true on\n // GOARCH amd64.\n func (X86Features) AVX512GFNI() bool {\n@@ -65,6 +65,8 @@ func (X86Features) AVX512GFNI() bool {\n \n // AVX512VAES returns whether the CPU supports the AVX512VAES feature.\n //\n+// If it returns true, then the CPU also supports AVX, AVX2, and AVX512.\n+//\n // AVX512VAES is defined on all GOARCHes, but will only return true on\n // GOARCH amd64.\n func (X86Features) AVX512VAES() bool {\n@@ -73,6 +75,8 @@ func (X86Features) AVX512VAES() bool {\n \n // AVX512VBMI returns whether the CPU supports the AVX512VBMI feature.\n //\n+// If it returns true, then the CPU also supports AVX, AVX2, and AVX512.\n+//\n // AVX512VBMI is defined on all GOARCHes, but will only return true on\n // GOARCH amd64.\n func (X86Features) AVX512VBMI() bool {\n@@ -81,6 +85,8 @@ func (X86Features) AVX512VBMI() bool {\n \n // AVX512VBMI2 returns whether the CPU supports the AVX512VBMI2 feature.\n //\n+// If it returns true, then the CPU also supports AVX, AVX2, and AVX512.\n+//\n // AVX512VBMI2 is defined on all GOARCHes, but will only return true on\n // GOARCH amd64.\n func (X86Features) AVX512VBMI2() bool {\n@@ -89,6 +95,8 @@ func (X86Features) AVX512VBMI2() bool {\n \n // AVX512VNNI returns whether the CPU supports the AVX512VNNI feature.\n //\n+// If it returns true, then the CPU also supports AVX, AVX2, and AVX512.\n+//\n // AVX512VNNI is defined on all GOARCHes, but will only return true on\n // GOARCH amd64.\n func (X86Features) AVX512VNNI() bool {\n@@ -105,14 +113,28 @@ func (X86Features) AVX512VPCLMULQDQ() bool {\n \n // AVX512VPOPCNTDQ returns whether the CPU supports the AVX512VPOPCNTDQ feature.\n //\n+// If it returns true, then the CPU also supports AVX, AVX2, and AVX512.\n+//\n // AVX512VPOPCNTDQ is defined on all GOARCHes, but will only return true on\n // GOARCH amd64.\n func (X86Features) AVX512VPOPCNTDQ() bool {\n \treturn cpu.X86.HasAVX512VPOPCNTDQ\n }\n \n+// AVXAES returns whether the CPU supports the AVXAES feature.\n+//\n+// If it returns true, then the CPU also supports AES and AVX.\n+//\n+// AVXAES is defined on all GOARCHes, but will only return true on\n+// GOARCH amd64.\n+func (X86Features) AVXAES() bool {\n+\treturn cpu.X86.HasAVX && cpu.X86.HasAES\n+}\n+\n // AVXVNNI returns whether the CPU supports the AVXVNNI feature.\n //\n+// If it returns true, then the CPU also supports AVX and AVX2.\n+//\n // AVXVNNI is defined on all GOARCHes, but will only return true on\n // GOARCH amd64.\n func (X86Features) AVXVNNI() bool {\ndiff --git a/src/simd/archsimd/ops_amd64.go b/src/simd/archsimd/ops_amd64.go\nindex bb162c4f..d65c7dde 100644\n--- a/src/simd/archsimd/ops_amd64.go\n+++ b/src/simd/archsimd/ops_amd64.go\n@@ -11,7 +11,7 @@ package archsimd\n // y is the chunk of dw array in use.\n // result = AddRoundKey(InvShiftRows(InvSubBytes(x)), y)\n //\n-// Asm: VAESDECLAST, CPU Feature: AVX, AES\n+// Asm: VAESDECLAST, CPU Feature: AVXAES\n func (x Uint8x16) AESDecryptLastRound(y Uint32x4) Uint8x16\n \n // AESDecryptLastRound performs a series of operations in AES cipher algorithm defined in FIPS 197.\n@@ -37,7 +37,7 @@ func (x Uint8x64) AESDecryptLastRound(y Uint32x16) Uint8x64\n // y is the chunk of dw array in use.\n // result = AddRoundKey(InvMixColumns(InvShiftRows(InvSubBytes(x))), y)\n //\n-// Asm: VAESDEC, CPU Feature: AVX, AES\n+// Asm: VAESDEC, CPU Feature: AVXAES\n func (x Uint8x16) AESDecryptOneRound(y Uint32x4) Uint8x16\n \n // AESDecryptOneRound performs a series of operations in AES cipher algorithm defined in FIPS 197.\n@@ -63,7 +63,7 @@ func (x Uint8x64) AESDecryptOneRound(y Uint32x16) Uint8x64\n // y is the chunk of w array in use.\n // result = AddRoundKey((ShiftRows(SubBytes(x))), y)\n //\n-// Asm: VAESENCLAST, CPU Feature: AVX, AES\n+// Asm: VAESENCLAST, CPU Feature: AVXAES\n func (x Uint8x16) AESEncryptLastRound(y Uint32x4) Uint8x16\n \n // AESEncryptLastRound performs a series of operations in AES cipher algorithm defined in FIPS 197.\n@@ -89,7 +89,7 @@ func (x Uint8x64) AESEncryptLastRound(y Uint32x16) Uint8x64\n // y is the chunk of w array in use.\n // result = AddRoundKey(MixColumns(ShiftRows(SubBytes(x))), y)\n //\n-// Asm: VAESENC, CPU Feature: AVX, AES\n+// Asm: VAESENC, CPU Feature: AVXAES\n func (x Uint8x16) AESEncryptOneRound(y Uint32x4) Uint8x16\n \n // AESEncryptOneRound performs a series of operations in AES cipher algorithm defined in FIPS 197.\n@@ -114,7 +114,7 @@ func (x Uint8x64) AESEncryptOneRound(y Uint32x16) Uint8x64\n // x is the chunk of w array in use.\n // result = InvMixColumns(x)\n //\n-// Asm: VAESIMC, CPU Feature: AVX, AES\n+// Asm: VAESIMC, CPU Feature: AVXAES\n func (x Uint32x4) AESInvMixColumns() Uint32x4\n \n /* AESRoundKeyGenAssist */\n@@ -129,7 +129,7 @@ func (x Uint32x4) AESInvMixColumns() Uint32x4\n //\n // rconVal results in better performance when it's a constant, a non-constant value will be translated into a jump table.\n //\n-// Asm: VAESKEYGENASSIST, CPU Feature: AVX, AES\n+// Asm: VAESKEYGENASSIST, CPU Feature: AVXAES\n func (x Uint32x4) AESRoundKeyGenAssist(rconVal uint8) Uint32x4\n \n /* Abs */","output":"refactor(simd): add CPU feature dependency tracking and virtual features","metadata":{"id":"go-9ef1692c","repository":"go","commit_hash":"9ef1692c93bf96328bcaf7a5c8a46094748da7f3"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/compile/internal/ssa/rewrite.go |  2 +-\n src/cmd/compile/internal/ssagen/ssa.go  |  2 +-\n src/runtime/_mkmalloc/mkmalloc.go       |  2 +-\n src/runtime/malloc_generated.go         | 30 +++++++++++++++---------------\n src/runtime/malloc_tables_generated.go  | 30 +++++++++++++++---------------\n test/codegen/strings.go                 |  2 +-\n test/live.go                            |  4 ++--\n test/live_regabi.go                     |  4 ++--\n 8 files changed, 38 insertions(+), 38 deletions(-)\n\ndiff --git a/src/cmd/compile/internal/ssa/rewrite.go b/src/cmd/compile/internal/ssa/rewrite.go\nindex af2568ae..032915f7 100644\n--- a/src/cmd/compile/internal/ssa/rewrite.go\n+++ b/src/cmd/compile/internal/ssa/rewrite.go\n@@ -480,7 +480,7 @@ func isSpecializedMalloc(aux Aux) bool {\n \tname := fn.String()\n \treturn strings.HasPrefix(name, \"runtime.mallocgcSmallNoScanSC\") ||\n \t\tstrings.HasPrefix(name, \"runtime.mallocgcSmallScanNoHeaderSC\") ||\n-\t\tstrings.HasPrefix(name, \"runtime.mallocTiny\")\n+\t\tstrings.HasPrefix(name, \"runtime.mallocgcTinySize\")\n }\n \n // canLoadUnaligned reports if the architecture supports unaligned load operations.\ndiff --git a/src/cmd/compile/internal/ssagen/ssa.go b/src/cmd/compile/internal/ssagen/ssa.go\nindex dd5baa0e..17feb90d 100644\n--- a/src/cmd/compile/internal/ssagen/ssa.go\n+++ b/src/cmd/compile/internal/ssagen/ssa.go\n@@ -140,7 +140,7 @@ func InitConfig() {\n \t\tir.Syms.MallocGCSmallScanNoHeader[i] = typecheck.LookupRuntimeFunc(fmt.Sprintf(\"mallocgcSmallScanNoHeaderSC%d\", i))\n \t}\n \tfor i := 1; i < len(ir.Syms.MallocGCTiny); i++ {\n-\t\tir.Syms.MallocGCTiny[i] = typecheck.LookupRuntimeFunc(fmt.Sprintf(\"mallocTiny%d\", i))\n+\t\tir.Syms.MallocGCTiny[i] = typecheck.LookupRuntimeFunc(fmt.Sprintf(\"mallocgcTinySize%d\", i))\n \t}\n \tir.Syms.MallocGC = typecheck.LookupRuntimeFunc(\"mallocgc\")\n \tir.Syms.Memmove = typecheck.LookupRuntimeFunc(\"memmove\")\ndiff --git a/src/runtime/_mkmalloc/mkmalloc.go b/src/runtime/_mkmalloc/mkmalloc.go\nindex 434eaad7..450608a7 100644\n--- a/src/runtime/_mkmalloc/mkmalloc.go\n+++ b/src/runtime/_mkmalloc/mkmalloc.go\n@@ -130,7 +130,7 @@ func tinyFuncName(size uintptr) string {\n \tif size == 0 || size > smallScanNoHeaderMax {\n \t\treturn \"mallocPanic\"\n \t}\n-\treturn fmt.Sprintf(\"mallocTiny%d\", size)\n+\treturn fmt.Sprintf(\"mallocgcTinySize%d\", size)\n }\n \n func smallNoScanSCFuncName(sc, scMax uint8) string {\ndiff --git a/src/runtime/malloc_generated.go b/src/runtime/malloc_generated.go\nindex 2be6a5b6..8d711264 100644\n--- a/src/runtime/malloc_generated.go\n+++ b/src/runtime/malloc_generated.go\n@@ -4300,7 +4300,7 @@ func mallocgcSmallScanNoHeaderSC26(size uintptr, typ *_type, needzero bool) unsa\n \treturn x\n }\n \n-func mallocTiny1(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize1(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -4456,7 +4456,7 @@ func mallocTiny1(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny2(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize2(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -4612,7 +4612,7 @@ func mallocTiny2(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny3(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize3(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -4768,7 +4768,7 @@ func mallocTiny3(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny4(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize4(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -4924,7 +4924,7 @@ func mallocTiny4(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny5(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize5(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -5080,7 +5080,7 @@ func mallocTiny5(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny6(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize6(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -5236,7 +5236,7 @@ func mallocTiny6(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny7(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize7(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -5392,7 +5392,7 @@ func mallocTiny7(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny8(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize8(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -5548,7 +5548,7 @@ func mallocTiny8(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny9(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize9(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -5704,7 +5704,7 @@ func mallocTiny9(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny10(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize10(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -5860,7 +5860,7 @@ func mallocTiny10(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny11(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize11(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -6016,7 +6016,7 @@ func mallocTiny11(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny12(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize12(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -6172,7 +6172,7 @@ func mallocTiny12(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny13(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize13(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -6328,7 +6328,7 @@ func mallocTiny13(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny14(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize14(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\n@@ -6484,7 +6484,7 @@ func mallocTiny14(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn x\n }\n \n-func mallocTiny15(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n+func mallocgcTinySize15(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \n \tgp := getg()\n \tif goexperiment.RuntimeSecret && gp.secret > 0 {\ndiff --git a/src/runtime/malloc_tables_generated.go b/src/runtime/malloc_tables_generated.go\nindex 36650881..b1ddde2a 100644\n--- a/src/runtime/malloc_tables_generated.go\n+++ b/src/runtime/malloc_tables_generated.go\n@@ -523,21 +523,21 @@ var mallocScanTable = [513]func(size uintptr, typ *_type, needzero bool) unsafe.\n \n var mallocNoScanTable = [513]func(size uintptr, typ *_type, needzero bool) unsafe.Pointer{\n \tmallocPanic,\n-\tmallocTiny1,\n-\tmallocTiny2,\n-\tmallocTiny3,\n-\tmallocTiny4,\n-\tmallocTiny5,\n-\tmallocTiny6,\n-\tmallocTiny7,\n-\tmallocTiny8,\n-\tmallocTiny9,\n-\tmallocTiny10,\n-\tmallocTiny11,\n-\tmallocTiny12,\n-\tmallocTiny13,\n-\tmallocTiny14,\n-\tmallocTiny15,\n+\tmallocgcTinySize1,\n+\tmallocgcTinySize2,\n+\tmallocgcTinySize3,\n+\tmallocgcTinySize4,\n+\tmallocgcTinySize5,\n+\tmallocgcTinySize6,\n+\tmallocgcTinySize7,\n+\tmallocgcTinySize8,\n+\tmallocgcTinySize9,\n+\tmallocgcTinySize10,\n+\tmallocgcTinySize11,\n+\tmallocgcTinySize12,\n+\tmallocgcTinySize13,\n+\tmallocgcTinySize14,\n+\tmallocgcTinySize15,\n \tmallocgcSmallNoScanSC2,\n \tmallocgcSmallNoScanSC3,\n \tmallocgcSmallNoScanSC3,\ndiff --git a/test/codegen/strings.go b/test/codegen/strings.go\nindex 0c5ee2f8..1c140211 100644\n--- a/test/codegen/strings.go\n+++ b/test/codegen/strings.go\n@@ -23,7 +23,7 @@ func CountBytes(s []byte) int {\n \n func ToByteSlice() []byte { // Issue #24698\n \t// amd64:`LEAQ type:\\[3\\]uint8`\n-\t// amd64:`CALL runtime\\.(newobject|mallocTiny3)`\n+\t// amd64:`CALL runtime\\.(newobject|mallocgcTinySize3)`\n \t// amd64:-`.*runtime.stringtoslicebyte`\n \treturn []byte(\"foo\")\n }\ndiff --git a/test/live.go b/test/live.go\nindex f8ad8df1..6561b209 100644\n--- a/test/live.go\n+++ b/test/live.go\n@@ -665,14 +665,14 @@ func f39a() (x []int) {\n \n func f39b() (x [10]*int) {\n \tx = [10]*int{}\n-\tx[0] = new(int) // ERROR \"live at call to (newobject|mallocTiny[48]): x$\"\n+\tx[0] = new(int) // ERROR \"live at call to (newobject|mallocgcTinySize[48]): x$\"\n \tprintnl()       // ERROR \"live at call to printnl: x$\"\n \treturn x\n }\n \n func f39c() (x [10]*int) {\n \tx = [10]*int{}\n-\tx[0] = new(int) // ERROR \"live at call to (newobject|mallocTiny[48]): x$\"\n+\tx[0] = new(int) // ERROR \"live at call to (newobject|mallocgcTinySize[48]): x$\"\n \tprintnl()       // ERROR \"live at call to printnl: x$\"\n \treturn\n }\ndiff --git a/test/live_regabi.go b/test/live_regabi.go\nindex 9809353f..75b842d7 100644\n--- a/test/live_regabi.go\n+++ b/test/live_regabi.go\n@@ -663,14 +663,14 @@ func f39a() (x []int) {\n \n func f39b() (x [10]*int) {\n \tx = [10]*int{}\n-\tx[0] = new(int) // ERROR \"live at call to (newobject|mallocTiny[48]): x$\"\n+\tx[0] = new(int) // ERROR \"live at call to (newobject|mallocgcTinySize[48]): x$\"\n \tprintnl()       // ERROR \"live at call to printnl: x$\"\n \treturn x\n }\n \n func f39c() (x [10]*int) {\n \tx = [10]*int{}\n-\tx[0] = new(int) // ERROR \"live at call to (newobject|mallocTiny[48]): x$\"\n+\tx[0] = new(int) // ERROR \"live at call to (newobject|mallocgcTinySize[48]): x$\"\n \tprintnl()       // ERROR \"live at call to printnl: x$\"\n \treturn\n }","output":"refactor(runtime): rename mallocTiny to mallocgcTinySize","metadata":{"id":"go-e2fef50d","repository":"go","commit_hash":"e2fef50def98b87107ab963f657d43d7869b8463"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/compile/internal/ssagen/ssa.go               | 2 +-\n src/simd/archsimd/_gen/simdgen/gen_simdMachineOps.go | 2 +-\n src/simd/archsimd/_gen/simdgen/gen_simdssa.go        | 2 +-\n 3 files changed, 3 insertions(+), 3 deletions(-)\n\ndiff --git a/src/cmd/compile/internal/ssagen/ssa.go b/src/cmd/compile/internal/ssagen/ssa.go\nindex 33fcf979..dd5baa0e 100644\n--- a/src/cmd/compile/internal/ssagen/ssa.go\n+++ b/src/cmd/compile/internal/ssagen/ssa.go\n@@ -7795,7 +7795,7 @@ func AddrAuto(a *obj.Addr, v *ssa.Value) {\n // Call returns a new CALL instruction for the SSA value v.\n // It uses PrepareCall to prepare the call.\n func (s *State) Call(v *ssa.Value) *obj.Prog {\n-\tpPosIsStmt := s.pp.Pos.IsStmt() // The statement-ness fo the call comes from ssaGenState\n+\tpPosIsStmt := s.pp.Pos.IsStmt() // The statement-ness of the call comes from ssaGenState\n \ts.PrepareCall(v)\n \n \tp := s.Prog(obj.ACALL)\ndiff --git a/src/simd/archsimd/_gen/simdgen/gen_simdMachineOps.go b/src/simd/archsimd/_gen/simdgen/gen_simdMachineOps.go\nindex 3d99dd2a..94b122ac 100644\n--- a/src/simd/archsimd/_gen/simdgen/gen_simdMachineOps.go\n+++ b/src/simd/archsimd/_gen/simdgen/gen_simdMachineOps.go\n@@ -181,7 +181,7 @@ func writeSIMDMachineOps(ops []Operation) *bytes.Buffer {\n \t\t}\n \t\thasMerging = gOp.hasMaskedMerging(maskType, shapeOut)\n \t\tif hasMerging && !resultInArg0 {\n-\t\t\t// We have to copy the slice here becasue the sort will be visible from other\n+\t\t\t// We have to copy the slice here because the sort will be visible from other\n \t\t\t// aliases when no reslicing is happening.\n \t\t\tnewIn := make([]Operand, len(op.In), len(op.In)+1)\n \t\t\tcopy(newIn, op.In)\ndiff --git a/src/simd/archsimd/_gen/simdgen/gen_simdssa.go b/src/simd/archsimd/_gen/simdgen/gen_simdssa.go\nindex 876ffabe..96d09668 100644\n--- a/src/simd/archsimd/_gen/simdgen/gen_simdssa.go\n+++ b/src/simd/archsimd/_gen/simdgen/gen_simdssa.go\n@@ -133,7 +133,7 @@ func writeSIMDSSA(ops []Operation) *bytes.Buffer {\n \t\tif mem == NoMem && op.hasMaskedMerging(maskType, shapeOut) {\n \t\t\tregShapeMerging := regShape\n \t\t\tif shapeOut != OneVregOutAtIn {\n-\t\t\t\t// We have to copy the slice here becasue the sort will be visible from other\n+\t\t\t\t// We have to copy the slice here because the sort will be visible from other\n \t\t\t\t// aliases when no reslicing is happening.\n \t\t\t\tnewIn := make([]Operand, len(op.In), len(op.In)+1)\n \t\t\t\tcopy(newIn, op.In)","output":"docs: fix typos in code comments","metadata":{"id":"go-7f6418bb","repository":"go","commit_hash":"7f6418bb4e44b1b11d428d402dd6935a2a1ea335"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/os/exec/lookpath.go   | 30 ++++++++++++++++++++++++++++++\n src/os/exec/lp_plan9.go   | 11 +----------\n src/os/exec/lp_unix.go    | 10 +---------\n src/os/exec/lp_wasm.go    |  2 +-\n src/os/exec/lp_windows.go | 26 ++++++++------------------\n 5 files changed, 41 insertions(+), 38 deletions(-)\n\ndiff --git a/src/os/exec/lookpath.go b/src/os/exec/lookpath.go\nnew file mode 100644\nindex 00000000..71f86b99\n--- /dev/null\n+++ b/src/os/exec/lookpath.go\n@@ -0,0 +1,30 @@\n+// Copyright 2026 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package exec\n+\n+// LookPath searches for an executable named file in the current path,\n+// following the conventions of the host operating system.\n+// If file contains a slash, it is tried directly and the default path is not consulted.\n+// Otherwise, on success the result is an absolute path.\n+//\n+// LookPath returns an error satisfying [errors.Is](err, [ErrDot])\n+// if the resolved path is relative to the current directory.\n+// See the package documentation for more details.\n+//\n+// LookPath looks for an executable named file in the\n+// directories named by the PATH environment variable,\n+// except as described below.\n+//\n+//   - On Windows, the file must have an extension named by\n+//     the PATHEXT environment variable.\n+//     When PATHEXT is unset, the file must have\n+//     a \".com\", \".exe\", \".bat\", or \".cmd\" extension.\n+//   - On Plan 9, LookPath consults the path environment variable.\n+//     If file begins with \"/\", \"#\", \"./\", or \"../\", it is tried\n+//     directly and the path is not consulted.\n+//   - On Wasm, LookPath always returns an error.\n+func LookPath(file string) (string, error) {\n+\treturn lookPath(file)\n+}\ndiff --git a/src/os/exec/lp_plan9.go b/src/os/exec/lp_plan9.go\nindex f713a690..711aad11 100644\n--- a/src/os/exec/lp_plan9.go\n+++ b/src/os/exec/lp_plan9.go\n@@ -26,16 +26,7 @@ func findExecutable(file string) error {\n \treturn fs.ErrPermission\n }\n \n-// LookPath searches for an executable named file in the\n-// directories named by the path environment variable.\n-// If file begins with \"/\", \"#\", \"./\", or \"../\", it is tried\n-// directly and the path is not consulted.\n-// On success, the result is an absolute path.\n-//\n-// In older versions of Go, LookPath could return a path relative to the current directory.\n-// As of Go 1.19, LookPath will instead return that path along with an error satisfying\n-// [errors.Is](err, [ErrDot]). See the package documentation for more details.\n-func LookPath(file string) (string, error) {\n+func lookPath(file string) (string, error) {\n \tif err := validateLookPath(filepath.Clean(file)); err != nil {\n \t\treturn \"\", &Error{file, err}\n \t}\ndiff --git a/src/os/exec/lp_unix.go b/src/os/exec/lp_unix.go\nindex e5fddbaf..d3b10cc4 100644\n--- a/src/os/exec/lp_unix.go\n+++ b/src/os/exec/lp_unix.go\n@@ -41,15 +41,7 @@ func findExecutable(file string) error {\n \treturn fs.ErrPermission\n }\n \n-// LookPath searches for an executable named file in the\n-// directories named by the PATH environment variable.\n-// If file contains a slash, it is tried directly and the PATH is not consulted.\n-// Otherwise, on success, the result is an absolute path.\n-//\n-// In older versions of Go, LookPath could return a path relative to the current directory.\n-// As of Go 1.19, LookPath will instead return that path along with an error satisfying\n-// [errors.Is](err, [ErrDot]). See the package documentation for more details.\n-func LookPath(file string) (string, error) {\n+func lookPath(file string) (string, error) {\n \t// NOTE(rsc): I wish we could use the Plan 9 behavior here\n \t// (only bypass the path if file begins with / or ./ or ../)\n \t// but that would not match all the Unix shells.\ndiff --git a/src/os/exec/lp_wasm.go b/src/os/exec/lp_wasm.go\nindex 3c819049..1de9076e 100644\n--- a/src/os/exec/lp_wasm.go\n+++ b/src/os/exec/lp_wasm.go\n@@ -17,7 +17,7 @@ var ErrNotFound = errors.New(\"executable file not found in $PATH\")\n // directories named by the PATH environment variable.\n // If file contains a slash, it is tried directly and the PATH is not consulted.\n // The result may be an absolute path or a path relative to the current directory.\n-func LookPath(file string) (string, error) {\n+func lookPath(file string) (string, error) {\n \t// Wasm can not execute processes, so act as if there are no executables at all.\n \treturn \"\", &Error{file, ErrNotFound}\n }\ndiff --git a/src/os/exec/lp_windows.go b/src/os/exec/lp_windows.go\nindex 74537dec..f58aabc1 100644\n--- a/src/os/exec/lp_windows.go\n+++ b/src/os/exec/lp_windows.go\n@@ -56,22 +56,12 @@ func findExecutable(file string, exts []string) (string, error) {\n \treturn \"\", ErrNotFound\n }\n \n-// LookPath searches for an executable named file in the\n-// directories named by the PATH environment variable.\n-// LookPath also uses PATHEXT environment variable to match\n-// a suitable candidate.\n-// If file contains a slash, it is tried directly and the PATH is not consulted.\n-// Otherwise, on success, the result is an absolute path.\n-//\n-// In older versions of Go, LookPath could return a path relative to the current directory.\n-// As of Go 1.19, LookPath will instead return that path along with an error satisfying\n-// [errors.Is](err, [ErrDot]). See the package documentation for more details.\n-func LookPath(file string) (string, error) {\n+func lookPath(file string) (string, error) {\n \tif err := validateLookPath(file); err != nil {\n \t\treturn \"\", &Error{file, err}\n \t}\n \n-\treturn lookPath(file, pathExt())\n+\treturn lookPathExts(file, pathExt())\n }\n \n // lookExtensions finds windows executable by its dir and path.\n@@ -101,17 +91,17 @@ func lookExtensions(path, dir string) (string, error) {\n \t\t}\n \t}\n \tif dir == \"\" {\n-\t\treturn lookPath(path, exts)\n+\t\treturn lookPathExts(path, exts)\n \t}\n \tif filepath.VolumeName(path) != \"\" {\n-\t\treturn lookPath(path, exts)\n+\t\treturn lookPathExts(path, exts)\n \t}\n \tif len(path) > 1 && os.IsPathSeparator(path[0]) {\n-\t\treturn lookPath(path, exts)\n+\t\treturn lookPathExts(path, exts)\n \t}\n \tdirandpath := filepath.Join(dir, path)\n \t// We assume that LookPath will only add file extension.\n-\tlp, err := lookPath(dirandpath, exts)\n+\tlp, err := lookPathExts(dirandpath, exts)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n@@ -138,8 +128,8 @@ func pathExt() []string {\n \treturn exts\n }\n \n-// lookPath implements LookPath for the given PATHEXT list.\n-func lookPath(file string, exts []string) (string, error) {\n+// lookPathExts implements LookPath for the given PATHEXT list.\n+func lookPathExts(file string, exts []string) (string, error) {\n \tif strings.ContainsAny(file, `:\\/`) {\n \t\tf, err := findExecutable(file, exts)\n \t\tif err == nil {","output":"refactor(exec): consolidate LookPath docs into shared file","metadata":{"id":"go-c16402d1","repository":"go","commit_hash":"c16402d15b42cf494774796e606aba66c90d3d6b"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/os/exec/exec_test.go | 24 +++++++-----------------\n 1 file changed, 7 insertions(+), 17 deletions(-)\n\ndiff --git a/src/os/exec/exec_test.go b/src/os/exec/exec_test.go\nindex bf2f3da5..2746ad87 100644\n--- a/src/os/exec/exec_test.go\n+++ b/src/os/exec/exec_test.go\n@@ -1845,23 +1845,13 @@ func TestStart_twice(t *testing.T) {\n \ttestenv.MustHaveExec(t)\n \n \tcmd := exec.Command(\"/bin/nonesuch\")\n-\tfor i, want := range []string{\n-\t\tcond(runtime.GOOS == \"windows\",\n-\t\t\t`exec: \"/bin/nonesuch\": executable file not found in %PATH%`,\n-\t\t\t\"fork/exec /bin/nonesuch: no such file or directory\"),\n-\t\t\"exec: already started\",\n-\t} {\n-\t\terr := cmd.Start()\n-\t\tif got := fmt.Sprint(err); got != want {\n-\t\t\tt.Errorf(\"Start call #%d return err %q, want %q\", i+1, got, want)\n-\t\t}\n+\tif err := cmd.Start(); err == nil {\n+\t\tt.Fatalf(\"running invalid command succeeded\")\n \t}\n-}\n-\n-func cond[T any](cond bool, t, f T) T {\n-\tif cond {\n-\t\treturn t\n-\t} else {\n-\t\treturn f\n+\terr := cmd.Start()\n+\tgot := fmt.Sprint(err)\n+\twant := \"exec: already started\"\n+\tif got != want {\n+\t\tt.Fatalf(\"Start call returned err %q, want %q\", got, want)\n \t}\n }","output":"test(exec): simplify TestStart_twice","metadata":{"id":"go-b7e6d8b9","repository":"go","commit_hash":"b7e6d8b923ad06538c800d635d3ede90d3d0b782"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/net/fd_windows.go   | 2 +-\n src/net/file_windows.go | 2 +-\n 2 files changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/src/net/fd_windows.go b/src/net/fd_windows.go\nindex 52985be8..c28ce045 100644\n--- a/src/net/fd_windows.go\n+++ b/src/net/fd_windows.go\n@@ -248,7 +248,7 @@ func (fd *netFD) dup() (*os.File, error) {\n \terr := fd.pfd.RawControl(func(fd uintptr) {\n \t\th, syserr = dupSocket(syscall.Handle(fd))\n \t})\n-\tif err != nil {\n+\tif err == nil {\n \t\terr = syserr\n \t}\n \tif err != nil {\ndiff --git a/src/net/file_windows.go b/src/net/file_windows.go\nindex b4eb00e5..6a630503 100644\n--- a/src/net/file_windows.go\n+++ b/src/net/file_windows.go\n@@ -39,7 +39,7 @@ func dupFileSocket(f *os.File) (syscall.Handle, error) {\n \terr = sc.Control(func(fd uintptr) {\n \t\th, syserr = dupSocket(syscall.Handle(fd))\n \t})\n-\tif err != nil {\n+\tif err == nil {\n \t\terr = syserr\n \t}\n \tif err != nil {","output":"fix(net): correct error assignment logic in windows socket duplication","metadata":{"id":"go-cbe15380","repository":"go","commit_hash":"cbe153806e67a16e362a1cdbbf1741d4ce82e98a"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/net/file_posix.go | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\ndiff --git a/src/net/file_posix.go b/src/net/file_posix.go\nindex 132d03e9..b28ff584 100644\n--- a/src/net/file_posix.go\n+++ b/src/net/file_posix.go\n@@ -23,7 +23,11 @@ func newFileFD(f *os.File) (*netFD, error) {\n \t\tpoll.CloseFunc(s)\n \t\treturn nil, os.NewSyscallError(\"getsockopt\", err)\n \t}\n-\tlsa, _ := syscall.Getsockname(s)\n+\tlsa, err := syscall.Getsockname(s)\n+\tif err != nil {\n+\t\tpoll.CloseFunc(s)\n+\t\treturn nil, os.NewSyscallError(\"getsockname\", err)\n+\t}\n \trsa, _ := syscall.Getpeername(s)\n \tswitch lsa.(type) {\n \tcase *syscall.SockaddrInet4:","output":"fix(net): handle getsockname error in file descriptor creation","metadata":{"id":"go-30d0b402","repository":"go","commit_hash":"30d0b4026410da3486ba841bb7f13c1d9074e91d"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/net/unixsock_test.go | 20 ++++++++++++++------\n 1 file changed, 14 insertions(+), 6 deletions(-)\n\ndiff --git a/src/net/unixsock_test.go b/src/net/unixsock_test.go\nindex f6c5679f..3e4a14b2 100644\n--- a/src/net/unixsock_test.go\n+++ b/src/net/unixsock_test.go\n@@ -375,6 +375,17 @@ func TestUnixUnlink(t *testing.T) {\n \t\t}\n \t\treturn l.(*UnixListener)\n \t}\n+\tfileListener := func(t *testing.T, l *UnixListener) (*os.File, Listener) {\n+\t\tf, err := l.File()\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tln, err := FileListener(f)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\treturn f, ln\n+\t}\n \tcheckExists := func(t *testing.T, desc string) {\n \t\tif _, err := os.Stat(name); err != nil {\n \t\t\tt.Fatalf(\"unix socket does not exist %s: %v\", desc, err)\n@@ -397,8 +408,7 @@ func TestUnixUnlink(t *testing.T) {\n \t// FileListener should not.\n \tt.Run(\"FileListener\", func(t *testing.T) {\n \t\tl := listen(t)\n-\t\tf, _ := l.File()\n-\t\tl1, _ := FileListener(f)\n+\t\tf, l1 := fileListener(t, l)\n \t\tcheckExists(t, \"after FileListener\")\n \t\tf.Close()\n \t\tcheckExists(t, \"after File close\")\n@@ -444,8 +454,7 @@ func TestUnixUnlink(t *testing.T) {\n \n \tt.Run(\"FileListener/SetUnlinkOnClose(true)\", func(t *testing.T) {\n \t\tl := listen(t)\n-\t\tf, _ := l.File()\n-\t\tl1, _ := FileListener(f)\n+\t\tf, l1 := fileListener(t, l)\n \t\tcheckExists(t, \"after FileListener\")\n \t\tl1.(*UnixListener).SetUnlinkOnClose(true)\n \t\tf.Close()\n@@ -457,8 +466,7 @@ func TestUnixUnlink(t *testing.T) {\n \n \tt.Run(\"FileListener/SetUnlinkOnClose(false)\", func(t *testing.T) {\n \t\tl := listen(t)\n-\t\tf, _ := l.File()\n-\t\tl1, _ := FileListener(f)\n+\t\tf, l1 := fileListener(t, l)\n \t\tcheckExists(t, \"after FileListener\")\n \t\tl1.(*UnixListener).SetUnlinkOnClose(false)\n \t\tf.Close()","output":"test(net): add fileListener helper and error handling","metadata":{"id":"go-5741608d","repository":"go","commit_hash":"5741608de26f06488e771fd7b3b35ca2ca4c93a6"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/crypto/internal/fips140test/acvp_test.go  | 4 ++--\n src/crypto/internal/fips140test/check_test.go | 2 +-\n src/crypto/tls/bogo_shim_test.go              | 2 +-\n 3 files changed, 4 insertions(+), 4 deletions(-)\n\ndiff --git a/src/crypto/internal/fips140test/acvp_test.go b/src/crypto/internal/fips140test/acvp_test.go\nindex e94bab74..6a0b46af 100644\n--- a/src/crypto/internal/fips140test/acvp_test.go\n+++ b/src/crypto/internal/fips140test/acvp_test.go\n@@ -2146,7 +2146,7 @@ func TestACVP(t *testing.T) {\n \t}\n \tconfigPath := filepath.Join(cwd, testConfigFile)\n \tt.Logf(\"running check_expected.go\\ncwd: %q\\ndata_dir: %q\\nconfig: %q\\ntool: %q\\nmodule-wrapper: %q\\n\",\n-\t\tcwd, dataDir, configPath, toolPath, os.Args[0])\n+\t\tcwd, dataDir, configPath, toolPath, testenv.Executable(t))\n \n \t// Run the check_expected test driver using the acvptool we built, and this test binary as the\n \t// module wrapper. The file paths in the config file are specified relative to the dataDir root\n@@ -2157,7 +2157,7 @@ func TestACVP(t *testing.T) {\n \t\t\"-tool\",\n \t\ttoolPath,\n \t\t// Note: module prefix must match Wrapper value in testConfigFile.\n-\t\t\"-module-wrappers\", \"go:\" + os.Args[0],\n+\t\t\"-module-wrappers\", \"go:\" + testenv.Executable(t),\n \t\t\"-tests\", configPath,\n \t}\n \tcmd = testenv.Command(t, testenv.GoToolPath(t), args...)\ndiff --git a/src/crypto/internal/fips140test/check_test.go b/src/crypto/internal/fips140test/check_test.go\nindex 8aef1f9b..d70ffbb7 100644\n--- a/src/crypto/internal/fips140test/check_test.go\n+++ b/src/crypto/internal/fips140test/check_test.go\n@@ -46,7 +46,7 @@ func TestIntegrityCheckFailure(t *testing.T) {\n \tmoduleStatus(t)\n \tcryptotest.MustSupportFIPS140(t)\n \n-\tbin, err := os.ReadFile(os.Args[0])\n+\tbin, err := os.ReadFile(testenv.Executable(t))\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\ndiff --git a/src/crypto/tls/bogo_shim_test.go b/src/crypto/tls/bogo_shim_test.go\nindex 1b5fc49c..ccac47c2 100644\n--- a/src/crypto/tls/bogo_shim_test.go\n+++ b/src/crypto/tls/bogo_shim_test.go\n@@ -577,7 +577,7 @@ func TestBogoSuite(t *testing.T) {\n \t\t\"test\",\n \t\t\".\",\n \t\tfmt.Sprintf(\"-shim-config=%s\", filepath.Join(cwd, \"bogo_config.json\")),\n-\t\tfmt.Sprintf(\"-shim-path=%s\", os.Args[0]),\n+\t\tfmt.Sprintf(\"-shim-path=%s\", testenv.Executable(t)),\n \t\t\"-shim-extra-flags=-bogo-mode\",\n \t\t\"-allow-unimplemented\",\n \t\t\"-loose-errors\", // TODO(roland): this should be removed eventually","output":"refactor(crypto): use testenv.Executable instead of os.Args[0]","metadata":{"id":"go-df6c351a","repository":"go","commit_hash":"df6c351aa4bbc8805406bfef979e62f59fc76da9"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" doc/go_spec.html | 87 +++++++++++++++++++++++++++++++++-----------------------\n 1 file changed, 51 insertions(+), 36 deletions(-)\n\ndiff --git a/doc/go_spec.html b/doc/go_spec.html\nindex f47f5a6e..478aefd4 100644\n--- a/doc/go_spec.html\n+++ b/doc/go_spec.html\n@@ -1,6 +1,6 @@\n <!--{\n \t\"Title\": \"The Go Programming Language Specification\",\n-\t\"Subtitle\": \"Language version go1.26 (Dec 2, 2025)\",\n+\t\"Subtitle\": \"Language version go1.26 (Jan 12, 2026)\",\n \t\"Path\": \"/ref/spec\"\n }-->\n \n@@ -3143,7 +3143,8 @@ math.Sin // denotes the Sin function in package math\n <p>\n Composite literals construct new values for structs, arrays, slices, and maps\n each time they are evaluated.\n-They consist of the type of the literal followed by a brace-bound list of elements.\n+They consist of the type of the literal followed by a (possibly empty)\n+brace-bound list of elements.\n Each element may optionally be preceded by a corresponding key.\n </p>\n \n@@ -3168,35 +3169,53 @@ as a TypeName).\n If the LiteralType is a type parameter, all types in its type set\n must have the same underlying type which must be\n a valid composite literal type.\n+</p>\n+\n+<p>\n The types of the elements and keys must be <a href=\"#Assignability\">assignable</a>\n-to the respective field, element, and key types of type <code>T</code>;\n+to the respective field, element, and key types of the LiteralType;\n there is no additional conversion.\n The key is interpreted as a field name for struct literals,\n an index for array and slice literals, and a key for map literals.\n-For map literals, all elements must have a key. It is an error\n-to specify multiple elements with the same field name or\n-constant key value. For non-constant map keys, see the section on\n-<a href=\"#Order_of_evaluation\">evaluation order</a>.\n+It is an error to specify multiple elements with the same field name\n+or constant key value.\n+A literal may omit the element list; such a literal evaluates\n+to the zero value for its type.\n </p>\n \n <p>\n-For struct literals the following rules apply:\n+A parsing ambiguity arises when a composite literal using the\n+TypeName form of the LiteralType appears as an operand between the\n+<a href=\"#Keywords\">keyword</a> and the opening brace of the block\n+of an \"if\", \"for\", or \"switch\" statement, and the composite literal\n+is not enclosed in parentheses, square brackets, or curly braces.\n+In this rare case, the opening brace of the literal is erroneously parsed\n+as the one introducing the block of statements. To resolve the ambiguity,\n+the composite literal must appear within parentheses.\n+</p>\n+\n+<pre>\n+if x == (T{a,b,c}[i]) {  }\n+if (x == T{a,b,c}[i]) {  }\n+</pre>\n+\n+<h4>Struct literals</h4>\n+\n+<p>\n+For struct literals without keys, the element list must contain an element\n+for each struct field in the order in which the fields are declared.\n+</p>\n+\n+<p>\n+For struct literals with keys the following rules apply:\n </p>\n <ul>\n-\t<li>A key must be a field name declared in the struct type.\n-\t</li>\n-\t<li>An element list that does not contain any keys must\n-\t    list an element for each struct field in the\n-\t    order in which the fields are declared.\n+\t<li>Every element must have a key.\n \t</li>\n-\t<li>If any element has a key, every element must have a key.\n+\t<li>Each key must be a field name declared in the struct type.\n \t</li>\n-\t<li>An element list that contains keys does not need to\n-\t    have an element for each struct field. Omitted fields\n-\t    get the zero value for that field.\n-\t</li>\n-\t<li>A literal may omit the element list; such a literal evaluates\n-\t    to the zero value for its type.\n+\t<li>The element list does not need to have an element for each struct field.\n+\t    Omitted fields get the zero value for that field.\n \t</li>\n \t<li>It is an error to specify an element for a non-exported\n \t    field of a struct belonging to a different package.\n@@ -3220,6 +3239,8 @@ origin := Point3D{}                            // zero value for Point3D\n line := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x\n </pre>\n \n+<h4>Array and slice literals</h4>\n+\n <p>\n For array and slice literals the following rules apply:\n </p>\n@@ -3295,6 +3316,16 @@ tmp := [n]T{x1, x2,  xn}\n tmp[0 : n]\n </pre>\n \n+<h4>Map literals</h4>\n+\n+<p>\n+For map literals, each element must have a key.\n+For non-constant map keys, see the section on\n+<a href=\"#Order_of_evaluation\">evaluation order</a>.\n+</p>\n+\n+<h4>Elision of element types</h4>\n+\n <p>\n Within a composite literal of array, slice, or map type <code>T</code>,\n elements or map keys that are themselves composite literals may elide the respective\n@@ -3315,22 +3346,6 @@ type PPoint *Point\n [2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&amp;Point{1.5, -3.5}), PPoint(&amp;Point{})}\n </pre>\n \n-<p>\n-A parsing ambiguity arises when a composite literal using the\n-TypeName form of the LiteralType appears as an operand between the\n-<a href=\"#Keywords\">keyword</a> and the opening brace of the block\n-of an \"if\", \"for\", or \"switch\" statement, and the composite literal\n-is not enclosed in parentheses, square brackets, or curly braces.\n-In this rare case, the opening brace of the literal is erroneously parsed\n-as the one introducing the block of statements. To resolve the ambiguity,\n-the composite literal must appear within parentheses.\n-</p>\n-\n-<pre>\n-if x == (T{a,b,c}[i]) {  }\n-if (x == T{a,b,c}[i]) {  }\n-</pre>\n-\n <p>\n Examples of valid array, slice, and map literals:\n </p>","output":"docs: restructure composite literals section","metadata":{"id":"go-cc1d7afb","repository":"go","commit_hash":"cc1d7afb247677fd9a1f75d11587af00d65e231d"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/dist/imports.go | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/cmd/dist/imports.go b/src/cmd/dist/imports.go\nindex 0ec2b06c..c00369a6 100644\n--- a/src/cmd/dist/imports.go\n+++ b/src/cmd/dist/imports.go\n@@ -259,6 +259,6 @@ func resolveVendor(imp, srcDir string) string {\n \t} else if strings.HasPrefix(srcDir, filepath.Join(goroot, \"src\")) {\n \t\treturn path.Join(\"vendor\", imp)\n \t} else {\n-\t\tpanic(fmt.Sprintf(\"srcDir %q not in GOOROT/src\", srcDir))\n+\t\tpanic(fmt.Sprintf(\"srcDir %q not in GOROOT/src\", srcDir))\n \t}\n }","output":"fix: correct typo in panic message","metadata":{"id":"go-fed3b0a2","repository":"go","commit_hash":"fed3b0a298464457c58d1150bdb3942f22bd6220"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/path/filepath/match.go | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\ndiff --git a/src/path/filepath/match.go b/src/path/filepath/match.go\nindex 7ccf71ee..3c1c22bb 100644\n--- a/src/path/filepath/match.go\n+++ b/src/path/filepath/match.go\n@@ -28,13 +28,15 @@ var ErrBadPattern = errors.New(\"syntax error in pattern\")\n //\t\t'[' [ '^' ] { character-range } ']'\n //\t\t            character class (must be non-empty)\n //\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n-//\t\t'\\\\' c      matches character c\n+//\t\t'\\\\' c      matches character c (except on Windows)\n //\n //\tcharacter-range:\n //\t\tc           matches character c (c != '\\\\', '-', ']')\n-//\t\t'\\\\' c      matches character c\n+//\t\t'\\\\' c      matches character c (except on Windows)\n //\t\tlo '-' hi   matches character c for lo <= c <= hi\n //\n+// Path segments in the pattern must be separated by [Separator].\n+//\n // Match requires pattern to match all of name, not just a substring.\n // The only possible returned error is [ErrBadPattern], when pattern\n // is malformed.","output":"docs: clarify filepath match behavior for windows and separators","metadata":{"id":"go-55ab5bba","repository":"go","commit_hash":"55ab5bba17a5221a51df244c8a3aeb1898cbdf1a"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/crypto/rsa/rsa_test.go | 6 ++++++\n 1 file changed, 6 insertions(+)\n\ndiff --git a/src/crypto/rsa/rsa_test.go b/src/crypto/rsa/rsa_test.go\nindex 5ae4c1dd..124fba1e 100644\n--- a/src/crypto/rsa/rsa_test.go\n+++ b/src/crypto/rsa/rsa_test.go\n@@ -145,6 +145,12 @@ d8Y7\n }\n \n func testKeyBasics(t *testing.T, priv *PrivateKey) {\n+\tdefer func() {\n+\t\tif t.Failed() {\n+\t\t\tt.Logf(\"failed key: %#v\", priv)\n+\t\t}\n+\t}()\n+\n \tif err := priv.Validate(); err != nil {\n \t\tt.Errorf(\"Validate() failed: %s\", err)\n \t}","output":"test(rsa): add debug logging for failed key tests","metadata":{"id":"go-088ba944","repository":"go","commit_hash":"088ba94439775e025b90790f1c8db49ee2e7017f"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/go/internal/work/exec.go | 12 ++++++------\n 1 file changed, 6 insertions(+), 6 deletions(-)\n\ndiff --git a/src/cmd/go/internal/work/exec.go b/src/cmd/go/internal/work/exec.go\nindex f2d1b104..0afdce23 100644\n--- a/src/cmd/go/internal/work/exec.go\n+++ b/src/cmd/go/internal/work/exec.go\n@@ -627,7 +627,7 @@ func (b *Builder) checkCacheForBuild(a, buildAction *Action, covMetaFileName str\n \t// If we are going to do a full build anyway,\n \t// we're going to regenerate the files in the build action anyway.\n \tif need == needVet {\n-\t\tif err := b.loadCachedVet(buildAction); err == nil {\n+\t\tif err := b.loadCachedVet(buildAction, a.Deps); err == nil {\n \t\t\tneed &^= needVet\n \t\t}\n \t}\n@@ -841,7 +841,7 @@ func (b *Builder) build(ctx context.Context, a *Action) (err error) {\n \n \t// Prepare Go vet config if needed.\n \tif need&needVet != 0 {\n-\t\tbuildVetConfig(a, srcfiles)\n+\t\tbuildVetConfig(a, srcfiles, a.Deps)\n \t\tneed &^= needVet\n \t}\n \tif need&needCompiledGoFiles != 0 {\n@@ -1121,7 +1121,7 @@ func (b *Builder) cacheSrcFiles(a *Action, srcfiles []string) {\n \tcache.PutBytes(c, cache.Subkey(a.actionID, \"srcfiles\"), buf.Bytes())\n }\n \n-func (b *Builder) loadCachedVet(a *Action) error {\n+func (b *Builder) loadCachedVet(a *Action, vetDeps []*Action) error {\n \tc := cache.Default()\n \tlist, _, err := cache.GetBytes(c, cache.Subkey(a.actionID, \"srcfiles\"))\n \tif err != nil {\n@@ -1141,7 +1141,7 @@ func (b *Builder) loadCachedVet(a *Action) error {\n \t\t}\n \t\tsrcfiles = append(srcfiles, a.Objdir+name)\n \t}\n-\tbuildVetConfig(a, srcfiles)\n+\tbuildVetConfig(a, srcfiles, vetDeps)\n \treturn nil\n }\n \n@@ -1197,7 +1197,7 @@ type vetConfig struct {\n \tSucceedOnTypecheckFailure bool // awful hack; see #18395 and below\n }\n \n-func buildVetConfig(a *Action, srcfiles []string) {\n+func buildVetConfig(a *Action, srcfiles []string, vetDeps []*Action) {\n \t// Classify files based on .go extension.\n \t// srcfiles does not include raw cgo files.\n \tvar gofiles, nongofiles []string\n@@ -1253,7 +1253,7 @@ func buildVetConfig(a *Action, srcfiles []string) {\n \t\tvcfgMapped[p] = true\n \t}\n \n-\tfor _, a1 := range a.Deps {\n+\tfor _, a1 := range vetDeps {\n \t\tp1 := a1.Package\n \t\tif p1 == nil || p1.ImportPath == \"\" || p1 == a.Package {\n \t\t\tcontinue","output":"refactor(work): pass vet deps explicitly to buildVetConfig","metadata":{"id":"go-108b333d","repository":"go","commit_hash":"108b333d510c1f60877ac917375d7931791acfe6"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/runtime/trace/recorder.go | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/runtime/trace/recorder.go b/src/runtime/trace/recorder.go\nindex a18d7641..8617231a 100644\n--- a/src/runtime/trace/recorder.go\n+++ b/src/runtime/trace/recorder.go\n@@ -112,7 +112,7 @@ func runtime_traceClockNow() uint64\n // frequency is nanoseconds per timestamp unit.\n type frequency float64\n \n-// mul multiplies an unprocessed to produce a time in nanoseconds.\n+// mul multiplies an unprocessed timestamp to produce a time in nanoseconds.\n func (f frequency) mul(t timestamp) eventTime {\n \treturn eventTime(float64(t) * float64(f))\n }","output":"docs: fix typo in frequency.mul comment","metadata":{"id":"go-2bbb2ace","repository":"go","commit_hash":"2bbb2ace346a26e0b1f7e32f1cdc645db8170d1c"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/cgo/ast.go | 11 +++--------\n 1 file changed, 3 insertions(+), 8 deletions(-)\n\ndiff --git a/src/cmd/cgo/ast.go b/src/cmd/cgo/ast.go\nindex 2da6ca5a..df0552f5 100644\n--- a/src/cmd/cgo/ast.go\n+++ b/src/cmd/cgo/ast.go\n@@ -301,17 +301,12 @@ func (f *File) saveExport(x any, context astContext) {\n \t\t\terror_(c.Pos(), \"export comment has wrong name %q, want %q\", name, n.Name.Name)\n \t\t}\n \n-\t\tdoc := \"\"\n-\t\tfor _, c1 := range n.Doc.List {\n-\t\t\tif c1 != c {\n-\t\t\t\tdoc += c1.Text + \"\\n\"\n-\t\t\t}\n-\t\t}\n-\n \t\tf.ExpFunc = append(f.ExpFunc, &ExpFunc{\n \t\t\tFunc:    n,\n \t\t\tExpName: name,\n-\t\t\tDoc:     doc,\n+\t\t\t// Caution: Do not set the Doc field on purpose\n+\t\t\t// to ensure that there are no unintended artifacts\n+\t\t\t// in the binary. See https://go.dev/issue/76697.\n \t\t})\n \t\tbreak\n \t}","output":"fix(cgo): remove doc field to prevent binary artifacts","metadata":{"id":"go-6b2505c7","repository":"go","commit_hash":"6b2505c79cb3838c6e27cf47ac09980fe51c83c2"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" lib/fips140/fips140.sum                     |   2 +-\n lib/fips140/{v1.1.0-rc1.zip => v1.26.0.zip} | Bin 678896 -> 676132 bytes\n 2 files changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/lib/fips140/fips140.sum b/lib/fips140/fips140.sum\nindex c4d185da..050957af 100644\n--- a/lib/fips140/fips140.sum\n+++ b/lib/fips140/fips140.sum\n@@ -10,4 +10,4 @@\n #\tgo test cmd/go/internal/fips140 -update\n #\n v1.0.0-c2097c7c.zip daf3614e0406f67ae6323c902db3f953a1effb199142362a039e7526dfb9368b\n-v1.1.0-rc1.zip ea94f8c3885294c9efe1bd8f9b6e86daeb25b6aff2aeb20707cd9a5101f6f54e\n+v1.26.0.zip 9b28f847fdf1db4a36cb2b2f8ec09443c039383f085630a03ecfaddf6db7ea23\ndiff --git a/lib/fips140/v1.1.0-rc1.zip b/lib/fips140/v1.26.0.zip\nsimilarity index 83%\nrename from lib/fips140/v1.1.0-rc1.zip\nrename to lib/fips140/v1.26.0.zip\nindex d4264bdb..f53ade80 100644\nBinary files a/lib/fips140/v1.1.0-rc1.zip and b/lib/fips140/v1.26.0.zip differ","output":"build(deps): update fips140 to v1.26.0","metadata":{"id":"go-4b89bcb8","repository":"go","commit_hash":"4b89bcb8b7141c7e4ef1a7dbb4c3f17f589d89c0"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/internal/types/testdata/check/cycles6.go | 71 ++++++++++++++++++++++++++++\n 1 file changed, 71 insertions(+)\n\ndiff --git a/src/internal/types/testdata/check/cycles6.go b/src/internal/types/testdata/check/cycles6.go\nnew file mode 100644\nindex 00000000..e5635ed4\n--- /dev/null\n+++ b/src/internal/types/testdata/check/cycles6.go\n@@ -0,0 +1,71 @@\n+// Copyright 2026 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+import \"unsafe\"\n+\n+// Below are the pieces of syntax corresponding to functions which can produce a\n+// type T without first having a value of type T. Notice that each causes a\n+// value of type T to be passed to unsafe.Sizeof while T is incomplete.\n+\n+// literal on type\n+type T0 /* ERROR \"invalid recursive type\" */ [unsafe.Sizeof(T0{})]int\n+// literal on value                                                             (not applicable)\n+// literal on pointer                                                           (not applicable)\n+\n+// call on type\n+type T1 /* ERROR \"invalid recursive type\" */ [unsafe.Sizeof(T1(42))]int\n+// call on value\n+func f2() T2\n+type T2 /* ERROR \"invalid recursive type\" */ [unsafe.Sizeof(f2())]int\n+// call on pointer                                                              (not applicable)\n+\n+// assert on type\n+var i3 interface{}\n+type T3 /* ERROR \"invalid recursive type\" */ [unsafe.Sizeof(i3.(T3))]int\n+// assert on value                                                              (not applicable)\n+// assert on pointer                                                            (not applicable)\n+\n+// receive on type                                                              (not applicable)\n+// receive on value\n+func f4() <-chan T4\n+type T4 /* ERROR \"invalid recursive type\" */ [unsafe.Sizeof(<-f4())]int\n+// receive on pointer                                                           (not applicable)\n+\n+// star on type                                                                 (not applicable)\n+// star on value                                                                (not applicable)\n+// star on pointer\n+func f5() *T5\n+type T5 /* ERROR \"invalid recursive type\" */ [unsafe.Sizeof(*f5())]int\n+\n+// Below is additional syntax which interacts with incomplete types. Notice that\n+// each of the below falls into 1 of 3 cases:\n+//   1. It cannot produce a value of (incomplete) type T.\n+//   2. It can, but only because it already has a value of type T.\n+//   3. It can, but only because it performs an implicit dereference.\n+\n+// select on type                                                               (case 1)\n+// select on value                                                              (case 2)\n+type T6 /* ERROR \"invalid recursive type\" */ struct {\n+\tf T7\n+}\n+type T7 [unsafe.Sizeof(T6{}.f)]int\n+// select on pointer                                                            (case 3)\n+type T8 /* ERROR \"invalid recursive type\" */ struct {\n+\tf T9\n+}\n+type T9 [unsafe.Sizeof(new(T8).f)]int\n+\n+// slice on type                                                                (not applicable)\n+// slice on value                                                               (case 2)\n+type T10 /* ERROR \"invalid recursive type\" */ [unsafe.Sizeof(T10{}[:])]int\n+// slice on pointer                                                             (case 3)\n+type T11 /* ERROR \"invalid recursive type\" */ [unsafe.Sizeof(new(T11)[:])]int\n+\n+// index on type                                                                (case 1)\n+// index on value                                                               (case 2)\n+type T12 /* ERROR \"invalid recursive type\" */ [unsafe.Sizeof(T12{}[42])]int\n+// index on pointer                                                             (case 3)\n+type T13 /* ERROR \"invalid recursive type\" */ [unsafe.Sizeof(new(T13)[42])]int","output":"test: add cycle detection tests for recursive types","metadata":{"id":"go-5facb3b2","repository":"go","commit_hash":"5facb3b24b1c388176572eb95239f94d6ed4017d"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/go/internal/work/gc.go | 17 ++++++++++-------\n 1 file changed, 10 insertions(+), 7 deletions(-)\n\ndiff --git a/src/cmd/go/internal/work/gc.go b/src/cmd/go/internal/work/gc.go\nindex fc74715f..6300a913 100644\n--- a/src/cmd/go/internal/work/gc.go\n+++ b/src/cmd/go/internal/work/gc.go\n@@ -217,11 +217,11 @@ func compilerConcurrency() (int, func()) {\n \tconcurrentProcesses++\n \t// Set aside tokens so that we don't run out if we were running cfg.BuildP concurrent compiles.\n \t// We'll set aside one token for each of the action goroutines that aren't currently running a compile.\n-\tsetAside := cfg.BuildP - concurrentProcesses\n+\tsetAside := (cfg.BuildP - concurrentProcesses) * minTokens\n \tavailableTokens := tokens - setAside\n-\t// Grab half the remaining tokens: but with a floor of at least 1 token, and\n+\t// Grab half the remaining tokens: but with a floor of at least minTokens token, and\n \t// a ceiling of the max backend concurrency.\n-\tc := max(min(availableTokens/2, maxCompilerConcurrency), 1)\n+\tc := max(min(availableTokens/2, maxCompilerConcurrency), minTokens)\n \ttokens -= c\n \t// Successfully grabbed the tokens.\n \treturn c, func() {\n@@ -239,15 +239,18 @@ var (\n \ttotalTokens         int // total number of tokens: this is used for checking that we get them all back in the end\n \ttokens              int // number of available tokens\n \tconcurrentProcesses int // number of currently running compiles\n+\tminTokens           int // minimum number of tokens to give out\n )\n \n // initCompilerConcurrencyPool sets the number of tokens in the pool. It needs\n // to be run after init, so that it can use the value of cfg.BuildP.\n func initCompilerConcurrencyPool() {\n-\t// Size the pool so that the worst case total number of compiles is not more\n-\t// than what it was when we capped the concurrency to 4.\n-\toldConcurrencyCap := min(4, maxCompilerConcurrency)\n-\ttokens = oldConcurrencyCap * cfg.BuildP\n+\t// Size the pool to allow 2*maxCompilerConcurrency extra tokens to\n+\t// be distributed amongst the compile actions in addition to the minimum\n+\t// of min(4,GOMAXPROCS) tokens for each of the potentially cfg.BuildP\n+\t// concurrently running compile actions.\n+\tminTokens = min(4, maxCompilerConcurrency)\n+\ttokens = 2*maxCompilerConcurrency + minTokens*cfg.BuildP\n \ttotalTokens = tokens\n }\n ","output":"refactor(gc): improve compiler concurrency token distribution","metadata":{"id":"go-28147b52","repository":"go","commit_hash":"28147b528312055b535c6a69d0d4492bd502e1b0"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/go/internal/work/exec.go | 5 +++++\n src/cmd/go/internal/work/gc.go   | 3 +++\n 2 files changed, 8 insertions(+)\n\ndiff --git a/src/cmd/go/internal/work/exec.go b/src/cmd/go/internal/work/exec.go\nindex 654e9e93..f2d1b104 100644\n--- a/src/cmd/go/internal/work/exec.go\n+++ b/src/cmd/go/internal/work/exec.go\n@@ -248,6 +248,11 @@ func (b *Builder) Do(ctx context.Context, root *Action) {\n \n \twg.Wait()\n \n+\tif tokens != totalTokens || concurrentProcesses != 0 {\n+\t\tbase.Fatalf(\"internal error: tokens not restored at end of build: tokens: %d, totalTokens: %d, concurrentProcesses: %d\",\n+\t\t\ttokens, totalTokens, concurrentProcesses)\n+\t}\n+\n \t// Write action graph again, this time with timing information.\n \twriteActionGraph()\n }\ndiff --git a/src/cmd/go/internal/work/gc.go b/src/cmd/go/internal/work/gc.go\nindex 9a5e6c92..fc74715f 100644\n--- a/src/cmd/go/internal/work/gc.go\n+++ b/src/cmd/go/internal/work/gc.go\n@@ -227,6 +227,7 @@ func compilerConcurrency() (int, func()) {\n \treturn c, func() {\n \t\ttokensMu.Lock()\n \t\tdefer tokensMu.Unlock()\n+\t\tconcurrentProcesses--\n \t\ttokens += c\n \t}\n }\n@@ -235,6 +236,7 @@ var maxCompilerConcurrency = runtime.GOMAXPROCS(0) // max value we will use for\n \n var (\n \ttokensMu            sync.Mutex\n+\ttotalTokens         int // total number of tokens: this is used for checking that we get them all back in the end\n \ttokens              int // number of available tokens\n \tconcurrentProcesses int // number of currently running compiles\n )\n@@ -246,6 +248,7 @@ func initCompilerConcurrencyPool() {\n \t// than what it was when we capped the concurrency to 4.\n \toldConcurrencyCap := min(4, maxCompilerConcurrency)\n \ttokens = oldConcurrencyCap * cfg.BuildP\n+\ttotalTokens = tokens\n }\n \n // trimpath returns the -trimpath argument to use","output":"fix(build): add token restoration check and fix concurrent process","metadata":{"id":"go-874d8b98","repository":"go","commit_hash":"874d8b98eba8129559b97d2fdfa02ddeb88b95f9"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/runtime/trace/recorder.go | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/runtime/trace/recorder.go b/src/runtime/trace/recorder.go\nindex 4f2d3aa9..a18d7641 100644\n--- a/src/runtime/trace/recorder.go\n+++ b/src/runtime/trace/recorder.go\n@@ -39,7 +39,7 @@ func (w *recorder) Write(b []byte) (n int, err error) {\n \t\tw.headerReceived = true\n \t}\n \tif len(b) == n {\n-\t\treturn 0, nil\n+\t\treturn n, nil\n \t}\n \tba, nb, err := readBatch(b[n:]) // Every write from the runtime is guaranteed to be a complete batch.\n \tif err != nil {","output":"fix(trace): return correct byte count in recorder Write","metadata":{"id":"go-d1e7f49e","repository":"go","commit_hash":"d1e7f49e3d1eb039d9d2aed3ba923459bd42aa7c"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/go.mod                                      |  2 +-\n src/cmd/go.sum                                      |  4 ++--\n .../x/tools/go/analysis/passes/modernize/doc.go     |  2 ++\n .../x/tools/go/analysis/passes/modernize/maps.go    | 21 ++++++++++++++++++++-\n .../tools/go/analysis/passes/modernize/modernize.go |  2 +-\n src/cmd/vendor/modules.txt                          |  2 +-\n 6 files changed, 27 insertions(+), 6 deletions(-)\n\ndiff --git a/src/cmd/go.mod b/src/cmd/go.mod\nindex c7d3cc61..85e8c4cb 100644\n--- a/src/cmd/go.mod\n+++ b/src/cmd/go.mod\n@@ -11,7 +11,7 @@ require (\n \tgolang.org/x/sys v0.39.0\n \tgolang.org/x/telemetry v0.0.0-20251128220624-abf20d0e57ec\n \tgolang.org/x/term v0.38.0\n-\tgolang.org/x/tools v0.39.1-0.20251205000126-062ef7b6ced2\n+\tgolang.org/x/tools v0.39.1-0.20251230210517-d44be789a05c\n )\n \n require (\ndiff --git a/src/cmd/go.sum b/src/cmd/go.sum\nindex b02c469a..61c88e52 100644\n--- a/src/cmd/go.sum\n+++ b/src/cmd/go.sum\n@@ -22,7 +22,7 @@ golang.org/x/term v0.38.0 h1:PQ5pkm/rLO6HnxFR7N2lJHOZX6Kez5Y1gDSJla6jo7Q=\n golang.org/x/term v0.38.0/go.mod h1:bSEAKrOT1W+VSu9TSCMtoGEOUcKxOKgl3LE5QEF/xVg=\n golang.org/x/text v0.32.0 h1:ZD01bjUt1FQ9WJ0ClOL5vxgxOI/sVCNgX1YtKwcY0mU=\n golang.org/x/text v0.32.0/go.mod h1:o/rUWzghvpD5TXrTIBuJU77MTaN0ljMWE47kxGJQ7jY=\n-golang.org/x/tools v0.39.1-0.20251205000126-062ef7b6ced2 h1:2Qqv605Nus9iUp3ErvEU/q92Q3HAzeROztzl9pzAno8=\n-golang.org/x/tools v0.39.1-0.20251205000126-062ef7b6ced2/go.mod h1:JnefbkDPyD8UU2kI5fuf8ZX4/yUeh9W877ZeBONxUqQ=\n+golang.org/x/tools v0.39.1-0.20251230210517-d44be789a05c h1:0pZej6BQOooNbOfjJEu4v5qx9hdwFX8HnvHCcNXcs2w=\n+golang.org/x/tools v0.39.1-0.20251230210517-d44be789a05c/go.mod h1:JnefbkDPyD8UU2kI5fuf8ZX4/yUeh9W877ZeBONxUqQ=\n rsc.io/markdown v0.0.0-20240306144322-0bf8f97ee8ef h1:mqLYrXCXYEZOop9/Dbo6RPX11539nwiCNBb1icVPmw8=\n rsc.io/markdown v0.0.0-20240306144322-0bf8f97ee8ef/go.mod h1:8xcPgWmwlZONN1D9bjxtHEjrUtSEa3fakVF8iaewYKQ=\ndiff --git a/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/doc.go b/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/doc.go\nindex 45aed790..f1202c7a 100644\n--- a/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/doc.go\n+++ b/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/doc.go\n@@ -80,6 +80,8 @@ or b.ResetTimer within the same function will also be removed.\n Caveats: The b.Loop() method is designed to prevent the compiler from\n optimizing away the benchmark loop, which can occasionally result in\n slower execution due to increased allocations in some specific cases.\n+Since its fix may change the performance of nanosecond-scale benchmarks,\n+bloop is disabled by default in the `go fix` analyzer suite; see golang/go#74967.\n \n # Analyzer any\n \ndiff --git a/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/maps.go b/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/maps.go\nindex f97541d4..795f5b6c 100644\n--- a/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/maps.go\n+++ b/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/maps.go\n@@ -231,9 +231,28 @@ func mapsloop(pass *analysis.Pass) (any, error) {\n \t\t\t\t// Have: for k, v := range x { lhs = rhs }\n \n \t\t\t\tassign := rng.Body.List[0].(*ast.AssignStmt)\n+\n+\t\t\t\t// usesKV reports whether e references vars k or v.\n+\t\t\t\tusesKV := func(e ast.Expr) bool {\n+\t\t\t\t\tk := info.Defs[rng.Key.(*ast.Ident)]\n+\t\t\t\t\tv := info.Defs[rng.Value.(*ast.Ident)]\n+\t\t\t\t\tfor n := range ast.Preorder(e) {\n+\t\t\t\t\t\tif id, ok := n.(*ast.Ident); ok {\n+\t\t\t\t\t\t\tobj := info.Uses[id]\n+\t\t\t\t\t\t\tif obj != nil && // don't rely on k, v being non-nil\n+\t\t\t\t\t\t\t\t(obj == k || obj == v) {\n+\t\t\t\t\t\t\t\treturn true\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\n \t\t\t\tif index, ok := assign.Lhs[0].(*ast.IndexExpr); ok &&\n+\t\t\t\t\tlen(assign.Lhs) == 1 &&\n \t\t\t\t\tastutil.EqualSyntax(rng.Key, index.Index) &&\n-\t\t\t\t\tastutil.EqualSyntax(rng.Value, assign.Rhs[0]) {\n+\t\t\t\t\tastutil.EqualSyntax(rng.Value, assign.Rhs[0]) &&\n+\t\t\t\t\t!usesKV(index.X) { // reject (e.g.) f(k, v)[k] = v\n \t\t\t\t\tif tmap, ok := typeparams.CoreType(info.TypeOf(index.X)).(*types.Map); ok &&\n \t\t\t\t\t\ttypes.Identical(info.TypeOf(index), info.TypeOf(rng.Value)) && // m[k], v\n \t\t\t\t\t\ttypes.Identical(tmap.Key(), info.TypeOf(rng.Key)) {\ndiff --git a/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/modernize.go b/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/modernize.go\nindex 013ce79d..f09a2d26 100644\n--- a/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/modernize.go\n+++ b/src/cmd/vendor/golang.org/x/tools/go/analysis/passes/modernize/modernize.go\n@@ -34,7 +34,7 @@ var doc string\n var Suite = []*analysis.Analyzer{\n \tAnyAnalyzer,\n \t// AppendClippedAnalyzer, // not nil-preserving!\n-\tBLoopAnalyzer,\n+\t// BLoopAnalyzer, // may skew benchmark results, see golang/go#74967\n \tFmtAppendfAnalyzer,\n \tForVarAnalyzer,\n \tMapsLoopAnalyzer,\ndiff --git a/src/cmd/vendor/modules.txt b/src/cmd/vendor/modules.txt\nindex 7c122cd9..9c179c4b 100644\n--- a/src/cmd/vendor/modules.txt\n+++ b/src/cmd/vendor/modules.txt\n@@ -73,7 +73,7 @@ golang.org/x/text/internal/tag\n golang.org/x/text/language\n golang.org/x/text/transform\n golang.org/x/text/unicode/norm\n-# golang.org/x/tools v0.39.1-0.20251205000126-062ef7b6ced2\n+# golang.org/x/tools v0.39.1-0.20251230210517-d44be789a05c\n ## explicit; go 1.24.0\n golang.org/x/tools/cmd/bisect\n golang.org/x/tools/cover","output":"build(deps): update golang.org/x/tools","metadata":{"id":"go-f6ebd911","repository":"go","commit_hash":"f6ebd91129e13ef7f495550a4fc8fa74769f6a2d"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/os/exec/exec.go | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\ndiff --git a/src/os/exec/exec.go b/src/os/exec/exec.go\nindex e0c509cb..aa7a6be7 100644\n--- a/src/os/exec/exec.go\n+++ b/src/os/exec/exec.go\n@@ -357,7 +357,9 @@ type Cmd struct {\n \tcachedLookExtensions struct{ in, out string }\n \n \t// startCalled records that Start was attempted, regardless of outcome.\n-\tstartCalled atomic.Bool\n+\t// (Until go.dev/issue/77075 is resolved, we use atomic.SwapInt32,\n+\t// not atomic.Bool.Swap, to avoid triggering the copylocks vet check.)\n+\tstartCalled int32\n }\n \n // A ctxResult reports the result of watching the Context associated with a\n@@ -640,7 +642,7 @@ func (c *Cmd) Start() error {\n \t// Check for doubled Start calls before we defer failure cleanup. If the prior\n \t// call to Start succeeded, we don't want to spuriously close its pipes.\n \t// It is an error to call Start twice even if the first call did not create a process.\n-\tif c.startCalled.Swap(true) {\n+\tif atomic.SwapInt32(&c.startCalled, 1) != 0 {\n \t\treturn errors.New(\"exec: already started\")\n \t}\n ","output":"fix(exec): use atomic.SwapInt32 to avoid copylocks vet check","metadata":{"id":"go-d1d0fc7a","repository":"go","commit_hash":"d1d0fc7a97539206e33f04bac935f6450597137c"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/compile/internal/amd64/ssa.go             |   8 +-\n src/cmd/compile/internal/ssa/_gen/AMD64.rules     |  24 ++--\n src/cmd/compile/internal/ssa/_gen/AMD64Ops.go     |   9 ++\n src/cmd/compile/internal/ssa/opGen.go             |  84 ++++++++++++\n src/cmd/compile/internal/ssa/rewriteAMD64.go      | 150 ++++------------------\n src/simd/archsimd/_gen/simdgen/gen_simdTypes.go   |  29 ++++-\n src/simd/archsimd/internal/simd_test/simd_test.go |  77 ++++++++++-\n src/simd/archsimd/types_amd64.go                  |  12 +-\n 8 files changed, 242 insertions(+), 151 deletions(-)\n\ndiff --git a/src/cmd/compile/internal/amd64/ssa.go b/src/cmd/compile/internal/amd64/ssa.go\nindex 5ddcb84c..e9a566d7 100644\n--- a/src/cmd/compile/internal/amd64/ssa.go\n+++ b/src/cmd/compile/internal/amd64/ssa.go\n@@ -1845,7 +1845,13 @@ func ssaGenValue(s *ssagen.State, v *ssa.Value) {\n \t\tssa.OpAMD64VPMOVVec32x16ToM,\n \t\tssa.OpAMD64VPMOVVec64x2ToM,\n \t\tssa.OpAMD64VPMOVVec64x4ToM,\n-\t\tssa.OpAMD64VPMOVVec64x8ToM:\n+\t\tssa.OpAMD64VPMOVVec64x8ToM,\n+\t\tssa.OpAMD64VPMOVMSKB128,\n+\t\tssa.OpAMD64VPMOVMSKB256,\n+\t\tssa.OpAMD64VMOVMSKPS128,\n+\t\tssa.OpAMD64VMOVMSKPS256,\n+\t\tssa.OpAMD64VMOVMSKPD128,\n+\t\tssa.OpAMD64VMOVMSKPD256:\n \t\tp := s.Prog(v.Op.Asm())\n \t\tp.From.Type = obj.TYPE_REG\n \t\tp.From.Reg = simdReg(v.Args[0])\ndiff --git a/src/cmd/compile/internal/ssa/_gen/AMD64.rules b/src/cmd/compile/internal/ssa/_gen/AMD64.rules\nindex 9cd23c62..b49e85b5 100644\n--- a/src/cmd/compile/internal/ssa/_gen/AMD64.rules\n+++ b/src/cmd/compile/internal/ssa/_gen/AMD64.rules\n@@ -1679,21 +1679,21 @@\n (Cvt8toMask64x8 <t> x) => (VPMOVMToVec64x8 <types.TypeVec512> (KMOVBk <t> x))\n \n // masks to integers\n-(CvtMask8x16to16 <t> x) => (KMOVWi <t> (VPMOVVec8x16ToM <types.TypeMask> x))\n-(CvtMask8x32to32 <t> x) => (KMOVDi <t> (VPMOVVec8x32ToM <types.TypeMask> x))\n-(CvtMask8x64to64 <t> x) => (KMOVQi <t> (VPMOVVec8x64ToM <types.TypeMask> x))\n+(CvtMask8x16to16 ...) => (VPMOVMSKB128 ...)\n+(CvtMask8x32to32 ...) => (VPMOVMSKB256 ...)\n+(CvtMask8x64to64 x) => (KMOVQi (VPMOVVec8x64ToM <types.TypeMask> x))\n \n-(CvtMask16x8to8 <t> x) => (KMOVBi <t> (VPMOVVec16x8ToM <types.TypeMask> x))\n-(CvtMask16x16to16 <t> x) => (KMOVWi <t> (VPMOVVec16x16ToM <types.TypeMask> x))\n-(CvtMask16x32to32 <t> x) => (KMOVDi <t> (VPMOVVec16x32ToM <types.TypeMask> x))\n+(CvtMask16x8to8 x) => (KMOVBi (VPMOVVec16x8ToM <types.TypeMask> x))\n+(CvtMask16x16to16 x) => (KMOVWi (VPMOVVec16x16ToM <types.TypeMask> x))\n+(CvtMask16x32to32 x) => (KMOVDi (VPMOVVec16x32ToM <types.TypeMask> x))\n \n-(CvtMask32x4to8 <t> x) => (KMOVBi <t> (VPMOVVec32x4ToM <types.TypeMask> x))\n-(CvtMask32x8to8 <t> x) => (KMOVBi <t> (VPMOVVec32x8ToM <types.TypeMask> x))\n-(CvtMask32x16to16 <t> x) => (KMOVWi <t> (VPMOVVec32x16ToM <types.TypeMask> x))\n+(CvtMask32x4to8 ...) => (VMOVMSKPS128 ...)\n+(CvtMask32x8to8 ...) => (VMOVMSKPS256 ...)\n+(CvtMask32x16to16 x) => (KMOVWi (VPMOVVec32x16ToM <types.TypeMask> x))\n \n-(CvtMask64x2to8 <t> x) => (KMOVBi <t> (VPMOVVec64x2ToM <types.TypeMask> x))\n-(CvtMask64x4to8 <t> x) => (KMOVBi <t> (VPMOVVec64x4ToM <types.TypeMask> x))\n-(CvtMask64x8to8 <t> x) => (KMOVBi <t> (VPMOVVec64x8ToM <types.TypeMask> x))\n+(CvtMask64x2to8 ...) => (VMOVMSKPD128 ...)\n+(CvtMask64x4to8 ...) => (VMOVMSKPD256 ...)\n+(CvtMask64x8to8 x) => (KMOVBi (VPMOVVec64x8ToM <types.TypeMask> x))\n \n // optimizations\n (MOVBstore [off] {sym} ptr (KMOVBi mask) mem) => (KMOVBstore [off] {sym} ptr mask mem)\ndiff --git a/src/cmd/compile/internal/ssa/_gen/AMD64Ops.go b/src/cmd/compile/internal/ssa/_gen/AMD64Ops.go\nindex 2fb4fdfc..b13eb5aa 100644\n--- a/src/cmd/compile/internal/ssa/_gen/AMD64Ops.go\n+++ b/src/cmd/compile/internal/ssa/_gen/AMD64Ops.go\n@@ -1368,6 +1368,7 @@ func init() {\n \t\t{name: \"VPMASK64load512\", argLength: 3, reg: vloadk, asm: \"VMOVDQU64\", aux: \"SymOff\", faultOnNilArg0: true, symEffect: \"Read\"},    // load from arg0+auxint+aux, arg1=k mask, arg2 = mem\n \t\t{name: \"VPMASK64store512\", argLength: 4, reg: vstorek, asm: \"VMOVDQU64\", aux: \"SymOff\", faultOnNilArg0: true, symEffect: \"Write\"}, // store, *(arg0+auxint+aux) = arg2, arg1=k mask, arg3 = mem\n \n+\t\t// AVX512 moves between int-vector and mask registers\n \t\t{name: \"VPMOVMToVec8x16\", argLength: 1, reg: kv, asm: \"VPMOVM2B\"},\n \t\t{name: \"VPMOVMToVec8x32\", argLength: 1, reg: kv, asm: \"VPMOVM2B\"},\n \t\t{name: \"VPMOVMToVec8x64\", argLength: 1, reg: kw, asm: \"VPMOVM2B\"},\n@@ -1400,6 +1401,14 @@ func init() {\n \t\t{name: \"VPMOVVec64x4ToM\", argLength: 1, reg: vk, asm: \"VPMOVQ2M\"},\n \t\t{name: \"VPMOVVec64x8ToM\", argLength: 1, reg: wk, asm: \"VPMOVQ2M\"},\n \n+\t\t// AVX1/2 moves from int-vector to bitmask (extracting sign bits)\n+\t\t{name: \"VPMOVMSKB128\", argLength: 1, reg: vgp, asm: \"VPMOVMSKB\"},\n+\t\t{name: \"VPMOVMSKB256\", argLength: 1, reg: vgp, asm: \"VPMOVMSKB\"},\n+\t\t{name: \"VMOVMSKPS128\", argLength: 1, reg: vgp, asm: \"VMOVMSKPS\"},\n+\t\t{name: \"VMOVMSKPS256\", argLength: 1, reg: vgp, asm: \"VMOVMSKPS\"},\n+\t\t{name: \"VMOVMSKPD128\", argLength: 1, reg: vgp, asm: \"VMOVMSKPD\"},\n+\t\t{name: \"VMOVMSKPD256\", argLength: 1, reg: vgp, asm: \"VMOVMSKPD\"},\n+\n \t\t// X15 is the zero register up to 128-bit. For larger values, we zero it on the fly.\n \t\t{name: \"Zero128\", argLength: 0, reg: x15only, zeroWidth: true, fixedReg: true},\n \t\t{name: \"Zero256\", argLength: 0, reg: v01, asm: \"VPXOR\"},\ndiff --git a/src/cmd/compile/internal/ssa/opGen.go b/src/cmd/compile/internal/ssa/opGen.go\nindex abaf7911..7b70dc26 100644\n--- a/src/cmd/compile/internal/ssa/opGen.go\n+++ b/src/cmd/compile/internal/ssa/opGen.go\n@@ -1214,6 +1214,12 @@ const (\n \tOpAMD64VPMOVVec64x2ToM\n \tOpAMD64VPMOVVec64x4ToM\n \tOpAMD64VPMOVVec64x8ToM\n+\tOpAMD64VPMOVMSKB128\n+\tOpAMD64VPMOVMSKB256\n+\tOpAMD64VMOVMSKPS128\n+\tOpAMD64VMOVMSKPS256\n+\tOpAMD64VMOVMSKPD128\n+\tOpAMD64VMOVMSKPD256\n \tOpAMD64Zero128\n \tOpAMD64Zero256\n \tOpAMD64Zero512\n@@ -20351,6 +20357,84 @@ var opcodeTable = [...]opInfo{\n \t\t\t},\n \t\t},\n \t},\n+\t{\n+\t\tname:   \"VPMOVMSKB128\",\n+\t\targLen: 1,\n+\t\tasm:    x86.AVPMOVMSKB,\n+\t\treg: regInfo{\n+\t\t\tinputs: []inputInfo{\n+\t\t\t\t{0, 2147418112}, // X0 X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12 X13 X14\n+\t\t\t},\n+\t\t\toutputs: []outputInfo{\n+\t\t\t\t{0, 49135}, // AX CX DX BX BP SI DI R8 R9 R10 R11 R12 R13 R15\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tname:   \"VPMOVMSKB256\",\n+\t\targLen: 1,\n+\t\tasm:    x86.AVPMOVMSKB,\n+\t\treg: regInfo{\n+\t\t\tinputs: []inputInfo{\n+\t\t\t\t{0, 2147418112}, // X0 X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12 X13 X14\n+\t\t\t},\n+\t\t\toutputs: []outputInfo{\n+\t\t\t\t{0, 49135}, // AX CX DX BX BP SI DI R8 R9 R10 R11 R12 R13 R15\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tname:   \"VMOVMSKPS128\",\n+\t\targLen: 1,\n+\t\tasm:    x86.AVMOVMSKPS,\n+\t\treg: regInfo{\n+\t\t\tinputs: []inputInfo{\n+\t\t\t\t{0, 2147418112}, // X0 X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12 X13 X14\n+\t\t\t},\n+\t\t\toutputs: []outputInfo{\n+\t\t\t\t{0, 49135}, // AX CX DX BX BP SI DI R8 R9 R10 R11 R12 R13 R15\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tname:   \"VMOVMSKPS256\",\n+\t\targLen: 1,\n+\t\tasm:    x86.AVMOVMSKPS,\n+\t\treg: regInfo{\n+\t\t\tinputs: []inputInfo{\n+\t\t\t\t{0, 2147418112}, // X0 X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12 X13 X14\n+\t\t\t},\n+\t\t\toutputs: []outputInfo{\n+\t\t\t\t{0, 49135}, // AX CX DX BX BP SI DI R8 R9 R10 R11 R12 R13 R15\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tname:   \"VMOVMSKPD128\",\n+\t\targLen: 1,\n+\t\tasm:    x86.AVMOVMSKPD,\n+\t\treg: regInfo{\n+\t\t\tinputs: []inputInfo{\n+\t\t\t\t{0, 2147418112}, // X0 X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12 X13 X14\n+\t\t\t},\n+\t\t\toutputs: []outputInfo{\n+\t\t\t\t{0, 49135}, // AX CX DX BX BP SI DI R8 R9 R10 R11 R12 R13 R15\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tname:   \"VMOVMSKPD256\",\n+\t\targLen: 1,\n+\t\tasm:    x86.AVMOVMSKPD,\n+\t\treg: regInfo{\n+\t\t\tinputs: []inputInfo{\n+\t\t\t\t{0, 2147418112}, // X0 X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12 X13 X14\n+\t\t\t},\n+\t\t\toutputs: []outputInfo{\n+\t\t\t\t{0, 49135}, // AX CX DX BX BP SI DI R8 R9 R10 R11 R12 R13 R15\n+\t\t\t},\n+\t\t},\n+\t},\n \t{\n \t\tname:      \"Zero128\",\n \t\targLen:    0,\ndiff --git a/src/cmd/compile/internal/ssa/rewriteAMD64.go b/src/cmd/compile/internal/ssa/rewriteAMD64.go\nindex 3eb2a627..e84bf19c 100644\n--- a/src/cmd/compile/internal/ssa/rewriteAMD64.go\n+++ b/src/cmd/compile/internal/ssa/rewriteAMD64.go\n@@ -3050,19 +3050,25 @@ func rewriteValueAMD64(v *Value) bool {\n \tcase OpCvtMask32x16to16:\n \t\treturn rewriteValueAMD64_OpCvtMask32x16to16(v)\n \tcase OpCvtMask32x4to8:\n-\t\treturn rewriteValueAMD64_OpCvtMask32x4to8(v)\n+\t\tv.Op = OpAMD64VMOVMSKPS128\n+\t\treturn true\n \tcase OpCvtMask32x8to8:\n-\t\treturn rewriteValueAMD64_OpCvtMask32x8to8(v)\n+\t\tv.Op = OpAMD64VMOVMSKPS256\n+\t\treturn true\n \tcase OpCvtMask64x2to8:\n-\t\treturn rewriteValueAMD64_OpCvtMask64x2to8(v)\n+\t\tv.Op = OpAMD64VMOVMSKPD128\n+\t\treturn true\n \tcase OpCvtMask64x4to8:\n-\t\treturn rewriteValueAMD64_OpCvtMask64x4to8(v)\n+\t\tv.Op = OpAMD64VMOVMSKPD256\n+\t\treturn true\n \tcase OpCvtMask64x8to8:\n \t\treturn rewriteValueAMD64_OpCvtMask64x8to8(v)\n \tcase OpCvtMask8x16to16:\n-\t\treturn rewriteValueAMD64_OpCvtMask8x16to16(v)\n+\t\tv.Op = OpAMD64VPMOVMSKB128\n+\t\treturn true\n \tcase OpCvtMask8x32to32:\n-\t\treturn rewriteValueAMD64_OpCvtMask8x32to32(v)\n+\t\tv.Op = OpAMD64VPMOVMSKB256\n+\t\treturn true\n \tcase OpCvtMask8x64to64:\n \t\treturn rewriteValueAMD64_OpCvtMask8x64to64(v)\n \tcase OpDiv128u:\n@@ -68722,13 +68728,11 @@ func rewriteValueAMD64_OpCvt8toMask64x8(v *Value) bool {\n func rewriteValueAMD64_OpCvtMask16x16to16(v *Value) bool {\n \tv_0 := v.Args[0]\n \tb := v.Block\n-\t// match: (CvtMask16x16to16 <t> x)\n-\t// result: (KMOVWi <t> (VPMOVVec16x16ToM <types.TypeMask> x))\n+\t// match: (CvtMask16x16to16 x)\n+\t// result: (KMOVWi (VPMOVVec16x16ToM <types.TypeMask> x))\n \tfor {\n-\t\tt := v.Type\n \t\tx := v_0\n \t\tv.reset(OpAMD64KMOVWi)\n-\t\tv.Type = t\n \t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec16x16ToM, types.TypeMask)\n \t\tv0.AddArg(x)\n \t\tv.AddArg(v0)\n@@ -68738,13 +68742,11 @@ func rewriteValueAMD64_OpCvtMask16x16to16(v *Value) bool {\n func rewriteValueAMD64_OpCvtMask16x32to32(v *Value) bool {\n \tv_0 := v.Args[0]\n \tb := v.Block\n-\t// match: (CvtMask16x32to32 <t> x)\n-\t// result: (KMOVDi <t> (VPMOVVec16x32ToM <types.TypeMask> x))\n+\t// match: (CvtMask16x32to32 x)\n+\t// result: (KMOVDi (VPMOVVec16x32ToM <types.TypeMask> x))\n \tfor {\n-\t\tt := v.Type\n \t\tx := v_0\n \t\tv.reset(OpAMD64KMOVDi)\n-\t\tv.Type = t\n \t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec16x32ToM, types.TypeMask)\n \t\tv0.AddArg(x)\n \t\tv.AddArg(v0)\n@@ -68754,13 +68756,11 @@ func rewriteValueAMD64_OpCvtMask16x32to32(v *Value) bool {\n func rewriteValueAMD64_OpCvtMask16x8to8(v *Value) bool {\n \tv_0 := v.Args[0]\n \tb := v.Block\n-\t// match: (CvtMask16x8to8 <t> x)\n-\t// result: (KMOVBi <t> (VPMOVVec16x8ToM <types.TypeMask> x))\n+\t// match: (CvtMask16x8to8 x)\n+\t// result: (KMOVBi (VPMOVVec16x8ToM <types.TypeMask> x))\n \tfor {\n-\t\tt := v.Type\n \t\tx := v_0\n \t\tv.reset(OpAMD64KMOVBi)\n-\t\tv.Type = t\n \t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec16x8ToM, types.TypeMask)\n \t\tv0.AddArg(x)\n \t\tv.AddArg(v0)\n@@ -68770,141 +68770,39 @@ func rewriteValueAMD64_OpCvtMask16x8to8(v *Value) bool {\n func rewriteValueAMD64_OpCvtMask32x16to16(v *Value) bool {\n \tv_0 := v.Args[0]\n \tb := v.Block\n-\t// match: (CvtMask32x16to16 <t> x)\n-\t// result: (KMOVWi <t> (VPMOVVec32x16ToM <types.TypeMask> x))\n+\t// match: (CvtMask32x16to16 x)\n+\t// result: (KMOVWi (VPMOVVec32x16ToM <types.TypeMask> x))\n \tfor {\n-\t\tt := v.Type\n \t\tx := v_0\n \t\tv.reset(OpAMD64KMOVWi)\n-\t\tv.Type = t\n \t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec32x16ToM, types.TypeMask)\n \t\tv0.AddArg(x)\n \t\tv.AddArg(v0)\n \t\treturn true\n \t}\n }\n-func rewriteValueAMD64_OpCvtMask32x4to8(v *Value) bool {\n-\tv_0 := v.Args[0]\n-\tb := v.Block\n-\t// match: (CvtMask32x4to8 <t> x)\n-\t// result: (KMOVBi <t> (VPMOVVec32x4ToM <types.TypeMask> x))\n-\tfor {\n-\t\tt := v.Type\n-\t\tx := v_0\n-\t\tv.reset(OpAMD64KMOVBi)\n-\t\tv.Type = t\n-\t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec32x4ToM, types.TypeMask)\n-\t\tv0.AddArg(x)\n-\t\tv.AddArg(v0)\n-\t\treturn true\n-\t}\n-}\n-func rewriteValueAMD64_OpCvtMask32x8to8(v *Value) bool {\n-\tv_0 := v.Args[0]\n-\tb := v.Block\n-\t// match: (CvtMask32x8to8 <t> x)\n-\t// result: (KMOVBi <t> (VPMOVVec32x8ToM <types.TypeMask> x))\n-\tfor {\n-\t\tt := v.Type\n-\t\tx := v_0\n-\t\tv.reset(OpAMD64KMOVBi)\n-\t\tv.Type = t\n-\t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec32x8ToM, types.TypeMask)\n-\t\tv0.AddArg(x)\n-\t\tv.AddArg(v0)\n-\t\treturn true\n-\t}\n-}\n-func rewriteValueAMD64_OpCvtMask64x2to8(v *Value) bool {\n-\tv_0 := v.Args[0]\n-\tb := v.Block\n-\t// match: (CvtMask64x2to8 <t> x)\n-\t// result: (KMOVBi <t> (VPMOVVec64x2ToM <types.TypeMask> x))\n-\tfor {\n-\t\tt := v.Type\n-\t\tx := v_0\n-\t\tv.reset(OpAMD64KMOVBi)\n-\t\tv.Type = t\n-\t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec64x2ToM, types.TypeMask)\n-\t\tv0.AddArg(x)\n-\t\tv.AddArg(v0)\n-\t\treturn true\n-\t}\n-}\n-func rewriteValueAMD64_OpCvtMask64x4to8(v *Value) bool {\n-\tv_0 := v.Args[0]\n-\tb := v.Block\n-\t// match: (CvtMask64x4to8 <t> x)\n-\t// result: (KMOVBi <t> (VPMOVVec64x4ToM <types.TypeMask> x))\n-\tfor {\n-\t\tt := v.Type\n-\t\tx := v_0\n-\t\tv.reset(OpAMD64KMOVBi)\n-\t\tv.Type = t\n-\t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec64x4ToM, types.TypeMask)\n-\t\tv0.AddArg(x)\n-\t\tv.AddArg(v0)\n-\t\treturn true\n-\t}\n-}\n func rewriteValueAMD64_OpCvtMask64x8to8(v *Value) bool {\n \tv_0 := v.Args[0]\n \tb := v.Block\n-\t// match: (CvtMask64x8to8 <t> x)\n-\t// result: (KMOVBi <t> (VPMOVVec64x8ToM <types.TypeMask> x))\n+\t// match: (CvtMask64x8to8 x)\n+\t// result: (KMOVBi (VPMOVVec64x8ToM <types.TypeMask> x))\n \tfor {\n-\t\tt := v.Type\n \t\tx := v_0\n \t\tv.reset(OpAMD64KMOVBi)\n-\t\tv.Type = t\n \t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec64x8ToM, types.TypeMask)\n \t\tv0.AddArg(x)\n \t\tv.AddArg(v0)\n \t\treturn true\n \t}\n }\n-func rewriteValueAMD64_OpCvtMask8x16to16(v *Value) bool {\n-\tv_0 := v.Args[0]\n-\tb := v.Block\n-\t// match: (CvtMask8x16to16 <t> x)\n-\t// result: (KMOVWi <t> (VPMOVVec8x16ToM <types.TypeMask> x))\n-\tfor {\n-\t\tt := v.Type\n-\t\tx := v_0\n-\t\tv.reset(OpAMD64KMOVWi)\n-\t\tv.Type = t\n-\t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec8x16ToM, types.TypeMask)\n-\t\tv0.AddArg(x)\n-\t\tv.AddArg(v0)\n-\t\treturn true\n-\t}\n-}\n-func rewriteValueAMD64_OpCvtMask8x32to32(v *Value) bool {\n-\tv_0 := v.Args[0]\n-\tb := v.Block\n-\t// match: (CvtMask8x32to32 <t> x)\n-\t// result: (KMOVDi <t> (VPMOVVec8x32ToM <types.TypeMask> x))\n-\tfor {\n-\t\tt := v.Type\n-\t\tx := v_0\n-\t\tv.reset(OpAMD64KMOVDi)\n-\t\tv.Type = t\n-\t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec8x32ToM, types.TypeMask)\n-\t\tv0.AddArg(x)\n-\t\tv.AddArg(v0)\n-\t\treturn true\n-\t}\n-}\n func rewriteValueAMD64_OpCvtMask8x64to64(v *Value) bool {\n \tv_0 := v.Args[0]\n \tb := v.Block\n-\t// match: (CvtMask8x64to64 <t> x)\n-\t// result: (KMOVQi <t> (VPMOVVec8x64ToM <types.TypeMask> x))\n+\t// match: (CvtMask8x64to64 x)\n+\t// result: (KMOVQi (VPMOVVec8x64ToM <types.TypeMask> x))\n \tfor {\n-\t\tt := v.Type\n \t\tx := v_0\n \t\tv.reset(OpAMD64KMOVQi)\n-\t\tv.Type = t\n \t\tv0 := b.NewValue0(v.Pos, OpAMD64VPMOVVec8x64ToM, types.TypeMask)\n \t\tv0.AddArg(x)\n \t\tv.AddArg(v0)\ndiff --git a/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go b/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go\nindex d8c44812..dd3a75eb 100644\n--- a/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go\n+++ b/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go\n@@ -93,6 +93,33 @@ func (x simdType) MaskedStoreDoc() string {\n \t}\n }\n \n+func (x simdType) ToBitsDoc() string {\n+\tif x.Size == 512 || x.ElemBits() == 16 {\n+\t\treturn fmt.Sprintf(\"// Asm: KMOV%s, CPU Features: AVX512\", x.IntelSizeSuffix())\n+\t}\n+\t// 128/256 bit vectors with 8, 32, 64 bit elements\n+\tvar asm string\n+\tvar feat string\n+\tswitch x.ElemBits() {\n+\tcase 8:\n+\t\tasm = \"VPMOVMSKB\"\n+\t\tif x.Size == 256 {\n+\t\t\tfeat = \"AVX2\"\n+\t\t} else {\n+\t\t\tfeat = \"AVX\"\n+\t\t}\n+\tcase 32:\n+\t\tasm = \"VMOVMSKPS\"\n+\t\tfeat = \"AVX\"\n+\tcase 64:\n+\t\tasm = \"VMOVMSKPD\"\n+\t\tfeat = \"AVX\"\n+\tdefault:\n+\t\tpanic(\"unexpected ElemBits\")\n+\t}\n+\treturn fmt.Sprintf(\"// Asm: %s, CPU Features: %s\", asm, feat)\n+}\n+\n func compareSimdTypes(x, y simdType) int {\n \t// \"vreg\" then \"mask\"\n \tif c := -compareNatural(x.Type, y.Type); c != 0 {\n@@ -210,7 +237,7 @@ func {{.Name}}FromBits(y uint{{.LanesContainer}}) {{.Name}}\n // Only the lower {{.Lanes}} bits of y are used.\n {{- end}}\n //\n-// Asm: KMOV{{.IntelSizeSuffix}}, CPU Features: AVX512\n+{{.ToBitsDoc}}\n func (x {{.Name}}) ToBits() uint{{.LanesContainer}}\n `\n \ndiff --git a/src/simd/archsimd/internal/simd_test/simd_test.go b/src/simd/archsimd/internal/simd_test/simd_test.go\nindex 671ec05e..36bde924 100644\n--- a/src/simd/archsimd/internal/simd_test/simd_test.go\n+++ b/src/simd/archsimd/internal/simd_test/simd_test.go\n@@ -379,12 +379,79 @@ func TestBitMaskFromBitsLoad(t *testing.T) {\n }\n \n func TestBitMaskToBits(t *testing.T) {\n-\tif !archsimd.X86.AVX512() {\n-\t\tt.Skip(\"Test requires X86.AVX512, not available on this hardware\")\n-\t\treturn\n+\tint8s := []int8{\n+\t\t0, 1, 1, 0, 0, 1, 0, 1,\n+\t\t1, 0, 1, 1, 0, 0, 1, 0,\n+\t\t1, 0, 0, 1, 1, 0, 1, 0,\n+\t\t0, 1, 1, 0, 0, 1, 0, 1,\n+\t\t1, 0, 0, 1, 0, 1, 1, 0,\n+\t\t0, 1, 0, 1, 1, 0, 0, 1,\n+\t\t1, 0, 1, 0, 0, 1, 1, 0,\n+\t\t0, 1, 1, 0, 1, 0, 0, 1,\n+\t}\n+\tint16s := make([]int16, 32)\n+\tfor i := range int16s {\n+\t\tint16s[i] = int16(int8s[i])\n+\t}\n+\tint32s := make([]int32, 16)\n+\tfor i := range int32s {\n+\t\tint32s[i] = int32(int8s[i])\n+\t}\n+\tint64s := make([]int64, 8)\n+\tfor i := range int64s {\n+\t\tint64s[i] = int64(int8s[i])\n+\t}\n+\twant64 := uint64(0)\n+\tfor i := range int8s {\n+\t\twant64 |= uint64(int8s[i]) << i\n+\t}\n+\twant32 := uint32(want64)\n+\twant16 := uint16(want64)\n+\twant8 := uint8(want64)\n+\twant4 := want8 & 0b1111\n+\twant2 := want4 & 0b11\n+\n+\tif v := archsimd.LoadInt8x16Slice(int8s[:16]).ToMask().ToBits(); v != want16 {\n+\t\tt.Errorf(\"want %b, got %b\", want16, v)\n+\t}\n+\tif v := archsimd.LoadInt32x4Slice(int32s[:4]).ToMask().ToBits(); v != want4 {\n+\t\tt.Errorf(\"want %b, got %b\", want4, v)\n+\t}\n+\tif v := archsimd.LoadInt32x8Slice(int32s[:8]).ToMask().ToBits(); v != want8 {\n+\t\tt.Errorf(\"want %b, got %b\", want8, v)\n+\t}\n+\tif v := archsimd.LoadInt64x2Slice(int64s[:2]).ToMask().ToBits(); v != want2 {\n+\t\tt.Errorf(\"want %b, got %b\", want2, v)\n+\t}\n+\tif v := archsimd.LoadInt64x4Slice(int64s[:4]).ToMask().ToBits(); v != want4 {\n+\t\tt.Errorf(\"want %b, got %b\", want4, v)\n \t}\n-\tif v := archsimd.LoadInt16x8Slice([]int16{1, 0, 1, 0, 0, 0, 0, 0}).ToMask().ToBits(); v != 0b101 {\n-\t\tt.Errorf(\"Want 0b101, got %b\", v)\n+\n+\tif archsimd.X86.AVX2() {\n+\t\tif v := archsimd.LoadInt8x32Slice(int8s[:32]).ToMask().ToBits(); v != want32 {\n+\t\t\tt.Errorf(\"want %b, got %b\", want32, v)\n+\t\t}\n+\t}\n+\n+\tif archsimd.X86.AVX512() {\n+\t\tif v := archsimd.LoadInt8x64Slice(int8s).ToMask().ToBits(); v != want64 {\n+\t\t\tt.Errorf(\"want %b, got %b\", want64, v)\n+\t\t}\n+\t\tif v := archsimd.LoadInt16x8Slice(int16s[:8]).ToMask().ToBits(); v != want8 {\n+\t\t\tt.Errorf(\"want %b, got %b\", want8, v)\n+\t\t}\n+\t\tif v := archsimd.LoadInt16x16Slice(int16s[:16]).ToMask().ToBits(); v != want16 {\n+\t\t\tt.Errorf(\"want %b, got %b\", want16, v)\n+\t\t}\n+\t\tif v := archsimd.LoadInt16x32Slice(int16s).ToMask().ToBits(); v != want32 {\n+\t\t\tt.Errorf(\"want %b, got %b\", want32, v)\n+\t\t}\n+\t\tif v := archsimd.LoadInt32x16Slice(int32s).ToMask().ToBits(); v != want16 {\n+\t\t\tt.Errorf(\"want %b, got %b\", want16, v)\n+\t\t}\n+\t\tif v := archsimd.LoadInt64x8Slice(int64s).ToMask().ToBits(); v != want8 {\n+\t\t\tt.Errorf(\"want %b, got %b\", want8, v)\n+\t\t}\n \t}\n }\n \ndiff --git a/src/simd/archsimd/types_amd64.go b/src/simd/archsimd/types_amd64.go\nindex f39549c7..3d0a49dc 100644\n--- a/src/simd/archsimd/types_amd64.go\n+++ b/src/simd/archsimd/types_amd64.go\n@@ -308,7 +308,7 @@ func Mask8x16FromBits(y uint16) Mask8x16\n \n // ToBits constructs a bitmap from a Mask8x16, where 1 means set for the indexed element, 0 means unset.\n //\n-// Asm: KMOVB, CPU Features: AVX512\n+// Asm: VPMOVMSKB, CPU Features: AVX\n func (x Mask8x16) ToBits() uint16\n \n // Mask16x8 is a mask for a SIMD vector of 8 16-bit elements.\n@@ -342,7 +342,7 @@ func Mask32x4FromBits(y uint8) Mask32x4\n // ToBits constructs a bitmap from a Mask32x4, where 1 means set for the indexed element, 0 means unset.\n // Only the lower 4 bits of y are used.\n //\n-// Asm: KMOVD, CPU Features: AVX512\n+// Asm: VMOVMSKPS, CPU Features: AVX\n func (x Mask32x4) ToBits() uint8\n \n // Mask64x2 is a mask for a SIMD vector of 2 64-bit elements.\n@@ -360,7 +360,7 @@ func Mask64x2FromBits(y uint8) Mask64x2\n // ToBits constructs a bitmap from a Mask64x2, where 1 means set for the indexed element, 0 means unset.\n // Only the lower 2 bits of y are used.\n //\n-// Asm: KMOVQ, CPU Features: AVX512\n+// Asm: VMOVMSKPD, CPU Features: AVX\n func (x Mask64x2) ToBits() uint8\n \n // v256 is a tag type that tells the compiler that this is really 256-bit SIMD\n@@ -667,7 +667,7 @@ func Mask8x32FromBits(y uint32) Mask8x32\n \n // ToBits constructs a bitmap from a Mask8x32, where 1 means set for the indexed element, 0 means unset.\n //\n-// Asm: KMOVB, CPU Features: AVX512\n+// Asm: VPMOVMSKB, CPU Features: AVX2\n func (x Mask8x32) ToBits() uint32\n \n // Mask16x16 is a mask for a SIMD vector of 16 16-bit elements.\n@@ -699,7 +699,7 @@ func Mask32x8FromBits(y uint8) Mask32x8\n \n // ToBits constructs a bitmap from a Mask32x8, where 1 means set for the indexed element, 0 means unset.\n //\n-// Asm: KMOVD, CPU Features: AVX512\n+// Asm: VMOVMSKPS, CPU Features: AVX\n func (x Mask32x8) ToBits() uint8\n \n // Mask64x4 is a mask for a SIMD vector of 4 64-bit elements.\n@@ -717,7 +717,7 @@ func Mask64x4FromBits(y uint8) Mask64x4\n // ToBits constructs a bitmap from a Mask64x4, where 1 means set for the indexed element, 0 means unset.\n // Only the lower 4 bits of y are used.\n //\n-// Asm: KMOVQ, CPU Features: AVX512\n+// Asm: VMOVMSKPD, CPU Features: AVX\n func (x Mask64x4) ToBits() uint8\n \n // v512 is a tag type that tells the compiler that this is really 512-bit SIMD","output":"feat(simd): add AVX1/2 movmsk instructions for mask-to-int conversion","metadata":{"id":"go-9b2e3b9a","repository":"go","commit_hash":"9b2e3b9a02bd8872bdbf5c6086674fa6b4bc8ef9"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/go/testdata/vcstest/git/legacytest.txt | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/cmd/go/testdata/vcstest/git/legacytest.txt b/src/cmd/go/testdata/vcstest/git/legacytest.txt\nindex 5846983c..6465242d 100644\n--- a/src/cmd/go/testdata/vcstest/git/legacytest.txt\n+++ b/src/cmd/go/testdata/vcstest/git/legacytest.txt\n@@ -6,7 +6,7 @@ env GIT_COMMITTER_NAME=$GIT_AUTHOR_NAME\n env GIT_COMMITTER_EMAIL=$GIT_AUTHOR_EMAIL\n \n git init\n-git branch -M master\n+git checkout -b master\n \n at 2018-07-17T12:41:39-04:00\n cp x_cf92c7b.go x.go","output":"test: use checkout -b instead of branch -M for git init","metadata":{"id":"go-f8ee0f84","repository":"go","commit_hash":"f8ee0f84753b22254d217bf28ce8ecca7db7025c"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" test/codegen/bits.go | 177 ++++++++++++++++++++++++++++++++++-----------------\n 1 file changed, 117 insertions(+), 60 deletions(-)\n\ndiff --git a/test/codegen/bits.go b/test/codegen/bits.go\nindex da0745d4..d9c567b0 100644\n--- a/test/codegen/bits.go\n+++ b/test/codegen/bits.go\n@@ -13,17 +13,20 @@ import \"math/bits\"\n //\n \n func bitsCheckConstLeftShiftU64(a uint64) (n int) {\n-\t// amd64:\"BTQ [$]63\"\n+\t// amd64:\"BTQ [$]63,\"\n+\t// arm64:\"TBNZ [$]63,\"\n \t// riscv64:\"MOV [$]\" \"AND\" \"BNEZ\"\n \tif a&(1<<63) != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTQ [$]60\"\n+\t// amd64:\"BTQ [$]60,\"\n+\t// arm64:\"TBNZ [$]60,\"\n \t// riscv64:\"MOV [$]\" \"AND\" \"BNEZ\"\n \tif a&(1<<60) != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]0\"\n+\t// amd64:\"BTL [$]0,\"\n+\t// arm64:\"TBZ [$]0,\"\n \t// riscv64:\"ANDI\" \"BEQZ\"\n \tif a&(1<<0) != 0 {\n \t\treturn 1\n@@ -32,37 +35,44 @@ func bitsCheckConstLeftShiftU64(a uint64) (n int) {\n }\n \n func bitsCheckConstRightShiftU64(a [8]uint64) (n int) {\n-\t// amd64:\"BTQ [$]63\"\n+\t// amd64:\"BTQ [$]63,\"\n+\t// arm64:\"LSR [$]63,\" \"TBNZ [$]0,\"\n \t// riscv64:\"SRLI\" \"ANDI\" \"BNEZ\"\n \tif (a[0]>>63)&1 != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTQ [$]63\"\n+\t// amd64:\"BTQ [$]63,\"\n+\t// arm64:\"LSR [$]63,\" \"CBNZ\"\n \t// riscv64:\"SRLI\" \"BNEZ\"\n \tif a[1]>>63 != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTQ [$]63\"\n+\t// amd64:\"BTQ [$]63,\"\n+\t// arm64:\"LSR [$]63,\" \"CBZ\"\n \t// riscv64:\"SRLI\" \"BEQZ\"\n \tif a[2]>>63 == 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTQ [$]60\"\n+\t// amd64:\"BTQ [$]60,\"\n+\t// arm64:\"LSR [$]60,\" \"TBZ [$]0,\"\n \t// riscv64:\"SRLI\", \"ANDI\" \"BEQZ\"\n \tif (a[3]>>60)&1 == 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]1\"\n+\t// amd64:\"BTL [$]1,\"\n+\t// arm64:\"LSR [$]1,\" \"TBZ [$]0,\"\n \t// riscv64:\"SRLI\" \"ANDI\" \"BEQZ\"\n \tif (a[4]>>1)&1 == 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]0\"\n+\t// amd64:\"BTL [$]0,\"\n+\t// arm64:\"TBZ [$]0,\" -\"LSR\"\n \t// riscv64:\"ANDI\" \"BEQZ\" -\"SRLI\"\n \tif (a[5]>>0)&1 == 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]7\"\n+\t// amd64:\"BTL [$]7,\"\n+\t// arm64:\"LSR [$]5,\" \"TBNZ [$]2,\"\n \t// riscv64:\"SRLI\" \"ANDI\" \"BNEZ\"\n \tif (a[6]>>5)&4 == 0 {\n \t\treturn 1\n@@ -72,12 +82,14 @@ func bitsCheckConstRightShiftU64(a [8]uint64) (n int) {\n \n func bitsCheckVarU64(a, b uint64) (n int) {\n \t// amd64:\"BTQ\"\n+\t// arm64:\"MOVD [$]1,\" \"LSL\" \"TST\"\n \t// riscv64:\"ANDI [$]63,\" \"SLL \" \"AND \"\n \tif a&(1<<(b&63)) != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTQ\" -\"BT. [$]0\"\n-\t// riscv64:\"ANDI [$]63,\" \"SRL \" \"ANDI [$]1,\"\n+\t// amd64:\"BTQ\" -\"BT. [$]0,\"\n+\t// arm64:\"LSR\" \"TBZ [$]0,\"\n+\t// riscv64:\"ANDI [$]63,\" \"SRL\" \"ANDI [$]1,\"\n \tif (b>>(a&63))&1 != 0 {\n \t\treturn 1\n \t}\n@@ -85,17 +97,20 @@ func bitsCheckVarU64(a, b uint64) (n int) {\n }\n \n func bitsCheckMaskU64(a uint64) (n int) {\n-\t// amd64:\"BTQ [$]63\"\n+\t// amd64:\"BTQ [$]63,\"\n+\t// arm64:\"TBNZ [$]63,\"\n \t// riscv64:\"MOV [$]\" \"AND\" \"BNEZ\"\n \tif a&0x8000000000000000 != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTQ [$]59\"\n+\t// amd64:\"BTQ [$]59,\"\n+\t// arm64:\"TBNZ [$]59,\"\n \t// riscv64:\"MOV [$]\" \"AND\" \"BNEZ\"\n \tif a&0x800000000000000 != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]0\"\n+\t// amd64:\"BTL [$]0,\"\n+\t// arm64:\"TBZ [$]0,\"\n \t// riscv64:\"ANDI\" \"BEQZ\"\n \tif a&0x1 != 0 {\n \t\treturn 1\n@@ -105,18 +120,22 @@ func bitsCheckMaskU64(a uint64) (n int) {\n \n func bitsSetU64(a, b uint64) (n uint64) {\n \t// amd64:\"BTSQ\"\n+\t// arm64:\"MOVD [$]1,\" \"LSL\" \"ORR\"\n \t// riscv64:\"ANDI\" \"SLL\" \"OR\"\n \tn += b | (1 << (a & 63))\n \n-\t// amd64:\"BTSQ [$]63\"\n+\t// amd64:\"BTSQ [$]63,\"\n+\t// arm64:\"ORR [$]-9223372036854775808,\"\n \t// riscv64:\"MOV [$]\" \"OR \"\n \tn += a | (1 << 63)\n \n-\t// amd64:\"BTSQ [$]60\"\n+\t// amd64:\"BTSQ [$]60,\"\n+\t// arm64:\"ORR [$]1152921504606846976,\"\n \t// riscv64:\"MOV [$]\" \"OR \"\n \tn += a | (1 << 60)\n \n-\t// amd64:\"ORQ [$]1\"\n+\t// amd64:\"ORQ [$]1,\"\n+\t// arm64:\"ORR [$]1,\"\n \t// riscv64:\"ORI\"\n \tn += a | (1 << 0)\n \n@@ -125,18 +144,22 @@ func bitsSetU64(a, b uint64) (n uint64) {\n \n func bitsClearU64(a, b uint64) (n uint64) {\n \t// amd64:\"BTRQ\"\n+\t// arm64:\"MOVD [$]1,\" \"LSL\" \"BIC\"\n \t// riscv64:\"ANDI\" \"SLL\" \"ANDN\"\n \tn += b &^ (1 << (a & 63))\n \n-\t// amd64:\"BTRQ [$]63\"\n+\t// amd64:\"BTRQ [$]63,\"\n+\t// arm64:\"AND [$]9223372036854775807,\"\n \t// riscv64:\"MOV [$]\" \"AND \"\n \tn += a &^ (1 << 63)\n \n-\t// amd64:\"BTRQ [$]60\"\n+\t// amd64:\"BTRQ [$]60,\"\n+\t// arm64:\"AND [$]-1152921504606846977,\"\n \t// riscv64:\"MOV [$]\" \"AND \"\n \tn += a &^ (1 << 60)\n \n \t// amd64:\"ANDQ [$]-2\"\n+\t// arm64:\"AND [$]-2\"\n \t// riscv64:\"ANDI [$]-2\"\n \tn += a &^ (1 << 0)\n \n@@ -144,12 +167,14 @@ func bitsClearU64(a, b uint64) (n uint64) {\n }\n \n func bitsClearLowest(x int64, y int32) (int64, int32) {\n-\t// amd64:\"ANDQ [$]-2\"\n-\t// riscv64:\"ANDI [$]-2\"\n+\t// amd64:\"ANDQ [$]-2,\"\n+\t// arm64:\"AND [$]-2,\"\n+\t// riscv64:\"ANDI [$]-2,\"\n \ta := (x >> 1) << 1\n \n-\t// amd64:\"ANDL [$]-2\"\n-\t// riscv64:\"ANDI [$]-2\"\n+\t// amd64:\"ANDL [$]-2,\"\n+\t// arm64:\"AND [$]-2,\"\n+\t// riscv64:\"ANDI [$]-2,\"\n \tb := (y >> 1) << 1\n \n \treturn a, b\n@@ -157,19 +182,23 @@ func bitsClearLowest(x int64, y int32) (int64, int32) {\n \n func bitsFlipU64(a, b uint64) (n uint64) {\n \t// amd64:\"BTCQ\"\n+\t// arm64:\"MOVD [$]1,\" \"LSL\" \"EOR\"\n \t// riscv64:\"ANDI\" \"SLL\" \"XOR \"\n \tn += b ^ (1 << (a & 63))\n \n-\t// amd64:\"BTCQ [$]63\"\n+\t// amd64:\"BTCQ [$]63,\"\n+\t// arm64:\"EOR [$]-9223372036854775808,\"\n \t// riscv64:\"MOV [$]\" \"XOR \"\n \tn += a ^ (1 << 63)\n \n-\t// amd64:\"BTCQ [$]60\"\n+\t// amd64:\"BTCQ [$]60,\"\n+\t// arm64:\"EOR [$]1152921504606846976,\"\n \t// riscv64:\"MOV [$]\" \"XOR \"\n \tn += a ^ (1 << 60)\n \n-\t// amd64:\"XORQ [$]1\"\n-\t// riscv64:\"XORI [$]1\"\n+\t// amd64:\"XORQ [$]1,\"\n+\t// arm64:\"EOR [$]1,\"\n+\t// riscv64:\"XORI [$]1,\"\n \tn += a ^ (1 << 0)\n \n \treturn n\n@@ -180,17 +209,20 @@ func bitsFlipU64(a, b uint64) (n uint64) {\n //\n \n func bitsCheckConstShiftLeftU32(a uint32) (n int) {\n-\t// amd64:\"BTL [$]31\"\n+\t// amd64:\"BTL [$]31,\"\n+\t// arm64:\"TBNZ [$]31,\"\n \t// riscv64:\"MOV [$]\" \"AND\" \"BNEZ\"\n \tif a&(1<<31) != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]28\"\n+\t// amd64:\"BTL [$]28,\"\n+\t// arm64:\"TBNZ [$]28,\"\n \t// riscv64:\"ANDI\" \"BNEZ\"\n \tif a&(1<<28) != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]0\"\n+\t// amd64:\"BTL [$]0,\"\n+\t// arm64:\"TBZ [$]0,\"\n \t// riscv64:\"ANDI\" \"BEQZ\"\n \tif a&(1<<0) != 0 {\n \t\treturn 1\n@@ -199,37 +231,44 @@ func bitsCheckConstShiftLeftU32(a uint32) (n int) {\n }\n \n func bitsCheckConstRightShiftU32(a [8]uint32) (n int) {\n-\t// amd64:\"BTL [$]31\"\n+\t// amd64:\"BTL [$]31,\"\n+\t// arm64:\"UBFX [$]31,\" \"CBNZW\"\n \t// riscv64:\"SRLI\" \"ANDI\" \"BNEZ\"\n \tif (a[0]>>31)&1 != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]31\"\n+\t// amd64:\"BTL [$]31,\"\n+\t// arm64:\"UBFX [$]31,\" \"CBNZW\"\n \t// riscv64:\"SRLI\" \"BNEZ\"\n \tif a[1]>>31 != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]31\"\n+\t// amd64:\"BTL [$]31,\"\n+\t// arm64:\"UBFX [$]31,\" \"CBZW\"\n \t// riscv64:\"SRLI\" \"BEQZ\"\n \tif a[2]>>31 == 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]28\"\n+\t// amd64:\"BTL [$]28,\"\n+\t// arm64:\"UBFX [$]28,\" \"TBZ\"\n \t// riscv64:\"SRLI\" \"ANDI\" \"BEQZ\"\n \tif (a[3]>>28)&1 == 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]1\"\n+\t// amd64:\"BTL [$]1,\"\n+\t// arm64:\"UBFX [$]1,\" \"TBZ\"\n \t// riscv64:\"SRLI\" \"ANDI\" \"BEQZ\"\n \tif (a[4]>>1)&1 == 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]0\"\n-\t// riscv64:\"ANDI\" \"BEQZ\" -\"SRLI\"\n+\t// amd64:\"BTL [$]0,\"\n+\t// arm64:\"TBZ\" -\"UBFX\" -\"SRL\"\n+\t// riscv64:\"ANDI\" \"BEQZ\" -\"SRLI \"\n \tif (a[5]>>0)&1 == 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]7\"\n+\t// amd64:\"BTL [$]7,\"\n+\t// arm64:\"UBFX [$]5,\" \"TBNZ\"\n \t// riscv64:\"SRLI\" \"ANDI\" \"BNEZ\"\n \tif (a[6]>>5)&4 == 0 {\n \t\treturn 1\n@@ -239,11 +278,13 @@ func bitsCheckConstRightShiftU32(a [8]uint32) (n int) {\n \n func bitsCheckVarU32(a, b uint32) (n int) {\n \t// amd64:\"BTL\"\n+\t// arm64:\"AND [$]31,\" \"MOVD [$]1,\" \"LSL\" \"TSTW\"\n \t// riscv64:\"ANDI [$]31,\" \"SLL \" \"AND \"\n \tif a&(1<<(b&31)) != 0 {\n \t\treturn 1\n \t}\n \t// amd64:\"BTL\" -\"BT. [$]0\"\n+\t// arm64:\"AND [$]31,\" \"LSR\" \"TBZ\"\n \t// riscv64:\"ANDI [$]31,\" \"SRLW \" \"ANDI [$]1,\"\n \tif (b>>(a&31))&1 != 0 {\n \t\treturn 1\n@@ -252,17 +293,20 @@ func bitsCheckVarU32(a, b uint32) (n int) {\n }\n \n func bitsCheckMaskU32(a uint32) (n int) {\n-\t// amd64:\"BTL [$]31\"\n+\t// amd64:\"BTL [$]31,\"\n+\t// arm64:\"TBNZ [$]31,\"\n \t// riscv64:\"MOV [$]\" \"AND\" \"BNEZ\"\n \tif a&0x80000000 != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]27\"\n+\t// amd64:\"BTL [$]27,\"\n+\t// arm64:\"TBNZ [$]27,\"\n \t// riscv64:\"ANDI\" \"BNEZ\"\n \tif a&0x8000000 != 0 {\n \t\treturn 1\n \t}\n-\t// amd64:\"BTL [$]0\"\n+\t// amd64:\"BTL [$]0,\"\n+\t// arm64:\"TBZ [$]0,\"\n \t// riscv64:\"ANDI\" \"BEQZ\"\n \tif a&0x1 != 0 {\n \t\treturn 1\n@@ -272,19 +316,23 @@ func bitsCheckMaskU32(a uint32) (n int) {\n \n func bitsSetU32(a, b uint32) (n uint32) {\n \t// amd64:\"BTSL\"\n+\t// arm64:\"AND [$]31,\" \"MOVD [$]1,\" \"LSL\" \"ORR\"\n \t// riscv64:\"ANDI\" \"SLL\" \"OR\"\n \tn += b | (1 << (a & 31))\n \n-\t// amd64:\"ORL [$]-2147483648\"\n-\t// riscv64:\"ORI [$]-2147483648\"\n+\t// amd64:\"ORL [$]-2147483648,\"\n+\t// arm64:\"ORR [$]-2147483648,\"\n+\t// riscv64:\"ORI [$]-2147483648,\"\n \tn += a | (1 << 31)\n \n-\t// amd64:\"ORL [$]268435456\"\n-\t// riscv64:\"ORI [$]268435456\"\n+\t// amd64:\"ORL [$]268435456,\"\n+\t// arm64:\"ORR [$]268435456,\"\n+\t// riscv64:\"ORI [$]268435456,\"\n \tn += a | (1 << 28)\n \n-\t// amd64:\"ORL [$]1\"\n-\t// riscv64:\"ORI [$]1\"\n+\t// amd64:\"ORL [$]1,\"\n+\t// arm64:\"ORR [$]1,\"\n+\t// riscv64:\"ORI [$]1,\"\n \tn += a | (1 << 0)\n \n \treturn n\n@@ -292,19 +340,23 @@ func bitsSetU32(a, b uint32) (n uint32) {\n \n func bitsClearU32(a, b uint32) (n uint32) {\n \t// amd64:\"BTRL\"\n+\t// arm64:\"AND [$]31,\" \"MOVD [$]1,\" \"LSL\" \"BIC\"\n \t// riscv64:\"ANDI\" \"SLL\" \"ANDN\"\n \tn += b &^ (1 << (a & 31))\n \n-\t// amd64:\"ANDL [$]2147483647\"\n-\t// riscv64:\"ANDI [$]2147483647\"\n+\t// amd64:\"ANDL [$]2147483647,\"\n+\t// arm64:\"AND [$]2147483647,\"\n+\t// riscv64:\"ANDI [$]2147483647,\"\n \tn += a &^ (1 << 31)\n \n-\t// amd64:\"ANDL [$]-268435457\"\n-\t// riscv64:\"ANDI [$]-268435457\"\n+\t// amd64:\"ANDL [$]-268435457,\"\n+\t// arm64:\"AND [$]-268435457,\"\n+\t// riscv64:\"ANDI [$]-268435457,\"\n \tn += a &^ (1 << 28)\n \n-\t// amd64:\"ANDL [$]-2\"\n-\t// riscv64:\"ANDI [$]-2\"\n+\t// amd64:\"ANDL [$]-2,\"\n+\t// arm64:\"AND [$]-2,\"\n+\t// riscv64:\"ANDI [$]-2,\"\n \tn += a &^ (1 << 0)\n \n \treturn n\n@@ -312,19 +364,23 @@ func bitsClearU32(a, b uint32) (n uint32) {\n \n func bitsFlipU32(a, b uint32) (n uint32) {\n \t// amd64:\"BTCL\"\n+\t// arm64:\"AND [$]31,\" \"MOVD [$]1,\" \"LSL\" \"EOR\"\n \t// riscv64:\"ANDI\" \"SLL\" \"XOR \"\n \tn += b ^ (1 << (a & 31))\n \n-\t// amd64:\"XORL [$]-2147483648\"\n-\t// riscv64:\"XORI [$]-2147483648\"\n+\t// amd64:\"XORL [$]-2147483648,\"\n+\t// arm64:\"EOR [$]-2147483648,\"\n+\t// riscv64:\"XORI [$]-2147483648,\"\n \tn += a ^ (1 << 31)\n \n-\t// amd64:\"XORL [$]268435456\"\n-\t// riscv64:\"XORI [$]268435456\"\n+\t// amd64:\"XORL [$]268435456,\"\n+\t// arm64:\"EOR [$]268435456,\"\n+\t// riscv64:\"XORI [$]268435456,\"\n \tn += a ^ (1 << 28)\n \n-\t// amd64:\"XORL [$]1\"\n-\t// riscv64:\"XORI [$]1\"\n+\t// amd64:\"XORL [$]1,\"\n+\t// arm64:\"EOR [$]1,\"\n+\t// riscv64:\"XORI [$]1,\"\n \tn += a ^ (1 << 0)\n \n \treturn n\n@@ -343,6 +399,7 @@ func bitsOpOnMem(a []uint32, b, c, d uint32) {\n \n func bitsCheckMostNegative(b uint8) bool {\n \t// amd64:\"TESTB\"\n+\t// arm64:\"TSTW\" \"CSET\"\n \t// riscv64:\"ANDI [$]128,\" \"SNEZ\" -\"ADDI\"\n \treturn b&0x80 == 0x80\n }","output":"test(codegen): add arm64 bit operation checks","metadata":{"id":"go-b094749b","repository":"go","commit_hash":"b094749bad125db5b89e48248bbb9c7dc1292a95"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/compile/internal/ssa/_gen/AMD64.rules      |   8 +\n src/cmd/compile/internal/ssa/rewriteAMD64.go       | 168 +++++++++++++++++++++\n .../archsimd/internal/simd_test/compare_test.go    |  34 +++++\n test/codegen/simd.go                               |  31 +++-\n 4 files changed, 239 insertions(+), 2 deletions(-)\n\ndiff --git a/src/cmd/compile/internal/ssa/_gen/AMD64.rules b/src/cmd/compile/internal/ssa/_gen/AMD64.rules\nindex 9c541868..9cd23c62 100644\n--- a/src/cmd/compile/internal/ssa/_gen/AMD64.rules\n+++ b/src/cmd/compile/internal/ssa/_gen/AMD64.rules\n@@ -1824,3 +1824,11 @@\n (EQ (VPTEST x:(VPAND(D|Q)512 j k) y) yes no) && x == y && x.Uses == 2 => (EQ (VPTEST j k) yes no)\n (EQ (VPTEST x:(VPANDN(128|256) j k) y) yes no) && x == y && x.Uses == 2 => (ULT (VPTEST k j) yes no) // AndNot has swapped its operand order\n (EQ (VPTEST x:(VPANDN(D|Q)512 j k) y) yes no) && x == y && x.Uses == 2 => (ULT (VPTEST k j) yes no) // AndNot has swapped its operand order\n+\n+// optimize x.IsNaN().Or(y.IsNaN())\n+(VPOR128 (VCMPP(S|D)128 [3] x x) (VCMPP(S|D)128 [3] y y)) => (VCMPP(S|D)128 [3] x y)\n+(VPOR256 (VCMPP(S|D)256 [3] x x) (VCMPP(S|D)256 [3] y y)) => (VCMPP(S|D)256 [3] x y)\n+(VPORD512 (VPMOVMToVec32x16 (VCMPPS512 [3] x x)) (VPMOVMToVec32x16 (VCMPPS512 [3] y y))) =>\n+\t(VPMOVMToVec32x16 (VCMPPS512 [3] x y))\n+(VPORD512 (VPMOVMToVec64x8  (VCMPPD512 [3] x x)) (VPMOVMToVec64x8  (VCMPPD512 [3] y y))) =>\n+\t(VPMOVMToVec64x8  (VCMPPD512 [3] x y))\ndiff --git a/src/cmd/compile/internal/ssa/rewriteAMD64.go b/src/cmd/compile/internal/ssa/rewriteAMD64.go\nindex 0b2bb74c..3eb2a627 100644\n--- a/src/cmd/compile/internal/ssa/rewriteAMD64.go\n+++ b/src/cmd/compile/internal/ssa/rewriteAMD64.go\n@@ -1382,6 +1382,10 @@ func rewriteValueAMD64(v *Value) bool {\n \t\treturn rewriteValueAMD64_OpAMD64VPOPCNTQMasked256(v)\n \tcase OpAMD64VPOPCNTQMasked512:\n \t\treturn rewriteValueAMD64_OpAMD64VPOPCNTQMasked512(v)\n+\tcase OpAMD64VPOR128:\n+\t\treturn rewriteValueAMD64_OpAMD64VPOR128(v)\n+\tcase OpAMD64VPOR256:\n+\t\treturn rewriteValueAMD64_OpAMD64VPOR256(v)\n \tcase OpAMD64VPORD512:\n \t\treturn rewriteValueAMD64_OpAMD64VPORD512(v)\n \tcase OpAMD64VPORDMasked128:\n@@ -56768,9 +56772,173 @@ func rewriteValueAMD64_OpAMD64VPOPCNTQMasked512(v *Value) bool {\n \t}\n \treturn false\n }\n+func rewriteValueAMD64_OpAMD64VPOR128(v *Value) bool {\n+\tv_1 := v.Args[1]\n+\tv_0 := v.Args[0]\n+\t// match: (VPOR128 (VCMPPS128 [3] x x) (VCMPPS128 [3] y y))\n+\t// result: (VCMPPS128 [3] x y)\n+\tfor {\n+\t\tfor _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {\n+\t\t\tif v_0.Op != OpAMD64VCMPPS128 || auxIntToUint8(v_0.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tx := v_0.Args[1]\n+\t\t\tif x != v_0.Args[0] || v_1.Op != OpAMD64VCMPPS128 || auxIntToUint8(v_1.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ty := v_1.Args[1]\n+\t\t\tif y != v_1.Args[0] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tv.reset(OpAMD64VCMPPS128)\n+\t\t\tv.AuxInt = uint8ToAuxInt(3)\n+\t\t\tv.AddArg2(x, y)\n+\t\t\treturn true\n+\t\t}\n+\t\tbreak\n+\t}\n+\t// match: (VPOR128 (VCMPPD128 [3] x x) (VCMPPD128 [3] y y))\n+\t// result: (VCMPPD128 [3] x y)\n+\tfor {\n+\t\tfor _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {\n+\t\t\tif v_0.Op != OpAMD64VCMPPD128 || auxIntToUint8(v_0.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tx := v_0.Args[1]\n+\t\t\tif x != v_0.Args[0] || v_1.Op != OpAMD64VCMPPD128 || auxIntToUint8(v_1.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ty := v_1.Args[1]\n+\t\t\tif y != v_1.Args[0] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tv.reset(OpAMD64VCMPPD128)\n+\t\t\tv.AuxInt = uint8ToAuxInt(3)\n+\t\t\tv.AddArg2(x, y)\n+\t\t\treturn true\n+\t\t}\n+\t\tbreak\n+\t}\n+\treturn false\n+}\n+func rewriteValueAMD64_OpAMD64VPOR256(v *Value) bool {\n+\tv_1 := v.Args[1]\n+\tv_0 := v.Args[0]\n+\t// match: (VPOR256 (VCMPPS256 [3] x x) (VCMPPS256 [3] y y))\n+\t// result: (VCMPPS256 [3] x y)\n+\tfor {\n+\t\tfor _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {\n+\t\t\tif v_0.Op != OpAMD64VCMPPS256 || auxIntToUint8(v_0.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tx := v_0.Args[1]\n+\t\t\tif x != v_0.Args[0] || v_1.Op != OpAMD64VCMPPS256 || auxIntToUint8(v_1.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ty := v_1.Args[1]\n+\t\t\tif y != v_1.Args[0] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tv.reset(OpAMD64VCMPPS256)\n+\t\t\tv.AuxInt = uint8ToAuxInt(3)\n+\t\t\tv.AddArg2(x, y)\n+\t\t\treturn true\n+\t\t}\n+\t\tbreak\n+\t}\n+\t// match: (VPOR256 (VCMPPD256 [3] x x) (VCMPPD256 [3] y y))\n+\t// result: (VCMPPD256 [3] x y)\n+\tfor {\n+\t\tfor _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {\n+\t\t\tif v_0.Op != OpAMD64VCMPPD256 || auxIntToUint8(v_0.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tx := v_0.Args[1]\n+\t\t\tif x != v_0.Args[0] || v_1.Op != OpAMD64VCMPPD256 || auxIntToUint8(v_1.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ty := v_1.Args[1]\n+\t\t\tif y != v_1.Args[0] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tv.reset(OpAMD64VCMPPD256)\n+\t\t\tv.AuxInt = uint8ToAuxInt(3)\n+\t\t\tv.AddArg2(x, y)\n+\t\t\treturn true\n+\t\t}\n+\t\tbreak\n+\t}\n+\treturn false\n+}\n func rewriteValueAMD64_OpAMD64VPORD512(v *Value) bool {\n \tv_1 := v.Args[1]\n \tv_0 := v.Args[0]\n+\tb := v.Block\n+\ttyp := &b.Func.Config.Types\n+\t// match: (VPORD512 (VPMOVMToVec32x16 (VCMPPS512 [3] x x)) (VPMOVMToVec32x16 (VCMPPS512 [3] y y)))\n+\t// result: (VPMOVMToVec32x16 (VCMPPS512 [3] x y))\n+\tfor {\n+\t\tfor _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {\n+\t\t\tif v_0.Op != OpAMD64VPMOVMToVec32x16 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tv_0_0 := v_0.Args[0]\n+\t\t\tif v_0_0.Op != OpAMD64VCMPPS512 || auxIntToUint8(v_0_0.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tx := v_0_0.Args[1]\n+\t\t\tif x != v_0_0.Args[0] || v_1.Op != OpAMD64VPMOVMToVec32x16 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tv_1_0 := v_1.Args[0]\n+\t\t\tif v_1_0.Op != OpAMD64VCMPPS512 || auxIntToUint8(v_1_0.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ty := v_1_0.Args[1]\n+\t\t\tif y != v_1_0.Args[0] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tv.reset(OpAMD64VPMOVMToVec32x16)\n+\t\t\tv0 := b.NewValue0(v.Pos, OpAMD64VCMPPS512, typ.Mask)\n+\t\t\tv0.AuxInt = uint8ToAuxInt(3)\n+\t\t\tv0.AddArg2(x, y)\n+\t\t\tv.AddArg(v0)\n+\t\t\treturn true\n+\t\t}\n+\t\tbreak\n+\t}\n+\t// match: (VPORD512 (VPMOVMToVec64x8 (VCMPPD512 [3] x x)) (VPMOVMToVec64x8 (VCMPPD512 [3] y y)))\n+\t// result: (VPMOVMToVec64x8 (VCMPPD512 [3] x y))\n+\tfor {\n+\t\tfor _i0 := 0; _i0 <= 1; _i0, v_0, v_1 = _i0+1, v_1, v_0 {\n+\t\t\tif v_0.Op != OpAMD64VPMOVMToVec64x8 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tv_0_0 := v_0.Args[0]\n+\t\t\tif v_0_0.Op != OpAMD64VCMPPD512 || auxIntToUint8(v_0_0.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tx := v_0_0.Args[1]\n+\t\t\tif x != v_0_0.Args[0] || v_1.Op != OpAMD64VPMOVMToVec64x8 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tv_1_0 := v_1.Args[0]\n+\t\t\tif v_1_0.Op != OpAMD64VCMPPD512 || auxIntToUint8(v_1_0.AuxInt) != 3 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\ty := v_1_0.Args[1]\n+\t\t\tif y != v_1_0.Args[0] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tv.reset(OpAMD64VPMOVMToVec64x8)\n+\t\t\tv0 := b.NewValue0(v.Pos, OpAMD64VCMPPD512, typ.Mask)\n+\t\t\tv0.AuxInt = uint8ToAuxInt(3)\n+\t\t\tv0.AddArg2(x, y)\n+\t\t\tv.AddArg(v0)\n+\t\t\treturn true\n+\t\t}\n+\t\tbreak\n+\t}\n \t// match: (VPORD512 x l:(VMOVDQUload512 {sym} [off] ptr mem))\n \t// cond: canMergeLoad(v, l) && clobber(l)\n \t// result: (VPORD512load {sym} [off] x ptr mem)\ndiff --git a/src/simd/archsimd/internal/simd_test/compare_test.go b/src/simd/archsimd/internal/simd_test/compare_test.go\nindex e678676b..ea8514ac 100644\n--- a/src/simd/archsimd/internal/simd_test/compare_test.go\n+++ b/src/simd/archsimd/internal/simd_test/compare_test.go\n@@ -309,4 +309,38 @@ func TestIsNaN(t *testing.T) {\n \t\ttestFloat32x16UnaryCompare(t, archsimd.Float32x16.IsNaN, isNaNSlice[float32])\n \t\ttestFloat64x8UnaryCompare(t, archsimd.Float64x8.IsNaN, isNaNSlice[float64])\n \t}\n+\n+\t// Test x.IsNaN().Or(y.IsNaN()), which is optimized to VCMPP(S|D) $3, x, y.\n+\twant32 := mapCompare(func(x, y float32) bool { return x != x || y != y })\n+\twant64 := mapCompare(func(x, y float64) bool { return x != x || y != y })\n+\ttestFloat32x4Compare(t,\n+\t\tfunc(x, y archsimd.Float32x4) archsimd.Mask32x4 {\n+\t\t\treturn x.IsNaN().Or(y.IsNaN())\n+\t\t}, want32)\n+\ttestFloat64x2Compare(t,\n+\t\tfunc(x, y archsimd.Float64x2) archsimd.Mask64x2 {\n+\t\t\treturn x.IsNaN().Or(y.IsNaN())\n+\t\t}, want64)\n+\n+\tif archsimd.X86.AVX2() {\n+\t\ttestFloat32x8Compare(t,\n+\t\t\tfunc(x, y archsimd.Float32x8) archsimd.Mask32x8 {\n+\t\t\t\treturn x.IsNaN().Or(y.IsNaN())\n+\t\t\t}, want32)\n+\t\ttestFloat64x4Compare(t,\n+\t\t\tfunc(x, y archsimd.Float64x4) archsimd.Mask64x4 {\n+\t\t\t\treturn x.IsNaN().Or(y.IsNaN())\n+\t\t\t}, want64)\n+\t}\n+\n+\tif archsimd.X86.AVX512() {\n+\t\ttestFloat32x16Compare(t,\n+\t\t\tfunc(x, y archsimd.Float32x16) archsimd.Mask32x16 {\n+\t\t\t\treturn x.IsNaN().Or(y.IsNaN())\n+\t\t\t}, want32)\n+\t\ttestFloat64x8Compare(t,\n+\t\t\tfunc(x, y archsimd.Float64x8) archsimd.Mask64x8 {\n+\t\t\t\treturn x.IsNaN().Or(y.IsNaN())\n+\t\t\t}, want64)\n+\t}\n }\ndiff --git a/test/codegen/simd.go b/test/codegen/simd.go\nindex 8f3a1a9f..04e01944 100644\n--- a/test/codegen/simd.go\n+++ b/test/codegen/simd.go\n@@ -6,11 +6,14 @@\n \n // These tests check code generation of simd peephole optimizations.\n \n-//go:build goexperiment.simd\n+//go:build goexperiment.simd && amd64\n \n package codegen\n \n-import \"simd/archsimd\"\n+import (\n+\t\"math\"\n+\t\"simd/archsimd\"\n+)\n \n func vptest1() bool {\n \tv1 := archsimd.LoadUint64x2Slice([]uint64{0, 1})\n@@ -77,3 +80,27 @@ func simdMaskedMerge() archsimd.Int16x16 {\n \tmask := archsimd.Mask16x16FromBits(5)\n \treturn x.Add(y).Merge(x, mask) // amd64:`VPBLENDVB\\s.*$`\n }\n+\n+var nan = math.NaN()\n+var floats64s = []float64{0, 1, 2, nan, 4, nan, 6, 7, 8, 9, 10, 11, nan, 13, 14, 15}\n+var sinkInt64s = make([]int64, 100)\n+\n+func simdIsNaN() {\n+\tx := archsimd.LoadFloat64x4Slice(floats64s)\n+\ty := archsimd.LoadFloat64x4Slice(floats64s[4:])\n+\ta := x.IsNaN()\n+\tb := y.IsNaN()\n+\t// amd64:\"VCMPPD [$]3,\" -\"VPOR\"\n+\tc := a.Or(b)\n+\tc.ToInt64x4().StoreSlice(sinkInt64s)\n+}\n+\n+func simdIsNaN512() {\n+\tx := archsimd.LoadFloat64x8Slice(floats64s)\n+\ty := archsimd.LoadFloat64x8Slice(floats64s[8:])\n+\ta := x.IsNaN()\n+\tb := y.IsNaN()\n+\t// amd64:\"VCMPPD [$]3,\" -\"VPOR\"\n+\tc := a.Or(b)\n+\tc.ToInt64x8().StoreSlice(sinkInt64s)\n+}","output":"feat(ssa): optimize IsNaN or pattern for SIMD comparisons","metadata":{"id":"go-e84983fa","repository":"go","commit_hash":"e84983fa40a6e97d3e169f1f3549af889b1b1f22"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/simd/archsimd/_gen/tmplgen/main.go             | 23 +++++-\n .../internal/simd_test/compare_helpers_test.go     | 84 ++++++++++++++++++++++\n .../archsimd/internal/simd_test/compare_test.go    | 12 ++++\n .../archsimd/internal/simd_test/helpers_test.go    |  6 +-\n .../internal/simd_test/simulation_helpers_test.go  | 13 ++++\n 5 files changed, 135 insertions(+), 3 deletions(-)\n\ndiff --git a/src/simd/archsimd/_gen/tmplgen/main.go b/src/simd/archsimd/_gen/tmplgen/main.go\nindex e0d607af..8db185e1 100644\n--- a/src/simd/archsimd/_gen/tmplgen/main.go\n+++ b/src/simd/archsimd/_gen/tmplgen/main.go\n@@ -104,6 +104,11 @@ var uintShapes = &shapes{\n \tuints: []int{8, 16, 32, 64},\n }\n \n+var floatShapes = &shapes{\n+\tvecs:   []int{128, 256, 512},\n+\tfloats: []int{32, 64},\n+}\n+\n var integerShapes = &shapes{\n \tvecs:  []int{128, 256, 512},\n \tints:  []int{8, 16, 32, 64},\n@@ -507,6 +512,22 @@ func test{{.VType}}Compare(t *testing.T, f func(_, _ archsimd.{{.VType}}) archsi\n }\n `)\n \n+var compareUnaryTemplate = shapedTemplateOf(floatShapes, \"compare_unary_helpers\", `\n+// test{{.VType}}UnaryCompare tests the simd unary comparison method f against the expected behavior generated by want\n+func test{{.VType}}UnaryCompare(t *testing.T, f func(x archsimd.{{.VType}}) archsimd.Mask{{.WxC}}, want func(x []{{.Etype}}) []int64) {\n+\tn := {{.Count}}\n+\tt.Helper()\n+\tforSlice(t, {{.Etype}}s, n, func(x []{{.Etype}}) bool {\n+\t \tt.Helper()\n+\t\ta := archsimd.Load{{.VType}}Slice(x)\n+\t\tg := make([]int{{.EWidth}}, n)\n+\t\tf(a).ToInt{{.WxC}}().StoreSlice(g)\n+\t\tw := want(x)\n+\t\treturn checkSlicesLogInput(t, s64(g), w, 0.0, func() {t.Helper(); t.Logf(\"x=%v\", x)})\n+\t})\n+}\n+`)\n+\n // TODO this has not been tested yet.\n var compareMaskedTemplate = templateOf(\"comparemasked_helpers\", `\n // test{{.VType}}CompareMasked tests the simd masked comparison method f against the expected behavior generated by want\n@@ -941,7 +962,7 @@ func main() {\n \t\tone(*th, curryTestPrologue(\"ternary simd methods\"), ternaryTemplate, ternaryFlakyTemplate)\n \t}\n \tif *ch != \"\" {\n-\t\tone(*ch, curryTestPrologue(\"simd methods that compare two operands\"), compareTemplate)\n+\t\tone(*ch, curryTestPrologue(\"simd methods that compare two operands\"), compareTemplate, compareUnaryTemplate)\n \t}\n \tif *cmh != \"\" {\n \t\tone(*cmh, curryTestPrologue(\"simd methods that compare two operands under a mask\"), compareMaskedTemplate)\ndiff --git a/src/simd/archsimd/internal/simd_test/compare_helpers_test.go b/src/simd/archsimd/internal/simd_test/compare_helpers_test.go\nindex c520aa7f..7a33f0ff 100644\n--- a/src/simd/archsimd/internal/simd_test/compare_helpers_test.go\n+++ b/src/simd/archsimd/internal/simd_test/compare_helpers_test.go\n@@ -462,3 +462,87 @@ func testFloat64x8Compare(t *testing.T, f func(_, _ archsimd.Float64x8) archsimd\n \t\treturn checkSlicesLogInput(t, s64(g), w, 0.0, func() { t.Helper(); t.Logf(\"x=%v\", x); t.Logf(\"y=%v\", y) })\n \t})\n }\n+\n+// testFloat32x4UnaryCompare tests the simd unary comparison method f against the expected behavior generated by want\n+func testFloat32x4UnaryCompare(t *testing.T, f func(x archsimd.Float32x4) archsimd.Mask32x4, want func(x []float32) []int64) {\n+\tn := 4\n+\tt.Helper()\n+\tforSlice(t, float32s, n, func(x []float32) bool {\n+\t\tt.Helper()\n+\t\ta := archsimd.LoadFloat32x4Slice(x)\n+\t\tg := make([]int32, n)\n+\t\tf(a).ToInt32x4().StoreSlice(g)\n+\t\tw := want(x)\n+\t\treturn checkSlicesLogInput(t, s64(g), w, 0.0, func() { t.Helper(); t.Logf(\"x=%v\", x) })\n+\t})\n+}\n+\n+// testFloat64x2UnaryCompare tests the simd unary comparison method f against the expected behavior generated by want\n+func testFloat64x2UnaryCompare(t *testing.T, f func(x archsimd.Float64x2) archsimd.Mask64x2, want func(x []float64) []int64) {\n+\tn := 2\n+\tt.Helper()\n+\tforSlice(t, float64s, n, func(x []float64) bool {\n+\t\tt.Helper()\n+\t\ta := archsimd.LoadFloat64x2Slice(x)\n+\t\tg := make([]int64, n)\n+\t\tf(a).ToInt64x2().StoreSlice(g)\n+\t\tw := want(x)\n+\t\treturn checkSlicesLogInput(t, s64(g), w, 0.0, func() { t.Helper(); t.Logf(\"x=%v\", x) })\n+\t})\n+}\n+\n+// testFloat32x8UnaryCompare tests the simd unary comparison method f against the expected behavior generated by want\n+func testFloat32x8UnaryCompare(t *testing.T, f func(x archsimd.Float32x8) archsimd.Mask32x8, want func(x []float32) []int64) {\n+\tn := 8\n+\tt.Helper()\n+\tforSlice(t, float32s, n, func(x []float32) bool {\n+\t\tt.Helper()\n+\t\ta := archsimd.LoadFloat32x8Slice(x)\n+\t\tg := make([]int32, n)\n+\t\tf(a).ToInt32x8().StoreSlice(g)\n+\t\tw := want(x)\n+\t\treturn checkSlicesLogInput(t, s64(g), w, 0.0, func() { t.Helper(); t.Logf(\"x=%v\", x) })\n+\t})\n+}\n+\n+// testFloat64x4UnaryCompare tests the simd unary comparison method f against the expected behavior generated by want\n+func testFloat64x4UnaryCompare(t *testing.T, f func(x archsimd.Float64x4) archsimd.Mask64x4, want func(x []float64) []int64) {\n+\tn := 4\n+\tt.Helper()\n+\tforSlice(t, float64s, n, func(x []float64) bool {\n+\t\tt.Helper()\n+\t\ta := archsimd.LoadFloat64x4Slice(x)\n+\t\tg := make([]int64, n)\n+\t\tf(a).ToInt64x4().StoreSlice(g)\n+\t\tw := want(x)\n+\t\treturn checkSlicesLogInput(t, s64(g), w, 0.0, func() { t.Helper(); t.Logf(\"x=%v\", x) })\n+\t})\n+}\n+\n+// testFloat32x16UnaryCompare tests the simd unary comparison method f against the expected behavior generated by want\n+func testFloat32x16UnaryCompare(t *testing.T, f func(x archsimd.Float32x16) archsimd.Mask32x16, want func(x []float32) []int64) {\n+\tn := 16\n+\tt.Helper()\n+\tforSlice(t, float32s, n, func(x []float32) bool {\n+\t\tt.Helper()\n+\t\ta := archsimd.LoadFloat32x16Slice(x)\n+\t\tg := make([]int32, n)\n+\t\tf(a).ToInt32x16().StoreSlice(g)\n+\t\tw := want(x)\n+\t\treturn checkSlicesLogInput(t, s64(g), w, 0.0, func() { t.Helper(); t.Logf(\"x=%v\", x) })\n+\t})\n+}\n+\n+// testFloat64x8UnaryCompare tests the simd unary comparison method f against the expected behavior generated by want\n+func testFloat64x8UnaryCompare(t *testing.T, f func(x archsimd.Float64x8) archsimd.Mask64x8, want func(x []float64) []int64) {\n+\tn := 8\n+\tt.Helper()\n+\tforSlice(t, float64s, n, func(x []float64) bool {\n+\t\tt.Helper()\n+\t\ta := archsimd.LoadFloat64x8Slice(x)\n+\t\tg := make([]int64, n)\n+\t\tf(a).ToInt64x8().StoreSlice(g)\n+\t\tw := want(x)\n+\t\treturn checkSlicesLogInput(t, s64(g), w, 0.0, func() { t.Helper(); t.Logf(\"x=%v\", x) })\n+\t})\n+}\ndiff --git a/src/simd/archsimd/internal/simd_test/compare_test.go b/src/simd/archsimd/internal/simd_test/compare_test.go\nindex efafbfdc..e678676b 100644\n--- a/src/simd/archsimd/internal/simd_test/compare_test.go\n+++ b/src/simd/archsimd/internal/simd_test/compare_test.go\n@@ -298,3 +298,15 @@ func TestNotEqual(t *testing.T) {\n \t\ttestUint64x8Compare(t, archsimd.Uint64x8.NotEqual, notEqualSlice[uint64])\n \t}\n }\n+\n+func TestIsNaN(t *testing.T) {\n+\ttestFloat32x4UnaryCompare(t, archsimd.Float32x4.IsNaN, isNaNSlice[float32])\n+\ttestFloat32x8UnaryCompare(t, archsimd.Float32x8.IsNaN, isNaNSlice[float32])\n+\ttestFloat64x2UnaryCompare(t, archsimd.Float64x2.IsNaN, isNaNSlice[float64])\n+\ttestFloat64x4UnaryCompare(t, archsimd.Float64x4.IsNaN, isNaNSlice[float64])\n+\n+\tif archsimd.X86.AVX512() {\n+\t\ttestFloat32x16UnaryCompare(t, archsimd.Float32x16.IsNaN, isNaNSlice[float32])\n+\t\ttestFloat64x8UnaryCompare(t, archsimd.Float64x8.IsNaN, isNaNSlice[float64])\n+\t}\n+}\ndiff --git a/src/simd/archsimd/internal/simd_test/helpers_test.go b/src/simd/archsimd/internal/simd_test/helpers_test.go\nindex 37cc9819..d6963586 100644\n--- a/src/simd/archsimd/internal/simd_test/helpers_test.go\n+++ b/src/simd/archsimd/internal/simd_test/helpers_test.go\n@@ -182,12 +182,14 @@ var nzero = -zero\n var inf = 1 / zero\n var ninf = -1 / zero\n var nan = math.NaN()\n+var snan32 = math.Float32frombits(0x7f800001)\n+var snan64 = math.Float64frombits(0x7ff0000000000001)\n \n // N controls how large the test vectors are\n const N = 144\n \n-var float32s = nOf(N, []float32{float32(inf), float32(ninf), 1, float32(nan), float32(zero), 2, float32(nan), float32(zero), 3, float32(-zero), float32(1.0 / zero), float32(-1.0 / zero), 1.0 / 2, 1.0 / 4, 1.0 / 8, 1.0 / 1000, 1.0 / 1000000, 1, -1, 0, 2, -2, 3, -3, math.MaxFloat32, 1 / math.MaxFloat32, 10, -10, 100, 20, -20, 300, -300, -4000, -80, -160, -3200, -64, -4, -8, -16, -32, -64})\n-var float64s = nOf(N, []float64{inf, ninf, nan, zero, -zero, 1 / zero, -1 / zero, 0.0001, 0.0000001, 1, -1, 0, 2, -2, 3, -3, math.MaxFloat64, 1.0 / math.MaxFloat64, 10, -10, 100, 20, -20, 300, -300, -4000, -80, -16, -32, -64})\n+var float32s = nOf(N, []float32{float32(inf), float32(ninf), 1, float32(nan), snan32, -float32(nan), -snan32, float32(zero), 2, float32(nan), float32(zero), 3, float32(-zero), float32(1.0 / zero), float32(-1.0 / zero), 1.0 / 2, 1.0 / 4, 1.0 / 8, 1.0 / 1000, 1.0 / 1000000, 1, -1, 0, 2, -2, 3, -3, math.MaxFloat32, 1 / math.MaxFloat32, 10, -10, 100, 20, -20, 300, -300, -4000, -80, -160, -3200, -64, -4, -8, -16, -32, -64})\n+var float64s = nOf(N, []float64{inf, ninf, nan, snan64, -nan, -snan64, zero, -zero, 1 / zero, -1 / zero, 0.0001, 0.0000001, 1, -1, 0, 2, -2, 3, -3, math.MaxFloat64, 1.0 / math.MaxFloat64, 10, -10, 100, 20, -20, 300, -300, -4000, -80, -16, -32, -64})\n \n var int32s = nOf(N, []int32{1, -1, 0, 2, 4, 8, 1024, 0xffffff, -0xffffff, 0x55555, 0x77777, 0xccccc, -0x55555, -0x77777, -0xccccc, -4, -8, -16, -32, -64})\n var uint32s = nOf(N, []uint32{1, 0, 2, 4, 8, 1024, 0xffffff, ^uint32(0xffffff), 0x55555, 0x77777, 0xccccc, ^uint32(0x55555), ^uint32(0x77777), ^uint32(0xccccc)})\ndiff --git a/src/simd/archsimd/internal/simd_test/simulation_helpers_test.go b/src/simd/archsimd/internal/simd_test/simulation_helpers_test.go\nindex da107d80..ac60b6d3 100644\n--- a/src/simd/archsimd/internal/simd_test/simulation_helpers_test.go\n+++ b/src/simd/archsimd/internal/simd_test/simulation_helpers_test.go\n@@ -29,6 +29,10 @@ func notEqual[T number](x, y T) bool {\n \treturn x != y\n }\n \n+func isNaN[T float](x T) bool {\n+\treturn x != x\n+}\n+\n func abs[T number](x T) T {\n \t// TODO this will need a non-standard FP-equality test.\n \tif x == 0 { // true if x is -0.\n@@ -299,6 +303,15 @@ func notEqualSlice[T number](x, y []T) []int64 {\n \treturn mapCompare[T](notEqual)(x, y)\n }\n \n+func isNaNSlice[T float](x []T) []int64 {\n+\treturn map1[T](func(x T) int64 {\n+\t\tif isNaN(x) {\n+\t\t\treturn -1\n+\t\t}\n+\t\treturn 0\n+\t})(x)\n+}\n+\n func ceilSlice[T float](x []T) []T {\n \treturn map1[T](ceil)(x)\n }","output":"test(simd): add unary comparison helpers and IsNaN tests","metadata":{"id":"go-8244b856","repository":"go","commit_hash":"8244b8567704739d9d6fa69a0f4b50b3203d6504"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/compile/internal/ssa/_gen/AMD64.rules      |  7 ++\n src/cmd/compile/internal/ssa/_gen/genericOps.go    |  8 +++\n src/cmd/compile/internal/ssa/_gen/simdAMD64.rules  |  6 --\n .../compile/internal/ssa/_gen/simdgenericOps.go    |  6 --\n src/cmd/compile/internal/ssa/opGen.go              | 78 ++++++++++----------\n src/cmd/compile/internal/ssa/rewriteAMD64.go       | 84 ++++++++++------------\n src/cmd/compile/internal/ssagen/intrinsics.go      |  6 ++\n src/cmd/compile/internal/ssagen/simdintrinsics.go  |  6 --\n .../_gen/simdgen/ops/Compares/categories.yaml      |  5 --\n .../archsimd/_gen/simdgen/ops/Compares/go.yaml     |  4 +-\n src/simd/archsimd/extra_amd64.go                   | 36 ++++++++++\n src/simd/archsimd/ops_amd64.go                     | 32 ---------\n 12 files changed, 131 insertions(+), 147 deletions(-)\n\ndiff --git a/src/cmd/compile/internal/ssa/_gen/AMD64.rules b/src/cmd/compile/internal/ssa/_gen/AMD64.rules\nindex 38ca44f7..9c541868 100644\n--- a/src/cmd/compile/internal/ssa/_gen/AMD64.rules\n+++ b/src/cmd/compile/internal/ssa/_gen/AMD64.rules\n@@ -1730,6 +1730,13 @@\n // Misc\n (IsZeroVec x) => (SETEQ (VPTEST x x))\n \n+(IsNaNFloat32x4  x) => (VCMPPS128 [3] x x)\n+(IsNaNFloat32x8  x) => (VCMPPS256 [3] x x)\n+(IsNaNFloat32x16 x) => (VPMOVMToVec32x16 (VCMPPS512 [3] x x))\n+(IsNaNFloat64x2  x) => (VCMPPD128 [3] x x)\n+(IsNaNFloat64x4  x) => (VCMPPD256 [3] x x)\n+(IsNaNFloat64x8  x) => (VPMOVMToVec64x8 (VCMPPD512 [3] x x))\n+\n // SIMD vector K-masked loads and stores\n \n (LoadMasked64 <t> ptr mask mem) && t.Size() == 64 => (VPMASK64load512 ptr (VPMOVVec64x8ToM  <types.TypeMask> mask) mem)\ndiff --git a/src/cmd/compile/internal/ssa/_gen/genericOps.go b/src/cmd/compile/internal/ssa/_gen/genericOps.go\nindex 8637133e..85bde1aa 100644\n--- a/src/cmd/compile/internal/ssa/_gen/genericOps.go\n+++ b/src/cmd/compile/internal/ssa/_gen/genericOps.go\n@@ -715,6 +715,14 @@ var genericOps = []opData{\n \n \t// Returns true if arg0 is all zero.\n \t{name: \"IsZeroVec\", argLength: 1},\n+\n+\t// Returns a mask indicating whether arg0's elements are NaN.\n+\t{name: \"IsNaNFloat32x4\", argLength: 1},\n+\t{name: \"IsNaNFloat32x8\", argLength: 1},\n+\t{name: \"IsNaNFloat32x16\", argLength: 1},\n+\t{name: \"IsNaNFloat64x2\", argLength: 1},\n+\t{name: \"IsNaNFloat64x4\", argLength: 1},\n+\t{name: \"IsNaNFloat64x8\", argLength: 1},\n }\n \n //     kind          controls          successors   implicit exit\ndiff --git a/src/cmd/compile/internal/ssa/_gen/simdAMD64.rules b/src/cmd/compile/internal/ssa/_gen/simdAMD64.rules\nindex 8a5b70da..5c83f39a 100644\n--- a/src/cmd/compile/internal/ssa/_gen/simdAMD64.rules\n+++ b/src/cmd/compile/internal/ssa/_gen/simdAMD64.rules\n@@ -559,12 +559,6 @@\n (InterleaveLoGroupedUint32x16 ...) => (VPUNPCKLDQ512 ...)\n (InterleaveLoGroupedUint64x4 ...) => (VPUNPCKLQDQ256 ...)\n (InterleaveLoGroupedUint64x8 ...) => (VPUNPCKLQDQ512 ...)\n-(IsNanFloat32x4 x y) => (VCMPPS128 [3] x y)\n-(IsNanFloat32x8 x y) => (VCMPPS256 [3] x y)\n-(IsNanFloat32x16 x y) => (VPMOVMToVec32x16 (VCMPPS512 [3] x y))\n-(IsNanFloat64x2 x y) => (VCMPPD128 [3] x y)\n-(IsNanFloat64x4 x y) => (VCMPPD256 [3] x y)\n-(IsNanFloat64x8 x y) => (VPMOVMToVec64x8 (VCMPPD512 [3] x y))\n (LeadingZerosInt32x4 ...) => (VPLZCNTD128 ...)\n (LeadingZerosInt32x8 ...) => (VPLZCNTD256 ...)\n (LeadingZerosInt32x16 ...) => (VPLZCNTD512 ...)\ndiff --git a/src/cmd/compile/internal/ssa/_gen/simdgenericOps.go b/src/cmd/compile/internal/ssa/_gen/simdgenericOps.go\nindex af1007cd..889ab0d8 100644\n--- a/src/cmd/compile/internal/ssa/_gen/simdgenericOps.go\n+++ b/src/cmd/compile/internal/ssa/_gen/simdgenericOps.go\n@@ -519,12 +519,6 @@ func simdGenericOps() []opData {\n \t\t{name: \"InterleaveLoUint16x8\", argLength: 2, commutative: false},\n \t\t{name: \"InterleaveLoUint32x4\", argLength: 2, commutative: false},\n \t\t{name: \"InterleaveLoUint64x2\", argLength: 2, commutative: false},\n-\t\t{name: \"IsNanFloat32x4\", argLength: 2, commutative: true},\n-\t\t{name: \"IsNanFloat32x8\", argLength: 2, commutative: true},\n-\t\t{name: \"IsNanFloat32x16\", argLength: 2, commutative: true},\n-\t\t{name: \"IsNanFloat64x2\", argLength: 2, commutative: true},\n-\t\t{name: \"IsNanFloat64x4\", argLength: 2, commutative: true},\n-\t\t{name: \"IsNanFloat64x8\", argLength: 2, commutative: true},\n \t\t{name: \"LeadingZerosInt32x4\", argLength: 1, commutative: false},\n \t\t{name: \"LeadingZerosInt32x8\", argLength: 1, commutative: false},\n \t\t{name: \"LeadingZerosInt32x16\", argLength: 1, commutative: false},\ndiff --git a/src/cmd/compile/internal/ssa/opGen.go b/src/cmd/compile/internal/ssa/opGen.go\nindex d2ba15f7..abaf7911 100644\n--- a/src/cmd/compile/internal/ssa/opGen.go\n+++ b/src/cmd/compile/internal/ssa/opGen.go\n@@ -6158,6 +6158,12 @@ const (\n \tOpCvtMask64x4to8\n \tOpCvtMask64x8to8\n \tOpIsZeroVec\n+\tOpIsNaNFloat32x4\n+\tOpIsNaNFloat32x8\n+\tOpIsNaNFloat32x16\n+\tOpIsNaNFloat64x2\n+\tOpIsNaNFloat64x4\n+\tOpIsNaNFloat64x8\n \tOpAESDecryptLastRoundUint8x16\n \tOpAESDecryptLastRoundUint8x32\n \tOpAESDecryptLastRoundUint8x64\n@@ -6673,12 +6679,6 @@ const (\n \tOpInterleaveLoUint16x8\n \tOpInterleaveLoUint32x4\n \tOpInterleaveLoUint64x2\n-\tOpIsNanFloat32x4\n-\tOpIsNanFloat32x8\n-\tOpIsNanFloat32x16\n-\tOpIsNanFloat64x2\n-\tOpIsNanFloat64x4\n-\tOpIsNanFloat64x8\n \tOpLeadingZerosInt32x4\n \tOpLeadingZerosInt32x8\n \tOpLeadingZerosInt32x16\n@@ -88993,6 +88993,36 @@ var opcodeTable = [...]opInfo{\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n+\t{\n+\t\tname:    \"IsNaNFloat32x4\",\n+\t\targLen:  1,\n+\t\tgeneric: true,\n+\t},\n+\t{\n+\t\tname:    \"IsNaNFloat32x8\",\n+\t\targLen:  1,\n+\t\tgeneric: true,\n+\t},\n+\t{\n+\t\tname:    \"IsNaNFloat32x16\",\n+\t\targLen:  1,\n+\t\tgeneric: true,\n+\t},\n+\t{\n+\t\tname:    \"IsNaNFloat64x2\",\n+\t\targLen:  1,\n+\t\tgeneric: true,\n+\t},\n+\t{\n+\t\tname:    \"IsNaNFloat64x4\",\n+\t\targLen:  1,\n+\t\tgeneric: true,\n+\t},\n+\t{\n+\t\tname:    \"IsNaNFloat64x8\",\n+\t\targLen:  1,\n+\t\tgeneric: true,\n+\t},\n \t{\n \t\tname:    \"AESDecryptLastRoundUint8x16\",\n \t\targLen:  2,\n@@ -91670,42 +91700,6 @@ var opcodeTable = [...]opInfo{\n \t\targLen:  2,\n \t\tgeneric: true,\n \t},\n-\t{\n-\t\tname:        \"IsNanFloat32x4\",\n-\t\targLen:      2,\n-\t\tcommutative: true,\n-\t\tgeneric:     true,\n-\t},\n-\t{\n-\t\tname:        \"IsNanFloat32x8\",\n-\t\targLen:      2,\n-\t\tcommutative: true,\n-\t\tgeneric:     true,\n-\t},\n-\t{\n-\t\tname:        \"IsNanFloat32x16\",\n-\t\targLen:      2,\n-\t\tcommutative: true,\n-\t\tgeneric:     true,\n-\t},\n-\t{\n-\t\tname:        \"IsNanFloat64x2\",\n-\t\targLen:      2,\n-\t\tcommutative: true,\n-\t\tgeneric:     true,\n-\t},\n-\t{\n-\t\tname:        \"IsNanFloat64x4\",\n-\t\targLen:      2,\n-\t\tcommutative: true,\n-\t\tgeneric:     true,\n-\t},\n-\t{\n-\t\tname:        \"IsNanFloat64x8\",\n-\t\targLen:      2,\n-\t\tcommutative: true,\n-\t\tgeneric:     true,\n-\t},\n \t{\n \t\tname:    \"LeadingZerosInt32x4\",\n \t\targLen:  1,\ndiff --git a/src/cmd/compile/internal/ssa/rewriteAMD64.go b/src/cmd/compile/internal/ssa/rewriteAMD64.go\nindex 0c044100..0b2bb74c 100644\n--- a/src/cmd/compile/internal/ssa/rewriteAMD64.go\n+++ b/src/cmd/compile/internal/ssa/rewriteAMD64.go\n@@ -3773,18 +3773,18 @@ func rewriteValueAMD64(v *Value) bool {\n \t\treturn true\n \tcase OpIsInBounds:\n \t\treturn rewriteValueAMD64_OpIsInBounds(v)\n-\tcase OpIsNanFloat32x16:\n-\t\treturn rewriteValueAMD64_OpIsNanFloat32x16(v)\n-\tcase OpIsNanFloat32x4:\n-\t\treturn rewriteValueAMD64_OpIsNanFloat32x4(v)\n-\tcase OpIsNanFloat32x8:\n-\t\treturn rewriteValueAMD64_OpIsNanFloat32x8(v)\n-\tcase OpIsNanFloat64x2:\n-\t\treturn rewriteValueAMD64_OpIsNanFloat64x2(v)\n-\tcase OpIsNanFloat64x4:\n-\t\treturn rewriteValueAMD64_OpIsNanFloat64x4(v)\n-\tcase OpIsNanFloat64x8:\n-\t\treturn rewriteValueAMD64_OpIsNanFloat64x8(v)\n+\tcase OpIsNaNFloat32x16:\n+\t\treturn rewriteValueAMD64_OpIsNaNFloat32x16(v)\n+\tcase OpIsNaNFloat32x4:\n+\t\treturn rewriteValueAMD64_OpIsNaNFloat32x4(v)\n+\tcase OpIsNaNFloat32x8:\n+\t\treturn rewriteValueAMD64_OpIsNaNFloat32x8(v)\n+\tcase OpIsNaNFloat64x2:\n+\t\treturn rewriteValueAMD64_OpIsNaNFloat64x2(v)\n+\tcase OpIsNaNFloat64x4:\n+\t\treturn rewriteValueAMD64_OpIsNaNFloat64x4(v)\n+\tcase OpIsNaNFloat64x8:\n+\t\treturn rewriteValueAMD64_OpIsNaNFloat64x8(v)\n \tcase OpIsNonNil:\n \t\treturn rewriteValueAMD64_OpIsNonNil(v)\n \tcase OpIsSliceInBounds:\n@@ -70957,94 +70957,82 @@ func rewriteValueAMD64_OpIsInBounds(v *Value) bool {\n \t\treturn true\n \t}\n }\n-func rewriteValueAMD64_OpIsNanFloat32x16(v *Value) bool {\n-\tv_1 := v.Args[1]\n+func rewriteValueAMD64_OpIsNaNFloat32x16(v *Value) bool {\n \tv_0 := v.Args[0]\n \tb := v.Block\n \ttyp := &b.Func.Config.Types\n-\t// match: (IsNanFloat32x16 x y)\n-\t// result: (VPMOVMToVec32x16 (VCMPPS512 [3] x y))\n+\t// match: (IsNaNFloat32x16 x)\n+\t// result: (VPMOVMToVec32x16 (VCMPPS512 [3] x x))\n \tfor {\n \t\tx := v_0\n-\t\ty := v_1\n \t\tv.reset(OpAMD64VPMOVMToVec32x16)\n \t\tv0 := b.NewValue0(v.Pos, OpAMD64VCMPPS512, typ.Mask)\n \t\tv0.AuxInt = uint8ToAuxInt(3)\n-\t\tv0.AddArg2(x, y)\n+\t\tv0.AddArg2(x, x)\n \t\tv.AddArg(v0)\n \t\treturn true\n \t}\n }\n-func rewriteValueAMD64_OpIsNanFloat32x4(v *Value) bool {\n-\tv_1 := v.Args[1]\n+func rewriteValueAMD64_OpIsNaNFloat32x4(v *Value) bool {\n \tv_0 := v.Args[0]\n-\t// match: (IsNanFloat32x4 x y)\n-\t// result: (VCMPPS128 [3] x y)\n+\t// match: (IsNaNFloat32x4 x)\n+\t// result: (VCMPPS128 [3] x x)\n \tfor {\n \t\tx := v_0\n-\t\ty := v_1\n \t\tv.reset(OpAMD64VCMPPS128)\n \t\tv.AuxInt = uint8ToAuxInt(3)\n-\t\tv.AddArg2(x, y)\n+\t\tv.AddArg2(x, x)\n \t\treturn true\n \t}\n }\n-func rewriteValueAMD64_OpIsNanFloat32x8(v *Value) bool {\n-\tv_1 := v.Args[1]\n+func rewriteValueAMD64_OpIsNaNFloat32x8(v *Value) bool {\n \tv_0 := v.Args[0]\n-\t// match: (IsNanFloat32x8 x y)\n-\t// result: (VCMPPS256 [3] x y)\n+\t// match: (IsNaNFloat32x8 x)\n+\t// result: (VCMPPS256 [3] x x)\n \tfor {\n \t\tx := v_0\n-\t\ty := v_1\n \t\tv.reset(OpAMD64VCMPPS256)\n \t\tv.AuxInt = uint8ToAuxInt(3)\n-\t\tv.AddArg2(x, y)\n+\t\tv.AddArg2(x, x)\n \t\treturn true\n \t}\n }\n-func rewriteValueAMD64_OpIsNanFloat64x2(v *Value) bool {\n-\tv_1 := v.Args[1]\n+func rewriteValueAMD64_OpIsNaNFloat64x2(v *Value) bool {\n \tv_0 := v.Args[0]\n-\t// match: (IsNanFloat64x2 x y)\n-\t// result: (VCMPPD128 [3] x y)\n+\t// match: (IsNaNFloat64x2 x)\n+\t// result: (VCMPPD128 [3] x x)\n \tfor {\n \t\tx := v_0\n-\t\ty := v_1\n \t\tv.reset(OpAMD64VCMPPD128)\n \t\tv.AuxInt = uint8ToAuxInt(3)\n-\t\tv.AddArg2(x, y)\n+\t\tv.AddArg2(x, x)\n \t\treturn true\n \t}\n }\n-func rewriteValueAMD64_OpIsNanFloat64x4(v *Value) bool {\n-\tv_1 := v.Args[1]\n+func rewriteValueAMD64_OpIsNaNFloat64x4(v *Value) bool {\n \tv_0 := v.Args[0]\n-\t// match: (IsNanFloat64x4 x y)\n-\t// result: (VCMPPD256 [3] x y)\n+\t// match: (IsNaNFloat64x4 x)\n+\t// result: (VCMPPD256 [3] x x)\n \tfor {\n \t\tx := v_0\n-\t\ty := v_1\n \t\tv.reset(OpAMD64VCMPPD256)\n \t\tv.AuxInt = uint8ToAuxInt(3)\n-\t\tv.AddArg2(x, y)\n+\t\tv.AddArg2(x, x)\n \t\treturn true\n \t}\n }\n-func rewriteValueAMD64_OpIsNanFloat64x8(v *Value) bool {\n-\tv_1 := v.Args[1]\n+func rewriteValueAMD64_OpIsNaNFloat64x8(v *Value) bool {\n \tv_0 := v.Args[0]\n \tb := v.Block\n \ttyp := &b.Func.Config.Types\n-\t// match: (IsNanFloat64x8 x y)\n-\t// result: (VPMOVMToVec64x8 (VCMPPD512 [3] x y))\n+\t// match: (IsNaNFloat64x8 x)\n+\t// result: (VPMOVMToVec64x8 (VCMPPD512 [3] x x))\n \tfor {\n \t\tx := v_0\n-\t\ty := v_1\n \t\tv.reset(OpAMD64VPMOVMToVec64x8)\n \t\tv0 := b.NewValue0(v.Pos, OpAMD64VCMPPD512, typ.Mask)\n \t\tv0.AuxInt = uint8ToAuxInt(3)\n-\t\tv0.AddArg2(x, y)\n+\t\tv0.AddArg2(x, x)\n \t\tv.AddArg(v0)\n \t\treturn true\n \t}\ndiff --git a/src/cmd/compile/internal/ssagen/intrinsics.go b/src/cmd/compile/internal/ssagen/intrinsics.go\nindex 4425c561..e2eebd78 100644\n--- a/src/cmd/compile/internal/ssagen/intrinsics.go\n+++ b/src/cmd/compile/internal/ssagen/intrinsics.go\n@@ -1667,6 +1667,12 @@ func initIntrinsics(cfg *intrinsicBuildConfig) {\n \t\taddF(simdPackage, \"Uint16x16.IsZero\", opLen1(ssa.OpIsZeroVec, types.Types[types.TBOOL]), sys.AMD64)\n \t\taddF(simdPackage, \"Uint32x8.IsZero\", opLen1(ssa.OpIsZeroVec, types.Types[types.TBOOL]), sys.AMD64)\n \t\taddF(simdPackage, \"Uint64x4.IsZero\", opLen1(ssa.OpIsZeroVec, types.Types[types.TBOOL]), sys.AMD64)\n+\t\taddF(simdPackage, \"Float32x4.IsNaN\", opLen1(ssa.OpIsNaNFloat32x4, types.TypeVec128), sys.AMD64)\n+\t\taddF(simdPackage, \"Float32x8.IsNaN\", opLen1(ssa.OpIsNaNFloat32x8, types.TypeVec256), sys.AMD64)\n+\t\taddF(simdPackage, \"Float32x16.IsNaN\", opLen1(ssa.OpIsNaNFloat32x16, types.TypeVec512), sys.AMD64)\n+\t\taddF(simdPackage, \"Float64x2.IsNaN\", opLen1(ssa.OpIsNaNFloat64x2, types.TypeVec128), sys.AMD64)\n+\t\taddF(simdPackage, \"Float64x4.IsNaN\", opLen1(ssa.OpIsNaNFloat64x4, types.TypeVec256), sys.AMD64)\n+\t\taddF(simdPackage, \"Float64x8.IsNaN\", opLen1(ssa.OpIsNaNFloat64x8, types.TypeVec512), sys.AMD64)\n \n \t\t// sfp4 is intrinsic-if-constant, but otherwise it's complicated enough to just implement in Go.\n \t\tsfp4 := func(method string, hwop ssa.Op, vectype *types.Type) {\ndiff --git a/src/cmd/compile/internal/ssagen/simdintrinsics.go b/src/cmd/compile/internal/ssagen/simdintrinsics.go\nindex 5a957612..4ad0c603 100644\n--- a/src/cmd/compile/internal/ssagen/simdintrinsics.go\n+++ b/src/cmd/compile/internal/ssagen/simdintrinsics.go\n@@ -571,12 +571,6 @@ func simdIntrinsics(addF func(pkg, fn string, b intrinsicBuilder, archFamilies .\n \taddF(simdPackage, \"Uint32x16.InterleaveLoGrouped\", opLen2(ssa.OpInterleaveLoGroupedUint32x16, types.TypeVec512), sys.AMD64)\n \taddF(simdPackage, \"Uint64x4.InterleaveLoGrouped\", opLen2(ssa.OpInterleaveLoGroupedUint64x4, types.TypeVec256), sys.AMD64)\n \taddF(simdPackage, \"Uint64x8.InterleaveLoGrouped\", opLen2(ssa.OpInterleaveLoGroupedUint64x8, types.TypeVec512), sys.AMD64)\n-\taddF(simdPackage, \"Float32x4.IsNan\", opLen2(ssa.OpIsNanFloat32x4, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Float32x8.IsNan\", opLen2(ssa.OpIsNanFloat32x8, types.TypeVec256), sys.AMD64)\n-\taddF(simdPackage, \"Float32x16.IsNan\", opLen2(ssa.OpIsNanFloat32x16, types.TypeVec512), sys.AMD64)\n-\taddF(simdPackage, \"Float64x2.IsNan\", opLen2(ssa.OpIsNanFloat64x2, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Float64x4.IsNan\", opLen2(ssa.OpIsNanFloat64x4, types.TypeVec256), sys.AMD64)\n-\taddF(simdPackage, \"Float64x8.IsNan\", opLen2(ssa.OpIsNanFloat64x8, types.TypeVec512), sys.AMD64)\n \taddF(simdPackage, \"Int32x4.LeadingZeros\", opLen1(ssa.OpLeadingZerosInt32x4, types.TypeVec128), sys.AMD64)\n \taddF(simdPackage, \"Int32x8.LeadingZeros\", opLen1(ssa.OpLeadingZerosInt32x8, types.TypeVec256), sys.AMD64)\n \taddF(simdPackage, \"Int32x16.LeadingZeros\", opLen1(ssa.OpLeadingZerosInt32x16, types.TypeVec512), sys.AMD64)\ndiff --git a/src/simd/archsimd/_gen/simdgen/ops/Compares/categories.yaml b/src/simd/archsimd/_gen/simdgen/ops/Compares/categories.yaml\nindex eb1d8161..97ee5875 100644\n--- a/src/simd/archsimd/_gen/simdgen/ops/Compares/categories.yaml\n+++ b/src/simd/archsimd/_gen/simdgen/ops/Compares/categories.yaml\n@@ -21,11 +21,6 @@\n   commutative: false\n   documentation: !string |-\n     // NAME returns a mask whose elements indicate whether x <= y.\n-- go: IsNan # For float only.\n-  constImm: 3\n-  commutative: true\n-  documentation: !string |-\n-    // NAME checks if elements are NaN. Use as x.IsNan(x).\n - go: NotEqual\n   constImm: 4\n   commutative: true\ndiff --git a/src/simd/archsimd/_gen/simdgen/ops/Compares/go.yaml b/src/simd/archsimd/_gen/simdgen/ops/Compares/go.yaml\nindex 3f6c8a45..6dbfb573 100644\n--- a/src/simd/archsimd/_gen/simdgen/ops/Compares/go.yaml\n+++ b/src/simd/archsimd/_gen/simdgen/ops/Compares/go.yaml\n@@ -121,7 +121,7 @@\n   - class: mask\n \n # Floats\n-- go: Equal|Greater|Less|LessEqual|GreaterEqual|NotEqual|IsNan\n+- go: (Equal|Greater|Less|LessEqual|GreaterEqual|NotEqual)\n   regexpTag: \"compares\"\n   asm: \"VCMPP[SD]\"\n   in:\n@@ -135,7 +135,7 @@\n   - go: $t\n     overwriteBase: int\n     overwriteClass: mask\n-- go: (Equal|Greater|Less|LessEqual|GreaterEqual|NotEqual|IsNan)\n+- go: (Equal|Greater|Less|LessEqual|GreaterEqual|NotEqual)\n   regexpTag: \"compares\"\n   asm: \"VCMPP[SD]\"\n   in:\ndiff --git a/src/simd/archsimd/extra_amd64.go b/src/simd/archsimd/extra_amd64.go\nindex cd5a3230..b0dba6d2 100644\n--- a/src/simd/archsimd/extra_amd64.go\n+++ b/src/simd/archsimd/extra_amd64.go\n@@ -143,3 +143,39 @@ func (x Uint64x2) IsZero() bool\n //\n // Asm: VPTEST, CPU Feature: AVX\n func (x Uint64x4) IsZero() bool\n+\n+// IsNaN returns a mask whose elements indicate whether the corresponding\n+// elements of x are NaN.\n+//\n+// Asm: VCMPPS, CPU Feature: AVX\n+func (x Float32x4) IsNaN() Mask32x4\n+\n+// IsNaN returns a mask whose elements indicate whether the corresponding\n+// elements of x are NaN.\n+//\n+// Asm: VCMPPS, CPU Feature: AVX\n+func (x Float32x8) IsNaN() Mask32x8\n+\n+// IsNaN returns a mask whose elements indicate whether the corresponding\n+// elements of x are NaN.\n+//\n+// Asm: VCMPPS, CPU Feature: AVX512\n+func (x Float32x16) IsNaN() Mask32x16\n+\n+// IsNaN returns a mask whose elements indicate whether the corresponding\n+// elements of x are NaN.\n+//\n+// Asm: VCMPPD, CPU Feature: AVX\n+func (x Float64x2) IsNaN() Mask64x2\n+\n+// IsNaN returns a mask whose elements indicate whether the corresponding\n+// elements of x are NaN.\n+//\n+// Asm: VCMPPD, CPU Feature: AVX\n+func (x Float64x4) IsNaN() Mask64x4\n+\n+// IsNaN returns a mask whose elements indicate whether the corresponding\n+// elements of x are NaN.\n+//\n+// Asm: VCMPPD, CPU Feature: AVX512\n+func (x Float64x8) IsNaN() Mask64x8\ndiff --git a/src/simd/archsimd/ops_amd64.go b/src/simd/archsimd/ops_amd64.go\nindex 95d417b3..eba340c7 100644\n--- a/src/simd/archsimd/ops_amd64.go\n+++ b/src/simd/archsimd/ops_amd64.go\n@@ -3446,38 +3446,6 @@ func (x Uint64x4) InterleaveLoGrouped(y Uint64x4) Uint64x4\n // Asm: VPUNPCKLQDQ, CPU Feature: AVX512\n func (x Uint64x8) InterleaveLoGrouped(y Uint64x8) Uint64x8\n \n-/* IsNan */\n-\n-// IsNan checks if elements are NaN. Use as x.IsNan(x).\n-//\n-// Asm: VCMPPS, CPU Feature: AVX\n-func (x Float32x4) IsNan(y Float32x4) Mask32x4\n-\n-// IsNan checks if elements are NaN. Use as x.IsNan(x).\n-//\n-// Asm: VCMPPS, CPU Feature: AVX\n-func (x Float32x8) IsNan(y Float32x8) Mask32x8\n-\n-// IsNan checks if elements are NaN. Use as x.IsNan(x).\n-//\n-// Asm: VCMPPS, CPU Feature: AVX512\n-func (x Float32x16) IsNan(y Float32x16) Mask32x16\n-\n-// IsNan checks if elements are NaN. Use as x.IsNan(x).\n-//\n-// Asm: VCMPPD, CPU Feature: AVX\n-func (x Float64x2) IsNan(y Float64x2) Mask64x2\n-\n-// IsNan checks if elements are NaN. Use as x.IsNan(x).\n-//\n-// Asm: VCMPPD, CPU Feature: AVX\n-func (x Float64x4) IsNan(y Float64x4) Mask64x4\n-\n-// IsNan checks if elements are NaN. Use as x.IsNan(x).\n-//\n-// Asm: VCMPPD, CPU Feature: AVX512\n-func (x Float64x8) IsNan(y Float64x8) Mask64x8\n-\n /* LeadingZeros */\n \n // LeadingZeros counts the leading zeros of each element in x.","output":"refactor(simd): change IsNaN from binary to unary operation","metadata":{"id":"go-13440fb5","repository":"go","commit_hash":"13440fb51831bfde5804430596d2045a64fd2209"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/simd/archsimd/_gen/simdgen/gen_simdTypes.go |  4 ++++\n src/simd/archsimd/types_amd64.go                | 24 ++++++++++++------------\n 2 files changed, 16 insertions(+), 12 deletions(-)\n\ndiff --git a/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go b/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go\nindex 453784ff..d8c44812 100644\n--- a/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go\n+++ b/src/simd/archsimd/_gen/simdgen/gen_simdTypes.go\n@@ -142,7 +142,11 @@ type v{{.}} struct {\n {{end}}\n \n {{define \"typeTmpl\"}}\n+{{- if eq .Type \"mask\"}}\n+// {{.Name}} is a mask for a SIMD vector of {{.Lanes}} {{.ElemBits}}-bit elements.\n+{{- else}}\n // {{.Name}} is a {{.Size}}-bit SIMD vector of {{.Lanes}} {{.Base}}s.\n+{{- end}}\n type {{.Name}} struct {\n {{.Fields}}\n }\ndiff --git a/src/simd/archsimd/types_amd64.go b/src/simd/archsimd/types_amd64.go\nindex 2efa1363..f39549c7 100644\n--- a/src/simd/archsimd/types_amd64.go\n+++ b/src/simd/archsimd/types_amd64.go\n@@ -295,7 +295,7 @@ func LoadMaskedUint64x2(y *[2]uint64, mask Mask64x2) Uint64x2\n //go:noescape\n func (x Uint64x2) StoreMasked(y *[2]uint64, mask Mask64x2)\n \n-// Mask8x16 is a 128-bit SIMD vector of 16 int8s.\n+// Mask8x16 is a mask for a SIMD vector of 16 8-bit elements.\n type Mask8x16 struct {\n \tint8x16 v128\n \tvals    [16]int8\n@@ -311,7 +311,7 @@ func Mask8x16FromBits(y uint16) Mask8x16\n // Asm: KMOVB, CPU Features: AVX512\n func (x Mask8x16) ToBits() uint16\n \n-// Mask16x8 is a 128-bit SIMD vector of 8 int16s.\n+// Mask16x8 is a mask for a SIMD vector of 8 16-bit elements.\n type Mask16x8 struct {\n \tint16x8 v128\n \tvals    [8]int16\n@@ -327,7 +327,7 @@ func Mask16x8FromBits(y uint8) Mask16x8\n // Asm: KMOVW, CPU Features: AVX512\n func (x Mask16x8) ToBits() uint8\n \n-// Mask32x4 is a 128-bit SIMD vector of 4 int32s.\n+// Mask32x4 is a mask for a SIMD vector of 4 32-bit elements.\n type Mask32x4 struct {\n \tint32x4 v128\n \tvals    [4]int32\n@@ -345,7 +345,7 @@ func Mask32x4FromBits(y uint8) Mask32x4\n // Asm: KMOVD, CPU Features: AVX512\n func (x Mask32x4) ToBits() uint8\n \n-// Mask64x2 is a 128-bit SIMD vector of 2 int64s.\n+// Mask64x2 is a mask for a SIMD vector of 2 64-bit elements.\n type Mask64x2 struct {\n \tint64x2 v128\n \tvals    [2]int64\n@@ -654,7 +654,7 @@ func LoadMaskedUint64x4(y *[4]uint64, mask Mask64x4) Uint64x4\n //go:noescape\n func (x Uint64x4) StoreMasked(y *[4]uint64, mask Mask64x4)\n \n-// Mask8x32 is a 256-bit SIMD vector of 32 int8s.\n+// Mask8x32 is a mask for a SIMD vector of 32 8-bit elements.\n type Mask8x32 struct {\n \tint8x32 v256\n \tvals    [32]int8\n@@ -670,7 +670,7 @@ func Mask8x32FromBits(y uint32) Mask8x32\n // Asm: KMOVB, CPU Features: AVX512\n func (x Mask8x32) ToBits() uint32\n \n-// Mask16x16 is a 256-bit SIMD vector of 16 int16s.\n+// Mask16x16 is a mask for a SIMD vector of 16 16-bit elements.\n type Mask16x16 struct {\n \tint16x16 v256\n \tvals     [16]int16\n@@ -686,7 +686,7 @@ func Mask16x16FromBits(y uint16) Mask16x16\n // Asm: KMOVW, CPU Features: AVX512\n func (x Mask16x16) ToBits() uint16\n \n-// Mask32x8 is a 256-bit SIMD vector of 8 int32s.\n+// Mask32x8 is a mask for a SIMD vector of 8 32-bit elements.\n type Mask32x8 struct {\n \tint32x8 v256\n \tvals    [8]int32\n@@ -702,7 +702,7 @@ func Mask32x8FromBits(y uint8) Mask32x8\n // Asm: KMOVD, CPU Features: AVX512\n func (x Mask32x8) ToBits() uint8\n \n-// Mask64x4 is a 256-bit SIMD vector of 4 int64s.\n+// Mask64x4 is a mask for a SIMD vector of 4 64-bit elements.\n type Mask64x4 struct {\n \tint64x4 v256\n \tvals    [4]int64\n@@ -1075,7 +1075,7 @@ func LoadMaskedUint64x8(y *[8]uint64, mask Mask64x8) Uint64x8\n //go:noescape\n func (x Uint64x8) StoreMasked(y *[8]uint64, mask Mask64x8)\n \n-// Mask8x64 is a 512-bit SIMD vector of 64 int8s.\n+// Mask8x64 is a mask for a SIMD vector of 64 8-bit elements.\n type Mask8x64 struct {\n \tint8x64 v512\n \tvals    [64]int8\n@@ -1091,7 +1091,7 @@ func Mask8x64FromBits(y uint64) Mask8x64\n // Asm: KMOVB, CPU Features: AVX512\n func (x Mask8x64) ToBits() uint64\n \n-// Mask16x32 is a 512-bit SIMD vector of 32 int16s.\n+// Mask16x32 is a mask for a SIMD vector of 32 16-bit elements.\n type Mask16x32 struct {\n \tint16x32 v512\n \tvals     [32]int16\n@@ -1107,7 +1107,7 @@ func Mask16x32FromBits(y uint32) Mask16x32\n // Asm: KMOVW, CPU Features: AVX512\n func (x Mask16x32) ToBits() uint32\n \n-// Mask32x16 is a 512-bit SIMD vector of 16 int32s.\n+// Mask32x16 is a mask for a SIMD vector of 16 32-bit elements.\n type Mask32x16 struct {\n \tint32x16 v512\n \tvals     [16]int32\n@@ -1123,7 +1123,7 @@ func Mask32x16FromBits(y uint16) Mask32x16\n // Asm: KMOVD, CPU Features: AVX512\n func (x Mask32x16) ToBits() uint16\n \n-// Mask64x8 is a 512-bit SIMD vector of 8 int64s.\n+// Mask64x8 is a mask for a SIMD vector of 8 64-bit elements.\n type Mask64x8 struct {\n \tint64x8 v512\n \tvals    [8]int64","output":"docs(simd): fix mask type comments to describe masks not vectors","metadata":{"id":"go-c3550b33","repository":"go","commit_hash":"c3550b3352ae283110c443576e1e62cdf8efaa72"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/net/rpc/server.go | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/net/rpc/server.go b/src/net/rpc/server.go\nindex 4233a426..961145c6 100644\n--- a/src/net/rpc/server.go\n+++ b/src/net/rpc/server.go\n@@ -202,7 +202,7 @@ func NewServer() *Server {\n // DefaultServer is the default instance of [*Server].\n var DefaultServer = NewServer()\n \n-// Is this type exported or a builtin?\n+// isExportedOrBuiltinType reports whether t is an exported or builtin type\n func isExportedOrBuiltinType(t reflect.Type) bool {\n \tfor t.Kind() == reflect.Pointer {\n \t\tt = t.Elem()","output":"docs: improve isExportedOrBuiltinType comment","metadata":{"id":"go-34ad2634","repository":"go","commit_hash":"34ad26341d454876964445d7c6dd8f8378efb8c3"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/go/internal/modindex/scan.go                 |  6 +++---\n src/cmd/go/testdata/script/list_empty_importpath.txt | 11 +----------\n 2 files changed, 4 insertions(+), 13 deletions(-)\n\ndiff --git a/src/cmd/go/internal/modindex/scan.go b/src/cmd/go/internal/modindex/scan.go\nindex af2c0abe..beded695 100644\n--- a/src/cmd/go/internal/modindex/scan.go\n+++ b/src/cmd/go/internal/modindex/scan.go\n@@ -112,10 +112,10 @@ func parseErrorToString(err error) string {\n \t\treturn \"\"\n \t}\n \tvar p parseError\n-\tif e, ok := err.(scanner.ErrorList); ok {\n-\t\tp.ErrorList = &e\n+\tif errlist, ok := err.(scanner.ErrorList); ok {\n+\t\tp.ErrorList = &errlist\n \t} else {\n-\t\tp.ErrorString = e.Error()\n+\t\tp.ErrorString = err.Error()\n \t}\n \ts, err := json.Marshal(p)\n \tif err != nil {\ndiff --git a/src/cmd/go/testdata/script/list_empty_importpath.txt b/src/cmd/go/testdata/script/list_empty_importpath.txt\nindex fe421032..0960a779 100644\n--- a/src/cmd/go/testdata/script/list_empty_importpath.txt\n+++ b/src/cmd/go/testdata/script/list_empty_importpath.txt\n@@ -1,15 +1,6 @@\n ! go list all\n ! stderr 'panic'\n-[!GOOS:windows] [!GOOS:solaris] [!GOOS:freebsd] [!GOOS:openbsd] [!GOOS:netbsd] stderr 'invalid import path'\n-# #73976: Allow 'no errors' on Windows, Solaris, and BSD until issue\n-# is resolved to prevent flakes. 'no errors' is printed by\n-# empty scanner.ErrorList errors so that's probably where the\n-# message is coming from, though we don't know how.\n-[GOOS:windows] stderr 'invalid import path|no errors'\n-[GOOS:solaris] stderr 'invalid import path|no errors'\n-[GOOS:freebsd] stderr 'invalid import path|no errors'\n-[GOOS:openbsd] stderr 'invalid import path|no errors'\n-[GOOS:netbsd] stderr 'invalid import path|no errors'\n+stderr 'invalid import path'\n \n # go list produces a package for 'p' but not for ''\n go list -e all","output":"fix(modindex): fix variable shadowing in parseErrorToString","metadata":{"id":"go-b28808d8","repository":"go","commit_hash":"b28808d838682b2911698fcb934813b02f39fa69"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/runtime/secret/secret_test.go | 38 +++++++++++++++++++++++++++++---------\n 1 file changed, 29 insertions(+), 9 deletions(-)\n\ndiff --git a/src/runtime/secret/secret_test.go b/src/runtime/secret/secret_test.go\nindex 98d67cf8..e2f78c53 100644\n--- a/src/runtime/secret/secret_test.go\n+++ b/src/runtime/secret/secret_test.go\n@@ -19,6 +19,7 @@ import (\n \t\"testing\"\n \t\"time\"\n \t\"unsafe\"\n+\t\"weak\"\n )\n \n type secretType int64\n@@ -63,28 +64,33 @@ func heapSTiny() *secretType {\n // are freed.\n // See runtime/mheap.go:freeSpecial.\n func TestHeap(t *testing.T) {\n-\tvar u uintptr\n+\tvar addr uintptr\n+\tvar p weak.Pointer[S]\n \tDo(func() {\n-\t\tu = uintptr(unsafe.Pointer(heapS()))\n+\t\tsp := heapS()\n+\t\taddr = uintptr(unsafe.Pointer(sp))\n+\t\tp = weak.Make(sp)\n \t})\n-\n-\truntime.GC()\n+\twaitCollected(t, p)\n \n \t// Check that object got zeroed.\n-\tcheckRangeForSecret(t, u, u+unsafe.Sizeof(S{}))\n+\tcheckRangeForSecret(t, addr, addr+unsafe.Sizeof(S{}))\n \t// Also check our stack, just because we can.\n \tcheckStackForSecret(t)\n }\n \n func TestHeapTiny(t *testing.T) {\n-\tvar u uintptr\n+\tvar addr uintptr\n+\tvar p weak.Pointer[secretType]\n \tDo(func() {\n-\t\tu = uintptr(unsafe.Pointer(heapSTiny()))\n+\t\tsp := heapSTiny()\n+\t\taddr = uintptr(unsafe.Pointer(sp))\n+\t\tp = weak.Make(sp)\n \t})\n-\truntime.GC()\n+\twaitCollected(t, p)\n \n \t// Check that object got zeroed.\n-\tcheckRangeForSecret(t, u, u+unsafe.Sizeof(secretType(0)))\n+\tcheckRangeForSecret(t, addr, addr+unsafe.Sizeof(secretType(0)))\n \t// Also check our stack, just because we can.\n \tcheckStackForSecret(t)\n }\n@@ -240,6 +246,20 @@ func checkRangeForSecret(t *testing.T, lo, hi uintptr) {\n \t}\n }\n \n+func waitCollected[P any](t *testing.T, ptr weak.Pointer[P]) {\n+\tt.Helper()\n+\ti := 0\n+\tfor ptr.Value() != nil {\n+\t\truntime.GC()\n+\t\ti++\n+\t\t// 20 seems like a decent number of times to try\n+\t\tif i > 20 {\n+\t\t\tt.Errorf(\"value was never collected\")\n+\t\t}\n+\t}\n+\tt.Logf(\"number of cycles until collection: %d\", i)\n+}\n+\n func TestRegisters(t *testing.T) {\n \tDo(func() {\n \t\ts := makeS()","output":"test(secret): use weak pointers to verify object collection","metadata":{"id":"go-1843cfbc","repository":"go","commit_hash":"1843cfbcd6bd0e1f7650c663c6c4608bc1cd8829"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/archive/tar/reader_test.go | 2 +-\n src/archive/tar/stat_unix.go   | 2 +-\n src/archive/tar/strconv.go     | 2 +-\n src/runtime/trace.go           | 4 ++--\n src/runtime/tracebuf.go        | 2 +-\n test/typeparam/typelist.go     | 2 +-\n 6 files changed, 7 insertions(+), 7 deletions(-)\n\ndiff --git a/src/archive/tar/reader_test.go b/src/archive/tar/reader_test.go\nindex de3d3653..c7611ca0 100644\n--- a/src/archive/tar/reader_test.go\n+++ b/src/archive/tar/reader_test.go\n@@ -787,7 +787,7 @@ type readBadSeeker struct{ io.ReadSeeker }\n \n func (rbs *readBadSeeker) Seek(int64, int) (int64, error) { return 0, fmt.Errorf(\"illegal seek\") }\n \n-// TestReadTruncation test the ending condition on various truncated files and\n+// TestReadTruncation tests the ending condition on various truncated files and\n // that truncated files are still detected even if the underlying io.Reader\n // satisfies io.Seeker.\n func TestReadTruncation(t *testing.T) {\ndiff --git a/src/archive/tar/stat_unix.go b/src/archive/tar/stat_unix.go\nindex f999f56d..891a1a3b 100644\n--- a/src/archive/tar/stat_unix.go\n+++ b/src/archive/tar/stat_unix.go\n@@ -19,7 +19,7 @@ func init() {\n \tsysStat = statUnix\n }\n \n-// userMap and groupMap caches UID and GID lookups for performance reasons.\n+// userMap and groupMap cache UID and GID lookups for performance reasons.\n // The downside is that renaming uname or gname by the OS never takes effect.\n var userMap, groupMap sync.Map // map[int]string\n \ndiff --git a/src/archive/tar/strconv.go b/src/archive/tar/strconv.go\nindex 217efe9e..d3c28a8c 100644\n--- a/src/archive/tar/strconv.go\n+++ b/src/archive/tar/strconv.go\n@@ -312,7 +312,7 @@ func formatPAXRecord(k, v string) (string, error) {\n //\t\"%d %s=%s\\n\" % (size, key, value)\n //\n // Keys and values should be UTF-8, but the number of bad writers out there\n-// forces us to be a more liberal.\n+// forces us to be more liberal.\n // Thus, we only reject all keys with NUL, and only reject NULs in values\n // for the PAX version of the USTAR string fields.\n // The key must not contain an '=' character.\ndiff --git a/src/runtime/trace.go b/src/runtime/trace.go\nindex a7e8937a..5f568d20 100644\n--- a/src/runtime/trace.go\n+++ b/src/runtime/trace.go\n@@ -12,7 +12,7 @@\n //\n // ## Design\n //\n-// The basic idea behind the the execution tracer is to have per-M buffers that\n+// The basic idea behind the execution tracer is to have per-M buffers that\n // trace data may be written into. Each M maintains a write flag indicating whether\n // its trace buffer is currently in use.\n //\n@@ -173,7 +173,7 @@\n // doesn't do this directly for performance reasons. The runtime implementation instead caches\n // a G on the M created for the C thread. On Linux this M is then cached in the thread's TLS,\n // and on other systems, the M is put on a global list on exit from Go. We need to do some\n-// extra work to make sure that this is modeled correctly in the the tracer. For example,\n+// extra work to make sure that this is modeled correctly in the tracer. For example,\n // a C thread exiting Go may leave a P hanging off of its M (whether that M is kept in TLS\n // or placed back on a list). In order to correctly model goroutine creation and destruction,\n // we must behave as if the P was at some point stolen by the runtime, if the C thread\ndiff --git a/src/runtime/tracebuf.go b/src/runtime/tracebuf.go\nindex 5adaede4..1caf69f8 100644\n--- a/src/runtime/tracebuf.go\n+++ b/src/runtime/tracebuf.go\n@@ -29,7 +29,7 @@ type traceWriter struct {\n \t*traceBuf\n }\n \n-// writer returns an a traceWriter that writes into the current M's stream.\n+// writer returns a traceWriter that writes into the current M's stream.\n //\n // Once this is called, the caller must guard against stack growth until\n // end is called on it. Therefore, it's highly recommended to use this\ndiff --git a/test/typeparam/typelist.go b/test/typeparam/typelist.go\nindex cd8ef7d6..b3226301 100644\n--- a/test/typeparam/typelist.go\n+++ b/test/typeparam/typelist.go\n@@ -32,7 +32,7 @@ func _[T interface{ ~int }](x T) {\n \tvar _ T = T(myint(42))\n }\n \n-// Indexing a generic type which has a an array as core type.\n+// Indexing a generic type which has an array as core type.\n func _[T interface{ ~[10]int }](x T) {\n \t_ = x[9] // ok\n }","output":"docs: fix typos in comments","metadata":{"id":"go-fd45d707","repository":"go","commit_hash":"fd45d70799853ef5980a559e206353574108d8da"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" test/codegen/comparisons.go | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/test/codegen/comparisons.go b/test/codegen/comparisons.go\nindex bcce21e4..0b550adc 100644\n--- a/test/codegen/comparisons.go\n+++ b/test/codegen/comparisons.go\n@@ -660,13 +660,13 @@ func equalVarString8(a string) bool {\n \treturn a[:8] == b\n }\n \n-func equalVarStringNoSpill(a,b string) bool {\n+func equalVarStringNoSpill(a, b string) bool {\n \ts := string(\"ZZZZZZZZZ\")\n \t// arm64:\".*memequal\"\n \tmemeq1 := a[:9] == s\n \t// arm64:-\".*\"\n \tmemeq2 := s == a[:9]\n-\t// arm64:-\"MOVB\\tR0,.*SP\",\".*memequal\"\n+\t// arm64:-\"MOVB R0,.*SP\",\".*memequal\"\n \tmemeq3 := s == b[:9]\n \treturn memeq1 && memeq2 && memeq3\n }","output":"test: fix formatting in codegen comparisons","metadata":{"id":"go-df4e08ac","repository":"go","commit_hash":"df4e08ac65e94041367785783ec1482e8bed2397"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/compile/internal/inline/inl.go         |  3 ++\n src/cmd/compile/testdata/script/issue77033.txt | 40 ++++++++++++++++++++++++++\n 2 files changed, 43 insertions(+)\n\ndiff --git a/src/cmd/compile/internal/inline/inl.go b/src/cmd/compile/internal/inline/inl.go\nindex 33f9c325..4fa9cf07 100644\n--- a/src/cmd/compile/internal/inline/inl.go\n+++ b/src/cmd/compile/internal/inline/inl.go\n@@ -516,6 +516,9 @@ opSwitch:\n \t\t\t\t\t\tbreak opSwitch\n \t\t\t\t\tcase \"panicrangestate\":\n \t\t\t\t\t\tcheap = true\n+\t\t\t\t\tcase \"deferrangefunc\":\n+\t\t\t\t\t\tv.reason = \"defer call in range func\"\n+\t\t\t\t\t\treturn true\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\ndiff --git a/src/cmd/compile/testdata/script/issue77033.txt b/src/cmd/compile/testdata/script/issue77033.txt\nnew file mode 100644\nindex 00000000..3b977e54\n--- /dev/null\n+++ b/src/cmd/compile/testdata/script/issue77033.txt\n@@ -0,0 +1,40 @@\n+go test -bench=Foo -cpuprofile=default.pgo\n+go test -bench=Foo -pgo=default.pgo\n+! stdout 'FAIL'\n+\n+-- main_test.go --\n+package main\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var a int\n+\n+func save(x int) {\n+\ta = x\n+}\n+\n+func foo() {\n+\tfor i := range yield1 {\n+\t\tdefer save(i)\n+\t}\n+}\n+\n+func yield1(yield func(int) bool) {\n+\tyield(1)\n+}\n+\n+func BenchmarkFoo(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfoo()\n+\t}\n+\tif a != 1 {\n+\t\tb.Fatalf(\"a = %d; want 1\", a)\n+\t}\n+}\n+\n+-- go.mod --\n+module demo\n+\n+go 1.24","output":"fix(compile): prevent inlining defer in range func","metadata":{"id":"go-cd668d74","repository":"go","commit_hash":"cd668d744f77da06ca9565f41c63c3a5251469ee"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/simd/archsimd/internal/simd_test/simd_test.go | 77 +++++++++++++++++++++++\n 1 file changed, 77 insertions(+)\n\ndiff --git a/src/simd/archsimd/internal/simd_test/simd_test.go b/src/simd/archsimd/internal/simd_test/simd_test.go\nindex 76b296c9..671ec05e 100644\n--- a/src/simd/archsimd/internal/simd_test/simd_test.go\n+++ b/src/simd/archsimd/internal/simd_test/simd_test.go\n@@ -1296,3 +1296,80 @@ func TestAddSubPairs(t *testing.T) {\n \t\ttestFloat64x4Binary(t, archsimd.Float64x4.SubPairsGrouped, subPairsGroupedSlice[float64])\n \t}\n }\n+\n+func convConcatSlice[T, U number](a, b []T, conv func(T) U) []U {\n+\tr := make([]U, len(a)+len(b))\n+\tfor i, v := range a {\n+\t\tr[i] = conv(v)\n+\t}\n+\tfor i, v := range b {\n+\t\tr[len(a)+i] = conv(v)\n+\t}\n+\treturn r\n+}\n+\n+func convConcatGroupedSlice[T, U number](a, b []T, conv func(T) U) []U {\n+\tgroup := int(128 / unsafe.Sizeof(a[0]))\n+\tr := make([]U, 0, len(a)+len(b))\n+\tfor i := 0; i < len(a)/group; i++ {\n+\t\tr = append(r, convConcatSlice(a[i*group:(i+1)*group], b[i*group:(i+1)*group], conv)...)\n+\t}\n+\treturn r\n+}\n+\n+func TestSaturateConcat(t *testing.T) {\n+\t// Int32x4.SaturateToInt16Concat\n+\tforSlicePair(t, int32s, 4, func(x, y []int32) bool {\n+\t\ta, b := archsimd.LoadInt32x4Slice(x), archsimd.LoadInt32x4Slice(y)\n+\t\tvar out [8]int16\n+\t\ta.SaturateToInt16Concat(b).Store(&out)\n+\t\twant := convConcatSlice(x, y, satToInt16)\n+\t\treturn checkSlicesLogInput(t, out[:], want, 0, func() { t.Logf(\"x=%v, y=%v\", x, y) })\n+\t})\n+\t// Int32x4.SaturateToUint16Concat\n+\tforSlicePair(t, int32s, 4, func(x, y []int32) bool {\n+\t\ta, b := archsimd.LoadInt32x4Slice(x), archsimd.LoadInt32x4Slice(y)\n+\t\tvar out [8]uint16\n+\t\ta.SaturateToUint16Concat(b).Store(&out)\n+\t\twant := convConcatSlice(x, y, satToUint16)\n+\t\treturn checkSlicesLogInput(t, out[:], want, 0, func() { t.Logf(\"x=%v, y=%v\", x, y) })\n+\t})\n+\n+\tif archsimd.X86.AVX2() {\n+\t\t// Int32x8.SaturateToInt16ConcatGrouped\n+\t\tforSlicePair(t, int32s, 8, func(x, y []int32) bool {\n+\t\t\ta, b := archsimd.LoadInt32x8Slice(x), archsimd.LoadInt32x8Slice(y)\n+\t\t\tvar out [16]int16\n+\t\t\ta.SaturateToInt16ConcatGrouped(b).Store(&out)\n+\t\t\twant := convConcatGroupedSlice(x, y, satToInt16)\n+\t\t\treturn checkSlicesLogInput(t, out[:], want, 0, func() { t.Logf(\"x=%v, y=%v\", x, y) })\n+\t\t})\n+\t\t// Int32x8.SaturateToUint16ConcatGrouped\n+\t\tforSlicePair(t, int32s, 8, func(x, y []int32) bool {\n+\t\t\ta, b := archsimd.LoadInt32x8Slice(x), archsimd.LoadInt32x8Slice(y)\n+\t\t\tvar out [16]uint16\n+\t\t\ta.SaturateToUint16ConcatGrouped(b).Store(&out)\n+\t\t\twant := convConcatGroupedSlice(x, y, satToUint16)\n+\t\t\treturn checkSlicesLogInput(t, out[:], want, 0, func() { t.Logf(\"x=%v, y=%v\", x, y) })\n+\t\t})\n+\t}\n+\n+\tif archsimd.X86.AVX512() {\n+\t\t// Int32x16.SaturateToInt16ConcatGrouped\n+\t\tforSlicePair(t, int32s, 16, func(x, y []int32) bool {\n+\t\t\ta, b := archsimd.LoadInt32x16Slice(x), archsimd.LoadInt32x16Slice(y)\n+\t\t\tvar out [32]int16\n+\t\t\ta.SaturateToInt16ConcatGrouped(b).Store(&out)\n+\t\t\twant := convConcatGroupedSlice(x, y, satToInt16)\n+\t\t\treturn checkSlicesLogInput(t, out[:], want, 0, func() { t.Logf(\"x=%v, y=%v\", x, y) })\n+\t\t})\n+\t\t// Int32x16.SaturateToUint16ConcatGrouped\n+\t\tforSlicePair(t, int32s, 16, func(x, y []int32) bool {\n+\t\t\ta, b := archsimd.LoadInt32x16Slice(x), archsimd.LoadInt32x16Slice(y)\n+\t\t\tvar out [32]uint16\n+\t\t\ta.SaturateToUint16ConcatGrouped(b).Store(&out)\n+\t\t\twant := convConcatGroupedSlice(x, y, satToUint16)\n+\t\t\treturn checkSlicesLogInput(t, out[:], want, 0, func() { t.Logf(\"x=%v, y=%v\", x, y) })\n+\t\t})\n+\t}\n+}","output":"test(simd): add saturate concat tests","metadata":{"id":"go-06eff0f7","repository":"go","commit_hash":"06eff0f7c3027a78088d45efdaec8ac3ed636481"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" .../internal/simd_test/simulation_helpers_test.go  | 87 ++++++++++++++++++++++\n src/simd/archsimd/internal/simd_test/unary_test.go | 42 +++++++++++\n 2 files changed, 129 insertions(+)\n\ndiff --git a/src/simd/archsimd/internal/simd_test/simulation_helpers_test.go b/src/simd/archsimd/internal/simd_test/simulation_helpers_test.go\nindex a51912a4..da107d80 100644\n--- a/src/simd/archsimd/internal/simd_test/simulation_helpers_test.go\n+++ b/src/simd/archsimd/internal/simd_test/simulation_helpers_test.go\n@@ -330,3 +330,90 @@ func imaSlice[T integer](x, y, z []T) []T {\n func fmaSlice[T float](x, y, z []T) []T {\n \treturn map3[T](fma)(x, y, z)\n }\n+\n+func satToInt8[T integer](x T) int8 {\n+\tvar m int8 = -128\n+\tvar M int8 = 127\n+\tif T(M) < T(m) { // expecting T being a larger type\n+\t\tpanic(\"bad input type\")\n+\t}\n+\tif x < T(m) {\n+\t\treturn m\n+\t}\n+\tif x > T(M) {\n+\t\treturn M\n+\t}\n+\treturn int8(x)\n+}\n+\n+func satToUint8[T integer](x T) uint8 {\n+\tvar M uint8 = 255\n+\tif T(M) < 0 { // expecting T being a larger type\n+\t\tpanic(\"bad input type\")\n+\t}\n+\tif x < 0 {\n+\t\treturn 0\n+\t}\n+\tif x > T(M) {\n+\t\treturn M\n+\t}\n+\treturn uint8(x)\n+}\n+\n+func satToInt16[T integer](x T) int16 {\n+\tvar m int16 = -32768\n+\tvar M int16 = 32767\n+\tif T(M) < T(m) { // expecting T being a larger type\n+\t\tpanic(\"bad input type\")\n+\t}\n+\tif x < T(m) {\n+\t\treturn m\n+\t}\n+\tif x > T(M) {\n+\t\treturn M\n+\t}\n+\treturn int16(x)\n+}\n+\n+func satToUint16[T integer](x T) uint16 {\n+\tvar M uint16 = 65535\n+\tif T(M) < 0 { // expecting T being a larger type\n+\t\tpanic(\"bad input type\")\n+\t}\n+\tif x < 0 {\n+\t\treturn 0\n+\t}\n+\tif x > T(M) {\n+\t\treturn M\n+\t}\n+\treturn uint16(x)\n+}\n+\n+func satToInt32[T integer](x T) int32 {\n+\tvar m int32 = -1 << 31\n+\tvar M int32 = 1<<31 - 1\n+\tif T(M) < T(m) { // expecting T being a larger type\n+\t\tpanic(\"bad input type\")\n+\t}\n+\tif x < T(m) {\n+\t\treturn m\n+\t}\n+\tif x > T(M) {\n+\t\treturn M\n+\t}\n+\treturn int32(x)\n+}\n+\n+func satToUint32[T integer](x T) uint32 {\n+\tvar M uint32 = 1<<32 - 1\n+\tif T(M) < 0 { // expecting T being a larger type\n+\t\tpanic(\"bad input type\")\n+\t}\n+\tif x < 0 {\n+\t\treturn 0\n+\t}\n+\tif x > T(M) {\n+\t\treturn M\n+\t}\n+\treturn uint32(x)\n+}\ndiff --git a/src/simd/archsimd/internal/simd_test/unary_test.go b/src/simd/archsimd/internal/simd_test/unary_test.go\nindex 5d00eba0..097feb60 100644\n--- a/src/simd/archsimd/internal/simd_test/unary_test.go\n+++ b/src/simd/archsimd/internal/simd_test/unary_test.go\n@@ -270,3 +270,45 @@ func TestTruncate(t *testing.T) {\n \t\ttestUint64x8ConvertToUint32(t, archsimd.Uint64x8.TruncateToUint32, map1[uint64](toUint32))\n \t}\n }\n+\n+func TestSaturate(t *testing.T) {\n+\tif archsimd.X86.AVX512() {\n+\t\ttestInt16x8ConvertToInt8(t, archsimd.Int16x8.SaturateToInt8, map1n[int16](satToInt8, 16))\n+\t\ttestInt16x16ConvertToInt8(t, archsimd.Int16x16.SaturateToInt8, map1[int16](satToInt8))\n+\t\ttestInt16x32ConvertToInt8(t, archsimd.Int16x32.SaturateToInt8, map1[int16](satToInt8))\n+\t\ttestInt32x4ConvertToInt8(t, archsimd.Int32x4.SaturateToInt8, map1n[int32](satToInt8, 16))\n+\t\ttestInt32x8ConvertToInt8(t, archsimd.Int32x8.SaturateToInt8, map1n[int32](satToInt8, 16))\n+\t\ttestInt32x16ConvertToInt8(t, archsimd.Int32x16.SaturateToInt8, map1[int32](satToInt8))\n+\t\ttestInt64x2ConvertToInt8(t, archsimd.Int64x2.SaturateToInt8, map1n[int64](satToInt8, 16))\n+\t\ttestInt64x4ConvertToInt8(t, archsimd.Int64x4.SaturateToInt8, map1n[int64](satToInt8, 16))\n+\t\ttestInt64x8ConvertToInt8(t, archsimd.Int64x8.SaturateToInt8, map1n[int64](satToInt8, 16))\n+\t\ttestInt32x4ConvertToInt16(t, archsimd.Int32x4.SaturateToInt16, map1n[int32](satToInt16, 8))\n+\t\ttestInt32x8ConvertToInt16(t, archsimd.Int32x8.SaturateToInt16, map1[int32](satToInt16))\n+\t\ttestInt32x16ConvertToInt16(t, archsimd.Int32x16.SaturateToInt16, map1[int32](satToInt16))\n+\t\ttestInt64x2ConvertToInt16(t, archsimd.Int64x2.SaturateToInt16, map1n[int64](satToInt16, 8))\n+\t\ttestInt64x4ConvertToInt16(t, archsimd.Int64x4.SaturateToInt16, map1n[int64](satToInt16, 8))\n+\t\ttestInt64x8ConvertToInt16(t, archsimd.Int64x8.SaturateToInt16, map1[int64](satToInt16))\n+\t\ttestInt64x2ConvertToInt32(t, archsimd.Int64x2.SaturateToInt32, map1n[int64](satToInt32, 4))\n+\t\ttestInt64x4ConvertToInt32(t, archsimd.Int64x4.SaturateToInt32, map1[int64](satToInt32))\n+\t\ttestInt64x8ConvertToInt32(t, archsimd.Int64x8.SaturateToInt32, map1[int64](satToInt32))\n+\n+\t\ttestUint16x8ConvertToUint8(t, archsimd.Uint16x8.SaturateToUint8, map1n[uint16](satToUint8, 16))\n+\t\ttestUint16x16ConvertToUint8(t, archsimd.Uint16x16.SaturateToUint8, map1[uint16](satToUint8))\n+\t\ttestUint16x32ConvertToUint8(t, archsimd.Uint16x32.SaturateToUint8, map1[uint16](satToUint8))\n+\t\ttestUint32x4ConvertToUint8(t, archsimd.Uint32x4.SaturateToUint8, map1n[uint32](satToUint8, 16))\n+\t\ttestUint32x8ConvertToUint8(t, archsimd.Uint32x8.SaturateToUint8, map1n[uint32](satToUint8, 16))\n+\t\ttestUint32x16ConvertToUint8(t, archsimd.Uint32x16.SaturateToUint8, map1[uint32](satToUint8))\n+\t\ttestUint64x2ConvertToUint8(t, archsimd.Uint64x2.SaturateToUint8, map1n[uint64](satToUint8, 16))\n+\t\ttestUint64x4ConvertToUint8(t, archsimd.Uint64x4.SaturateToUint8, map1n[uint64](satToUint8, 16))\n+\t\ttestUint64x8ConvertToUint8(t, archsimd.Uint64x8.SaturateToUint8, map1n[uint64](satToUint8, 16))\n+\t\ttestUint32x4ConvertToUint16(t, archsimd.Uint32x4.SaturateToUint16, map1n[uint32](satToUint16, 8))\n+\t\ttestUint32x8ConvertToUint16(t, archsimd.Uint32x8.SaturateToUint16, map1[uint32](satToUint16))\n+\t\ttestUint32x16ConvertToUint16(t, archsimd.Uint32x16.SaturateToUint16, map1[uint32](satToUint16))\n+\t\ttestUint64x2ConvertToUint16(t, archsimd.Uint64x2.SaturateToUint16, map1n[uint64](satToUint16, 8))\n+\t\ttestUint64x4ConvertToUint16(t, archsimd.Uint64x4.SaturateToUint16, map1n[uint64](satToUint16, 8))\n+\t\ttestUint64x8ConvertToUint16(t, archsimd.Uint64x8.SaturateToUint16, map1[uint64](satToUint16))\n+\t\ttestUint64x2ConvertToUint32(t, archsimd.Uint64x2.SaturateToUint32, map1n[uint64](satToUint32, 4))\n+\t\ttestUint64x4ConvertToUint32(t, archsimd.Uint64x4.SaturateToUint32, map1[uint64](satToUint32))\n+\t\ttestUint64x8ConvertToUint32(t, archsimd.Uint64x8.SaturateToUint32, map1[uint64](satToUint32))\n+\t}\n+}","output":"test(simd): add saturate conversion tests","metadata":{"id":"go-110aaf71","repository":"go","commit_hash":"110aaf7137430595faaee5623ab724d73c1f9aab"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/cmd/compile/internal/ssa/_gen/simdAMD64.rules  |  40 ++++----\n .../compile/internal/ssa/_gen/simdgenericOps.go    |  40 ++++----\n src/cmd/compile/internal/ssa/opGen.go              |  80 ++++++++--------\n src/cmd/compile/internal/ssa/rewriteAMD64.go       |  40 ++++----\n src/cmd/compile/internal/ssagen/simdintrinsics.go  |  40 ++++----\n .../_gen/simdgen/ops/Converts/categories.yaml      |  40 ++++----\n .../archsimd/_gen/simdgen/ops/Converts/go.yaml     |  40 ++++----\n src/simd/archsimd/ops_amd64.go                     | 104 ++++++++++-----------\n 8 files changed, 212 insertions(+), 212 deletions(-)\n\ndiff --git a/src/cmd/compile/internal/ssa/_gen/simdAMD64.rules b/src/cmd/compile/internal/ssa/_gen/simdAMD64.rules\nindex a7a6a3f7..8a5b70da 100644\n--- a/src/cmd/compile/internal/ssa/_gen/simdAMD64.rules\n+++ b/src/cmd/compile/internal/ssa/_gen/simdAMD64.rules\n@@ -376,26 +376,26 @@\n (ExpandUint64x2 x mask) => (VPEXPANDQMasked128 x (VPMOVVec64x2ToM <types.TypeMask> mask))\n (ExpandUint64x4 x mask) => (VPEXPANDQMasked256 x (VPMOVVec64x4ToM <types.TypeMask> mask))\n (ExpandUint64x8 x mask) => (VPEXPANDQMasked512 x (VPMOVVec64x8ToM <types.TypeMask> mask))\n-(ExtendLo2ToInt64x2Int8x16 ...) => (VPMOVSXBQ128 ...)\n-(ExtendLo2ToInt64x2Int16x8 ...) => (VPMOVSXWQ128 ...)\n-(ExtendLo2ToInt64x2Int32x4 ...) => (VPMOVSXDQ128 ...)\n-(ExtendLo2ToUint64x2Uint8x16 ...) => (VPMOVZXBQ128 ...)\n-(ExtendLo2ToUint64x2Uint16x8 ...) => (VPMOVZXWQ128 ...)\n-(ExtendLo2ToUint64x2Uint32x4 ...) => (VPMOVZXDQ128 ...)\n-(ExtendLo4ToInt32x4Int8x16 ...) => (VPMOVSXBD128 ...)\n-(ExtendLo4ToInt32x4Int16x8 ...) => (VPMOVSXWD128 ...)\n-(ExtendLo4ToInt64x4Int8x16 ...) => (VPMOVSXBQ256 ...)\n-(ExtendLo4ToInt64x4Int16x8 ...) => (VPMOVSXWQ256 ...)\n-(ExtendLo4ToUint32x4Uint8x16 ...) => (VPMOVZXBD128 ...)\n-(ExtendLo4ToUint32x4Uint16x8 ...) => (VPMOVZXWD128 ...)\n-(ExtendLo4ToUint64x4Uint8x16 ...) => (VPMOVZXBQ256 ...)\n-(ExtendLo4ToUint64x4Uint16x8 ...) => (VPMOVZXWQ256 ...)\n-(ExtendLo8ToInt16x8Int8x16 ...) => (VPMOVSXBW128 ...)\n-(ExtendLo8ToInt32x8Int8x16 ...) => (VPMOVSXBD256 ...)\n-(ExtendLo8ToInt64x8Int8x16 ...) => (VPMOVSXBQ512 ...)\n-(ExtendLo8ToUint16x8Uint8x16 ...) => (VPMOVZXBW128 ...)\n-(ExtendLo8ToUint32x8Uint8x16 ...) => (VPMOVZXBD256 ...)\n-(ExtendLo8ToUint64x8Uint8x16 ...) => (VPMOVZXBQ512 ...)\n+(ExtendLo2ToInt64Int8x16 ...) => (VPMOVSXBQ128 ...)\n+(ExtendLo2ToInt64Int16x8 ...) => (VPMOVSXWQ128 ...)\n+(ExtendLo2ToInt64Int32x4 ...) => (VPMOVSXDQ128 ...)\n+(ExtendLo2ToUint64Uint8x16 ...) => (VPMOVZXBQ128 ...)\n+(ExtendLo2ToUint64Uint16x8 ...) => (VPMOVZXWQ128 ...)\n+(ExtendLo2ToUint64Uint32x4 ...) => (VPMOVZXDQ128 ...)\n+(ExtendLo4ToInt32Int8x16 ...) => (VPMOVSXBD128 ...)\n+(ExtendLo4ToInt32Int16x8 ...) => (VPMOVSXWD128 ...)\n+(ExtendLo4ToInt64Int8x16 ...) => (VPMOVSXBQ256 ...)\n+(ExtendLo4ToInt64Int16x8 ...) => (VPMOVSXWQ256 ...)\n+(ExtendLo4ToUint32Uint8x16 ...) => (VPMOVZXBD128 ...)\n+(ExtendLo4ToUint32Uint16x8 ...) => (VPMOVZXWD128 ...)\n+(ExtendLo4ToUint64Uint8x16 ...) => (VPMOVZXBQ256 ...)\n+(ExtendLo4ToUint64Uint16x8 ...) => (VPMOVZXWQ256 ...)\n+(ExtendLo8ToInt16Int8x16 ...) => (VPMOVSXBW128 ...)\n+(ExtendLo8ToInt32Int8x16 ...) => (VPMOVSXBD256 ...)\n+(ExtendLo8ToInt64Int8x16 ...) => (VPMOVSXBQ512 ...)\n+(ExtendLo8ToUint16Uint8x16 ...) => (VPMOVZXBW128 ...)\n+(ExtendLo8ToUint32Uint8x16 ...) => (VPMOVZXBD256 ...)\n+(ExtendLo8ToUint64Uint8x16 ...) => (VPMOVZXBQ512 ...)\n (ExtendToInt16Int8x16 ...) => (VPMOVSXBW256 ...)\n (ExtendToInt16Int8x32 ...) => (VPMOVSXBW512 ...)\n (ExtendToInt32Int8x16 ...) => (VPMOVSXBD512 ...)\ndiff --git a/src/cmd/compile/internal/ssa/_gen/simdgenericOps.go b/src/cmd/compile/internal/ssa/_gen/simdgenericOps.go\nindex fd43f3d6..af1007cd 100644\n--- a/src/cmd/compile/internal/ssa/_gen/simdgenericOps.go\n+++ b/src/cmd/compile/internal/ssa/_gen/simdgenericOps.go\n@@ -364,26 +364,26 @@ func simdGenericOps() []opData {\n \t\t{name: \"ExpandUint64x2\", argLength: 2, commutative: false},\n \t\t{name: \"ExpandUint64x4\", argLength: 2, commutative: false},\n \t\t{name: \"ExpandUint64x8\", argLength: 2, commutative: false},\n-\t\t{name: \"ExtendLo2ToInt64x2Int8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo2ToInt64x2Int16x8\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo2ToInt64x2Int32x4\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo2ToUint64x2Uint8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo2ToUint64x2Uint16x8\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo2ToUint64x2Uint32x4\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo4ToInt32x4Int8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo4ToInt32x4Int16x8\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo4ToInt64x4Int8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo4ToInt64x4Int16x8\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo4ToUint32x4Uint8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo4ToUint32x4Uint16x8\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo4ToUint64x4Uint8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo4ToUint64x4Uint16x8\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo8ToInt16x8Int8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo8ToInt32x8Int8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo8ToInt64x8Int8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo8ToUint16x8Uint8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo8ToUint32x8Uint8x16\", argLength: 1, commutative: false},\n-\t\t{name: \"ExtendLo8ToUint64x8Uint8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo2ToInt64Int8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo2ToInt64Int16x8\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo2ToInt64Int32x4\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo2ToUint64Uint8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo2ToUint64Uint16x8\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo2ToUint64Uint32x4\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo4ToInt32Int8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo4ToInt32Int16x8\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo4ToInt64Int8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo4ToInt64Int16x8\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo4ToUint32Uint8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo4ToUint32Uint16x8\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo4ToUint64Uint8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo4ToUint64Uint16x8\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo8ToInt16Int8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo8ToInt32Int8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo8ToInt64Int8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo8ToUint16Uint8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo8ToUint32Uint8x16\", argLength: 1, commutative: false},\n+\t\t{name: \"ExtendLo8ToUint64Uint8x16\", argLength: 1, commutative: false},\n \t\t{name: \"ExtendToInt16Int8x16\", argLength: 1, commutative: false},\n \t\t{name: \"ExtendToInt16Int8x32\", argLength: 1, commutative: false},\n \t\t{name: \"ExtendToInt32Int8x16\", argLength: 1, commutative: false},\ndiff --git a/src/cmd/compile/internal/ssa/opGen.go b/src/cmd/compile/internal/ssa/opGen.go\nindex f318adfd..d2ba15f7 100644\n--- a/src/cmd/compile/internal/ssa/opGen.go\n+++ b/src/cmd/compile/internal/ssa/opGen.go\n@@ -6518,26 +6518,26 @@ const (\n \tOpExpandUint64x2\n \tOpExpandUint64x4\n \tOpExpandUint64x8\n-\tOpExtendLo2ToInt64x2Int8x16\n-\tOpExtendLo2ToInt64x2Int16x8\n-\tOpExtendLo2ToInt64x2Int32x4\n-\tOpExtendLo2ToUint64x2Uint8x16\n-\tOpExtendLo2ToUint64x2Uint16x8\n-\tOpExtendLo2ToUint64x2Uint32x4\n-\tOpExtendLo4ToInt32x4Int8x16\n-\tOpExtendLo4ToInt32x4Int16x8\n-\tOpExtendLo4ToInt64x4Int8x16\n-\tOpExtendLo4ToInt64x4Int16x8\n-\tOpExtendLo4ToUint32x4Uint8x16\n-\tOpExtendLo4ToUint32x4Uint16x8\n-\tOpExtendLo4ToUint64x4Uint8x16\n-\tOpExtendLo4ToUint64x4Uint16x8\n-\tOpExtendLo8ToInt16x8Int8x16\n-\tOpExtendLo8ToInt32x8Int8x16\n-\tOpExtendLo8ToInt64x8Int8x16\n-\tOpExtendLo8ToUint16x8Uint8x16\n-\tOpExtendLo8ToUint32x8Uint8x16\n-\tOpExtendLo8ToUint64x8Uint8x16\n+\tOpExtendLo2ToInt64Int8x16\n+\tOpExtendLo2ToInt64Int16x8\n+\tOpExtendLo2ToInt64Int32x4\n+\tOpExtendLo2ToUint64Uint8x16\n+\tOpExtendLo2ToUint64Uint16x8\n+\tOpExtendLo2ToUint64Uint32x4\n+\tOpExtendLo4ToInt32Int8x16\n+\tOpExtendLo4ToInt32Int16x8\n+\tOpExtendLo4ToInt64Int8x16\n+\tOpExtendLo4ToInt64Int16x8\n+\tOpExtendLo4ToUint32Uint8x16\n+\tOpExtendLo4ToUint32Uint16x8\n+\tOpExtendLo4ToUint64Uint8x16\n+\tOpExtendLo4ToUint64Uint16x8\n+\tOpExtendLo8ToInt16Int8x16\n+\tOpExtendLo8ToInt32Int8x16\n+\tOpExtendLo8ToInt64Int8x16\n+\tOpExtendLo8ToUint16Uint8x16\n+\tOpExtendLo8ToUint32Uint8x16\n+\tOpExtendLo8ToUint64Uint8x16\n \tOpExtendToInt16Int8x16\n \tOpExtendToInt16Int8x32\n \tOpExtendToInt32Int8x16\n@@ -90896,102 +90896,102 @@ var opcodeTable = [...]opInfo{\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo2ToInt64x2Int8x16\",\n+\t\tname:    \"ExtendLo2ToInt64Int8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo2ToInt64x2Int16x8\",\n+\t\tname:    \"ExtendLo2ToInt64Int16x8\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo2ToInt64x2Int32x4\",\n+\t\tname:    \"ExtendLo2ToInt64Int32x4\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo2ToUint64x2Uint8x16\",\n+\t\tname:    \"ExtendLo2ToUint64Uint8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo2ToUint64x2Uint16x8\",\n+\t\tname:    \"ExtendLo2ToUint64Uint16x8\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo2ToUint64x2Uint32x4\",\n+\t\tname:    \"ExtendLo2ToUint64Uint32x4\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo4ToInt32x4Int8x16\",\n+\t\tname:    \"ExtendLo4ToInt32Int8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo4ToInt32x4Int16x8\",\n+\t\tname:    \"ExtendLo4ToInt32Int16x8\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo4ToInt64x4Int8x16\",\n+\t\tname:    \"ExtendLo4ToInt64Int8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo4ToInt64x4Int16x8\",\n+\t\tname:    \"ExtendLo4ToInt64Int16x8\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo4ToUint32x4Uint8x16\",\n+\t\tname:    \"ExtendLo4ToUint32Uint8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo4ToUint32x4Uint16x8\",\n+\t\tname:    \"ExtendLo4ToUint32Uint16x8\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo4ToUint64x4Uint8x16\",\n+\t\tname:    \"ExtendLo4ToUint64Uint8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo4ToUint64x4Uint16x8\",\n+\t\tname:    \"ExtendLo4ToUint64Uint16x8\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo8ToInt16x8Int8x16\",\n+\t\tname:    \"ExtendLo8ToInt16Int8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo8ToInt32x8Int8x16\",\n+\t\tname:    \"ExtendLo8ToInt32Int8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo8ToInt64x8Int8x16\",\n+\t\tname:    \"ExtendLo8ToInt64Int8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo8ToUint16x8Uint8x16\",\n+\t\tname:    \"ExtendLo8ToUint16Uint8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo8ToUint32x8Uint8x16\",\n+\t\tname:    \"ExtendLo8ToUint32Uint8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\n \t{\n-\t\tname:    \"ExtendLo8ToUint64x8Uint8x16\",\n+\t\tname:    \"ExtendLo8ToUint64Uint8x16\",\n \t\targLen:  1,\n \t\tgeneric: true,\n \t},\ndiff --git a/src/cmd/compile/internal/ssa/rewriteAMD64.go b/src/cmd/compile/internal/ssa/rewriteAMD64.go\nindex 5fed6a80..0c044100 100644\n--- a/src/cmd/compile/internal/ssa/rewriteAMD64.go\n+++ b/src/cmd/compile/internal/ssa/rewriteAMD64.go\n@@ -3274,64 +3274,64 @@ func rewriteValueAMD64(v *Value) bool {\n \t\treturn rewriteValueAMD64_OpExpandUint8x32(v)\n \tcase OpExpandUint8x64:\n \t\treturn rewriteValueAMD64_OpExpandUint8x64(v)\n-\tcase OpExtendLo2ToInt64x2Int16x8:\n+\tcase OpExtendLo2ToInt64Int16x8:\n \t\tv.Op = OpAMD64VPMOVSXWQ128\n \t\treturn true\n-\tcase OpExtendLo2ToInt64x2Int32x4:\n+\tcase OpExtendLo2ToInt64Int32x4:\n \t\tv.Op = OpAMD64VPMOVSXDQ128\n \t\treturn true\n-\tcase OpExtendLo2ToInt64x2Int8x16:\n+\tcase OpExtendLo2ToInt64Int8x16:\n \t\tv.Op = OpAMD64VPMOVSXBQ128\n \t\treturn true\n-\tcase OpExtendLo2ToUint64x2Uint16x8:\n+\tcase OpExtendLo2ToUint64Uint16x8:\n \t\tv.Op = OpAMD64VPMOVZXWQ128\n \t\treturn true\n-\tcase OpExtendLo2ToUint64x2Uint32x4:\n+\tcase OpExtendLo2ToUint64Uint32x4:\n \t\tv.Op = OpAMD64VPMOVZXDQ128\n \t\treturn true\n-\tcase OpExtendLo2ToUint64x2Uint8x16:\n+\tcase OpExtendLo2ToUint64Uint8x16:\n \t\tv.Op = OpAMD64VPMOVZXBQ128\n \t\treturn true\n-\tcase OpExtendLo4ToInt32x4Int16x8:\n+\tcase OpExtendLo4ToInt32Int16x8:\n \t\tv.Op = OpAMD64VPMOVSXWD128\n \t\treturn true\n-\tcase OpExtendLo4ToInt32x4Int8x16:\n+\tcase OpExtendLo4ToInt32Int8x16:\n \t\tv.Op = OpAMD64VPMOVSXBD128\n \t\treturn true\n-\tcase OpExtendLo4ToInt64x4Int16x8:\n+\tcase OpExtendLo4ToInt64Int16x8:\n \t\tv.Op = OpAMD64VPMOVSXWQ256\n \t\treturn true\n-\tcase OpExtendLo4ToInt64x4Int8x16:\n+\tcase OpExtendLo4ToInt64Int8x16:\n \t\tv.Op = OpAMD64VPMOVSXBQ256\n \t\treturn true\n-\tcase OpExtendLo4ToUint32x4Uint16x8:\n+\tcase OpExtendLo4ToUint32Uint16x8:\n \t\tv.Op = OpAMD64VPMOVZXWD128\n \t\treturn true\n-\tcase OpExtendLo4ToUint32x4Uint8x16:\n+\tcase OpExtendLo4ToUint32Uint8x16:\n \t\tv.Op = OpAMD64VPMOVZXBD128\n \t\treturn true\n-\tcase OpExtendLo4ToUint64x4Uint16x8:\n+\tcase OpExtendLo4ToUint64Uint16x8:\n \t\tv.Op = OpAMD64VPMOVZXWQ256\n \t\treturn true\n-\tcase OpExtendLo4ToUint64x4Uint8x16:\n+\tcase OpExtendLo4ToUint64Uint8x16:\n \t\tv.Op = OpAMD64VPMOVZXBQ256\n \t\treturn true\n-\tcase OpExtendLo8ToInt16x8Int8x16:\n+\tcase OpExtendLo8ToInt16Int8x16:\n \t\tv.Op = OpAMD64VPMOVSXBW128\n \t\treturn true\n-\tcase OpExtendLo8ToInt32x8Int8x16:\n+\tcase OpExtendLo8ToInt32Int8x16:\n \t\tv.Op = OpAMD64VPMOVSXBD256\n \t\treturn true\n-\tcase OpExtendLo8ToInt64x8Int8x16:\n+\tcase OpExtendLo8ToInt64Int8x16:\n \t\tv.Op = OpAMD64VPMOVSXBQ512\n \t\treturn true\n-\tcase OpExtendLo8ToUint16x8Uint8x16:\n+\tcase OpExtendLo8ToUint16Uint8x16:\n \t\tv.Op = OpAMD64VPMOVZXBW128\n \t\treturn true\n-\tcase OpExtendLo8ToUint32x8Uint8x16:\n+\tcase OpExtendLo8ToUint32Uint8x16:\n \t\tv.Op = OpAMD64VPMOVZXBD256\n \t\treturn true\n-\tcase OpExtendLo8ToUint64x8Uint8x16:\n+\tcase OpExtendLo8ToUint64Uint8x16:\n \t\tv.Op = OpAMD64VPMOVZXBQ512\n \t\treturn true\n \tcase OpExtendToInt16Int8x16:\ndiff --git a/src/cmd/compile/internal/ssagen/simdintrinsics.go b/src/cmd/compile/internal/ssagen/simdintrinsics.go\nindex 8b9fe3af..5a957612 100644\n--- a/src/cmd/compile/internal/ssagen/simdintrinsics.go\n+++ b/src/cmd/compile/internal/ssagen/simdintrinsics.go\n@@ -388,26 +388,26 @@ func simdIntrinsics(addF func(pkg, fn string, b intrinsicBuilder, archFamilies .\n \taddF(simdPackage, \"Uint64x2.Expand\", opLen2(ssa.OpExpandUint64x2, types.TypeVec128), sys.AMD64)\n \taddF(simdPackage, \"Uint64x4.Expand\", opLen2(ssa.OpExpandUint64x4, types.TypeVec256), sys.AMD64)\n \taddF(simdPackage, \"Uint64x8.Expand\", opLen2(ssa.OpExpandUint64x8, types.TypeVec512), sys.AMD64)\n-\taddF(simdPackage, \"Int8x16.ExtendLo2ToInt64x2\", opLen1(ssa.OpExtendLo2ToInt64x2Int8x16, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Int16x8.ExtendLo2ToInt64x2\", opLen1(ssa.OpExtendLo2ToInt64x2Int16x8, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Int32x4.ExtendLo2ToInt64x2\", opLen1(ssa.OpExtendLo2ToInt64x2Int32x4, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Uint8x16.ExtendLo2ToUint64x2\", opLen1(ssa.OpExtendLo2ToUint64x2Uint8x16, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Uint16x8.ExtendLo2ToUint64x2\", opLen1(ssa.OpExtendLo2ToUint64x2Uint16x8, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Uint32x4.ExtendLo2ToUint64x2\", opLen1(ssa.OpExtendLo2ToUint64x2Uint32x4, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Int8x16.ExtendLo4ToInt32x4\", opLen1(ssa.OpExtendLo4ToInt32x4Int8x16, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Int16x8.ExtendLo4ToInt32x4\", opLen1(ssa.OpExtendLo4ToInt32x4Int16x8, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Int8x16.ExtendLo4ToInt64x4\", opLen1(ssa.OpExtendLo4ToInt64x4Int8x16, types.TypeVec256), sys.AMD64)\n-\taddF(simdPackage, \"Int16x8.ExtendLo4ToInt64x4\", opLen1(ssa.OpExtendLo4ToInt64x4Int16x8, types.TypeVec256), sys.AMD64)\n-\taddF(simdPackage, \"Uint8x16.ExtendLo4ToUint32x4\", opLen1(ssa.OpExtendLo4ToUint32x4Uint8x16, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Uint16x8.ExtendLo4ToUint32x4\", opLen1(ssa.OpExtendLo4ToUint32x4Uint16x8, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Uint8x16.ExtendLo4ToUint64x4\", opLen1(ssa.OpExtendLo4ToUint64x4Uint8x16, types.TypeVec256), sys.AMD64)\n-\taddF(simdPackage, \"Uint16x8.ExtendLo4ToUint64x4\", opLen1(ssa.OpExtendLo4ToUint64x4Uint16x8, types.TypeVec256), sys.AMD64)\n-\taddF(simdPackage, \"Int8x16.ExtendLo8ToInt16x8\", opLen1(ssa.OpExtendLo8ToInt16x8Int8x16, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Int8x16.ExtendLo8ToInt32x8\", opLen1(ssa.OpExtendLo8ToInt32x8Int8x16, types.TypeVec256), sys.AMD64)\n-\taddF(simdPackage, \"Int8x16.ExtendLo8ToInt64x8\", opLen1(ssa.OpExtendLo8ToInt64x8Int8x16, types.TypeVec512), sys.AMD64)\n-\taddF(simdPackage, \"Uint8x16.ExtendLo8ToUint16x8\", opLen1(ssa.OpExtendLo8ToUint16x8Uint8x16, types.TypeVec128), sys.AMD64)\n-\taddF(simdPackage, \"Uint8x16.ExtendLo8ToUint32x8\", opLen1(ssa.OpExtendLo8ToUint32x8Uint8x16, types.TypeVec256), sys.AMD64)\n-\taddF(simdPackage, \"Uint8x16.ExtendLo8ToUint64x8\", opLen1(ssa.OpExtendLo8ToUint64x8Uint8x16, types.TypeVec512), sys.AMD64)\n+\taddF(simdPackage, \"Int8x16.ExtendLo2ToInt64\", opLen1(ssa.OpExtendLo2ToInt64Int8x16, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Int16x8.ExtendLo2ToInt64\", opLen1(ssa.OpExtendLo2ToInt64Int16x8, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Int32x4.ExtendLo2ToInt64\", opLen1(ssa.OpExtendLo2ToInt64Int32x4, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Uint8x16.ExtendLo2ToUint64\", opLen1(ssa.OpExtendLo2ToUint64Uint8x16, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Uint16x8.ExtendLo2ToUint64\", opLen1(ssa.OpExtendLo2ToUint64Uint16x8, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Uint32x4.ExtendLo2ToUint64\", opLen1(ssa.OpExtendLo2ToUint64Uint32x4, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Int8x16.ExtendLo4ToInt32\", opLen1(ssa.OpExtendLo4ToInt32Int8x16, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Int16x8.ExtendLo4ToInt32\", opLen1(ssa.OpExtendLo4ToInt32Int16x8, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Int8x16.ExtendLo4ToInt64\", opLen1(ssa.OpExtendLo4ToInt64Int8x16, types.TypeVec256), sys.AMD64)\n+\taddF(simdPackage, \"Int16x8.ExtendLo4ToInt64\", opLen1(ssa.OpExtendLo4ToInt64Int16x8, types.TypeVec256), sys.AMD64)\n+\taddF(simdPackage, \"Uint8x16.ExtendLo4ToUint32\", opLen1(ssa.OpExtendLo4ToUint32Uint8x16, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Uint16x8.ExtendLo4ToUint32\", opLen1(ssa.OpExtendLo4ToUint32Uint16x8, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Uint8x16.ExtendLo4ToUint64\", opLen1(ssa.OpExtendLo4ToUint64Uint8x16, types.TypeVec256), sys.AMD64)\n+\taddF(simdPackage, \"Uint16x8.ExtendLo4ToUint64\", opLen1(ssa.OpExtendLo4ToUint64Uint16x8, types.TypeVec256), sys.AMD64)\n+\taddF(simdPackage, \"Int8x16.ExtendLo8ToInt16\", opLen1(ssa.OpExtendLo8ToInt16Int8x16, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Int8x16.ExtendLo8ToInt32\", opLen1(ssa.OpExtendLo8ToInt32Int8x16, types.TypeVec256), sys.AMD64)\n+\taddF(simdPackage, \"Int8x16.ExtendLo8ToInt64\", opLen1(ssa.OpExtendLo8ToInt64Int8x16, types.TypeVec512), sys.AMD64)\n+\taddF(simdPackage, \"Uint8x16.ExtendLo8ToUint16\", opLen1(ssa.OpExtendLo8ToUint16Uint8x16, types.TypeVec128), sys.AMD64)\n+\taddF(simdPackage, \"Uint8x16.ExtendLo8ToUint32\", opLen1(ssa.OpExtendLo8ToUint32Uint8x16, types.TypeVec256), sys.AMD64)\n+\taddF(simdPackage, \"Uint8x16.ExtendLo8ToUint64\", opLen1(ssa.OpExtendLo8ToUint64Uint8x16, types.TypeVec512), sys.AMD64)\n \taddF(simdPackage, \"Int8x16.ExtendToInt16\", opLen1(ssa.OpExtendToInt16Int8x16, types.TypeVec256), sys.AMD64)\n \taddF(simdPackage, \"Int8x32.ExtendToInt16\", opLen1(ssa.OpExtendToInt16Int8x32, types.TypeVec512), sys.AMD64)\n \taddF(simdPackage, \"Int8x16.ExtendToInt32\", opLen1(ssa.OpExtendToInt32Int8x16, types.TypeVec512), sys.AMD64)\ndiff --git a/src/simd/archsimd/_gen/simdgen/ops/Converts/categories.yaml b/src/simd/archsimd/_gen/simdgen/ops/Converts/categories.yaml\nindex 88e48409..698e6d99 100644\n--- a/src/simd/archsimd/_gen/simdgen/ops/Converts/categories.yaml\n+++ b/src/simd/archsimd/_gen/simdgen/ops/Converts/categories.yaml\n@@ -135,83 +135,83 @@\n   documentation: !string |-\n     // NAME zero-extends element values to uint64.\n # low-part only Int <-> Int conversions\n-- go: ExtendLo8ToUint16x8\n+- go: ExtendLo8ToUint16\n   commutative: false\n   documentation: !string |-\n     // NAME zero-extends 8 lowest vector element values to uint16.\n-- go: ExtendLo8ToInt16x8\n+- go: ExtendLo8ToInt16\n   commutative: false\n   documentation: !string |-\n     // NAME sign-extends 8 lowest vector element values to int16.\n-- go: ExtendLo4ToUint32x4\n+- go: ExtendLo4ToUint32\n   commutative: false\n   documentation: !string |-\n     // NAME zero-extends 4 lowest vector element values to uint32.\n-- go: ExtendLo4ToInt32x4\n+- go: ExtendLo4ToInt32\n   commutative: false\n   documentation: !string |-\n     // NAME sign-extends 4 lowest vector element values to int32.\n-- go: ExtendLo2ToUint64x2\n+- go: ExtendLo2ToUint64\n   commutative: false\n   documentation: !string |-\n     // NAME zero-extends 2 lowest vector element values to uint64.\n-- go: ExtendLo2ToInt64x2\n+- go: ExtendLo2ToInt64\n   commutative: false\n   documentation: !string |-\n     // NAME sign-extends 2 lowest vector element values to int64.\n-- go: ExtendLo2ToUint64x2\n+- go: ExtendLo2ToUint64\n   commutative: false\n   documentation: !string |-\n     // NAME zero-extends 2 lowest vector element values to uint64.\n-- go: ExtendLo4ToUint64x4\n+- go: ExtendLo4ToUint64\n   commutative: false\n   documentation: !string |-\n     // NAME zero-extends 4 lowest vector element values to uint64.\n-- go: ExtendLo2ToInt64x2\n+- go: ExtendLo2ToInt64\n   commutative: false\n   documentation: !string |-\n     // NAME sign-extends 2 lowest vector element values to int64.\n-- go: ExtendLo4ToInt64x4\n+- go: ExtendLo4ToInt64\n   commutative: false\n   documentation: !string |-\n     // NAME sign-extends 4 lowest vector element values to int64.\n-- go: ExtendLo4ToUint32x4\n+- go: ExtendLo4ToUint32\n   commutative: false\n   documentation: !string |-\n     // NAME zero-extends 4 lowest vector element values to uint32.\n-- go: ExtendLo8ToUint32x8\n+- go: ExtendLo8ToUint32\n   commutative: false\n   documentation: !string |-\n     // NAME zero-extends 8 lowest vector element values to uint32.\n-- go: ExtendLo4ToInt32x4\n+- go: ExtendLo4ToInt32\n   commutative: false\n   documentation: !string |-\n     // NAME sign-extends 4 lowest vector element values to int32.\n-- go: ExtendLo8ToInt32x8\n+- go: ExtendLo8ToInt32\n   commutative: false\n   documentation: !string |-\n     // NAME sign-extends 8 lowest vector element values to int32.\n-- go: ExtendLo2ToUint64x2\n+- go: ExtendLo2ToUint64\n   commutative: false\n   documentation: !string |-\n     // NAME zero-extends 2 lowest vector element values to uint64.\n-- go: ExtendLo4ToUint64x4\n+- go: ExtendLo4ToUint64\n   commutative: false\n   documentation: !string |-\n     // NAME zero-extends 4 lowest vector element values to uint64.\n-- go: ExtendLo8ToUint64x8\n+- go: ExtendLo8ToUint64\n   commutative: false\n   documentation: !string |-\n     // NAME zero-extends 8 lowest vector element values to uint64.\n-- go: ExtendLo2ToInt64x2\n+- go: ExtendLo2ToInt64\n   commutative: false\n   documentation: !string |-\n     // NAME sign-extends 2 lowest vector element values to int64.\n-- go: ExtendLo4ToInt64x4\n+- go: ExtendLo4ToInt64\n   commutative: false\n   documentation: !string |-\n     // NAME sign-extends 4 lowest vector element values to int64.\n-- go: ExtendLo8ToInt64x8\n+- go: ExtendLo8ToInt64\n   commutative: false\n   documentation: !string |-\n     // NAME sign-extends 8 lowest vector element values to int64.\ndiff --git a/src/simd/archsimd/_gen/simdgen/ops/Converts/go.yaml b/src/simd/archsimd/_gen/simdgen/ops/Converts/go.yaml\nindex f436be23..2f19d126 100644\n--- a/src/simd/archsimd/_gen/simdgen/ops/Converts/go.yaml\n+++ b/src/simd/archsimd/_gen/simdgen/ops/Converts/go.yaml\n@@ -491,7 +491,7 @@\n \n # low-part only conversions.\n # uint8->uint16\n-- go: ExtendLo8ToUint16x8\n+- go: ExtendLo8ToUint16\n   regexpTag: \"convert\"\n   asm: \"VPMOVZXBW\"\n   in:\n@@ -499,7 +499,7 @@\n   out:\n   - *u16x8\n # int8->int16\n-- go: ExtendLo8ToInt16x8\n+- go: ExtendLo8ToInt16\n   regexpTag: \"convert\"\n   asm: \"VPMOVSXBW\"\n   in:\n@@ -507,7 +507,7 @@\n   out:\n   - *i16x8\n # uint16->uint32\n-- go: ExtendLo4ToUint32x4\n+- go: ExtendLo4ToUint32\n   regexpTag: \"convert\"\n   asm: \"VPMOVZXWD\"\n   in:\n@@ -515,7 +515,7 @@\n   out:\n   - *u32x4\n # int16->int32\n-- go: ExtendLo4ToInt32x4\n+- go: ExtendLo4ToInt32\n   regexpTag: \"convert\"\n   asm: \"VPMOVSXWD\"\n   in:\n@@ -523,7 +523,7 @@\n   out:\n   - *i32x4\n # uint32 -> uint64\n-- go: ExtendLo2ToUint64x2\n+- go: ExtendLo2ToUint64\n   regexpTag: \"convert\"\n   asm: \"VPMOVZXDQ\"\n   in:\n@@ -534,7 +534,7 @@\n     elemBits: 64\n     bits: 128\n # int32 -> int64\n-- go: ExtendLo2ToInt64x2\n+- go: ExtendLo2ToInt64\n   regexpTag: \"convert\"\n   asm: \"VPMOVSXDQ\"\n   in:\n@@ -545,14 +545,14 @@\n     elemBits: 64\n     bits: 128\n # uint16 -> uint64\n-- go: ExtendLo2ToUint64x2\n+- go: ExtendLo2ToUint64\n   regexpTag: \"convert\"\n   asm: \"VPMOVZXWQ\"\n   in:\n   - *u16x8\n   out:\n   - *u64x2\n-- go: ExtendLo4ToUint64x4\n+- go: ExtendLo4ToUint64\n   regexpTag: \"convert\"\n   asm: \"VPMOVZXWQ\"\n   in:\n@@ -560,14 +560,14 @@\n   out:\n   - *u64x4\n # int16 -> int64\n-- go: ExtendLo2ToInt64x2\n+- go: ExtendLo2ToInt64\n   regexpTag: \"convert\"\n   asm: \"VPMOVSXWQ\"\n   in:\n   - *i16x8\n   out:\n   - *i64x2\n-- go: ExtendLo4ToInt64x4\n+- go: ExtendLo4ToInt64\n   regexpTag: \"convert\"\n   asm: \"VPMOVSXWQ\"\n   in:\n@@ -575,14 +575,14 @@\n   out:\n   - *i64x4\n # uint8 -> uint32\n-- go: ExtendLo4ToUint32x4\n+- go: ExtendLo4ToUint32\n   regexpTag: \"convert\"\n   asm: \"VPMOVZXBD\"\n   in:\n   - *u8x16\n   out:\n   - *u32x4\n-- go: ExtendLo8ToUint32x8\n+- go: ExtendLo8ToUint32\n   regexpTag: \"convert\"\n   asm: \"VPMOVZXBD\"\n   in:\n@@ -590,14 +590,14 @@\n   out:\n   - *u32x8\n # int8 -> int32\n-- go: ExtendLo4ToInt32x4\n+- go: ExtendLo4ToInt32\n   regexpTag: \"convert\"\n   asm: \"VPMOVSXBD\"\n   in:\n   - *i8x16\n   out:\n   - *i32x4\n-- go: ExtendLo8ToInt32x8\n+- go: ExtendLo8ToInt32\n   regexpTag: \"convert\"\n   asm: \"VPMOVSXBD\"\n   in:\n@@ -605,21 +605,21 @@\n   out:\n   - *i32x8\n # uint8 -> uint64\n-- go: ExtendLo2ToUint64x2\n+- go: ExtendLo2ToUint64\n   regexpTag: \"convert\"\n   asm: \"VPMOVZXBQ\"\n   in:\n   - *u8x16\n   out:\n   - *u64x2\n-- go: ExtendLo4ToUint64x4\n+- go: ExtendLo4ToUint64\n   regexpTag: \"convert\"\n   asm: \"VPMOVZXBQ\"\n   in:\n   - *u8x16\n   out:\n   - *u64x4\n-- go: ExtendLo8ToUint64x8\n+- go: ExtendLo8ToUint64\n   regexpTag: \"convert\"\n   asm: \"VPMOVZXBQ\"\n   in:\n@@ -627,21 +627,21 @@\n   out:\n   - *u64x8\n # int8 -> int64\n-- go: ExtendLo2ToInt64x2\n+- go: ExtendLo2ToInt64\n   regexpTag: \"convert\"\n   asm: \"VPMOVSXBQ\"\n   in:\n   - *i8x16\n   out:\n   - *i64x2\n-- go: ExtendLo4ToInt64x4\n+- go: ExtendLo4ToInt64\n   regexpTag: \"convert\"\n   asm: \"VPMOVSXBQ\"\n   in:\n   - *i8x16\n   out:\n   - *i64x4\n-- go: ExtendLo8ToInt64x8\n+- go: ExtendLo8ToInt64\n   regexpTag: \"convert\"\n   asm: \"VPMOVSXBQ\"\n   in:\ndiff --git a/src/simd/archsimd/ops_amd64.go b/src/simd/archsimd/ops_amd64.go\nindex 20ae3b1c..522a98ca 100644\n--- a/src/simd/archsimd/ops_amd64.go\n+++ b/src/simd/archsimd/ops_amd64.go\n@@ -2325,129 +2325,129 @@ func (x Uint64x4) Expand(mask Mask64x4) Uint64x4\n // Asm: VPEXPANDQ, CPU Feature: AVX512\n func (x Uint64x8) Expand(mask Mask64x8) Uint64x8\n \n-/* ExtendLo2ToInt64x2 */\n+/* ExtendLo2ToInt64 */\n \n-// ExtendLo2ToInt64x2 sign-extends 2 lowest vector element values to int64.\n+// ExtendLo2ToInt64 sign-extends 2 lowest vector element values to int64.\n //\n // Asm: VPMOVSXBQ, CPU Feature: AVX\n-func (x Int8x16) ExtendLo2ToInt64x2() Int64x2\n+func (x Int8x16) ExtendLo2ToInt64() Int64x2\n \n-// ExtendLo2ToInt64x2 sign-extends 2 lowest vector element values to int64.\n+// ExtendLo2ToInt64 sign-extends 2 lowest vector element values to int64.\n //\n // Asm: VPMOVSXWQ, CPU Feature: AVX\n-func (x Int16x8) ExtendLo2ToInt64x2() Int64x2\n+func (x Int16x8) ExtendLo2ToInt64() Int64x2\n \n-// ExtendLo2ToInt64x2 sign-extends 2 lowest vector element values to int64.\n+// ExtendLo2ToInt64 sign-extends 2 lowest vector element values to int64.\n //\n // Asm: VPMOVSXDQ, CPU Feature: AVX\n-func (x Int32x4) ExtendLo2ToInt64x2() Int64x2\n+func (x Int32x4) ExtendLo2ToInt64() Int64x2\n \n-/* ExtendLo2ToUint64x2 */\n+/* ExtendLo2ToUint64 */\n \n-// ExtendLo2ToUint64x2 zero-extends 2 lowest vector element values to uint64.\n+// ExtendLo2ToUint64 zero-extends 2 lowest vector element values to uint64.\n //\n // Asm: VPMOVZXBQ, CPU Feature: AVX\n-func (x Uint8x16) ExtendLo2ToUint64x2() Uint64x2\n+func (x Uint8x16) ExtendLo2ToUint64() Uint64x2\n \n-// ExtendLo2ToUint64x2 zero-extends 2 lowest vector element values to uint64.\n+// ExtendLo2ToUint64 zero-extends 2 lowest vector element values to uint64.\n //\n // Asm: VPMOVZXWQ, CPU Feature: AVX\n-func (x Uint16x8) ExtendLo2ToUint64x2() Uint64x2\n+func (x Uint16x8) ExtendLo2ToUint64() Uint64x2\n \n-// ExtendLo2ToUint64x2 zero-extends 2 lowest vector element values to uint64.\n+// ExtendLo2ToUint64 zero-extends 2 lowest vector element values to uint64.\n //\n // Asm: VPMOVZXDQ, CPU Feature: AVX\n-func (x Uint32x4) ExtendLo2ToUint64x2() Uint64x2\n+func (x Uint32x4) ExtendLo2ToUint64() Uint64x2\n \n-/* ExtendLo4ToInt32x4 */\n+/* ExtendLo4ToInt32 */\n \n-// ExtendLo4ToInt32x4 sign-extends 4 lowest vector element values to int32.\n+// ExtendLo4ToInt32 sign-extends 4 lowest vector element values to int32.\n //\n // Asm: VPMOVSXBD, CPU Feature: AVX\n-func (x Int8x16) ExtendLo4ToInt32x4() Int32x4\n+func (x Int8x16) ExtendLo4ToInt32() Int32x4\n \n-// ExtendLo4ToInt32x4 sign-extends 4 lowest vector element values to int32.\n+// ExtendLo4ToInt32 sign-extends 4 lowest vector element values to int32.\n //\n // Asm: VPMOVSXWD, CPU Feature: AVX\n-func (x Int16x8) ExtendLo4ToInt32x4() Int32x4\n+func (x Int16x8) ExtendLo4ToInt32() Int32x4\n \n-/* ExtendLo4ToInt64x4 */\n+/* ExtendLo4ToInt64 */\n \n-// ExtendLo4ToInt64x4 sign-extends 4 lowest vector element values to int64.\n+// ExtendLo4ToInt64 sign-extends 4 lowest vector element values to int64.\n //\n // Asm: VPMOVSXBQ, CPU Feature: AVX2\n-func (x Int8x16) ExtendLo4ToInt64x4() Int64x4\n+func (x Int8x16) ExtendLo4ToInt64() Int64x4\n \n-// ExtendLo4ToInt64x4 sign-extends 4 lowest vector element values to int64.\n+// ExtendLo4ToInt64 sign-extends 4 lowest vector element values to int64.\n //\n // Asm: VPMOVSXWQ, CPU Feature: AVX2\n-func (x Int16x8) ExtendLo4ToInt64x4() Int64x4\n+func (x Int16x8) ExtendLo4ToInt64() Int64x4\n \n-/* ExtendLo4ToUint32x4 */\n+/* ExtendLo4ToUint32 */\n \n-// ExtendLo4ToUint32x4 zero-extends 4 lowest vector element values to uint32.\n+// ExtendLo4ToUint32 zero-extends 4 lowest vector element values to uint32.\n //\n // Asm: VPMOVZXBD, CPU Feature: AVX\n-func (x Uint8x16) ExtendLo4ToUint32x4() Uint32x4\n+func (x Uint8x16) ExtendLo4ToUint32() Uint32x4\n \n-// ExtendLo4ToUint32x4 zero-extends 4 lowest vector element values to uint32.\n+// ExtendLo4ToUint32 zero-extends 4 lowest vector element values to uint32.\n //\n // Asm: VPMOVZXWD, CPU Feature: AVX\n-func (x Uint16x8) ExtendLo4ToUint32x4() Uint32x4\n+func (x Uint16x8) ExtendLo4ToUint32() Uint32x4\n \n-/* ExtendLo4ToUint64x4 */\n+/* ExtendLo4ToUint64 */\n \n-// ExtendLo4ToUint64x4 zero-extends 4 lowest vector element values to uint64.\n+// ExtendLo4ToUint64 zero-extends 4 lowest vector element values to uint64.\n //\n // Asm: VPMOVZXBQ, CPU Feature: AVX2\n-func (x Uint8x16) ExtendLo4ToUint64x4() Uint64x4\n+func (x Uint8x16) ExtendLo4ToUint64() Uint64x4\n \n-// ExtendLo4ToUint64x4 zero-extends 4 lowest vector element values to uint64.\n+// ExtendLo4ToUint64 zero-extends 4 lowest vector element values to uint64.\n //\n // Asm: VPMOVZXWQ, CPU Feature: AVX2\n-func (x Uint16x8) ExtendLo4ToUint64x4() Uint64x4\n+func (x Uint16x8) ExtendLo4ToUint64() Uint64x4\n \n-/* ExtendLo8ToInt16x8 */\n+/* ExtendLo8ToInt16 */\n \n-// ExtendLo8ToInt16x8 sign-extends 8 lowest vector element values to int16.\n+// ExtendLo8ToInt16 sign-extends 8 lowest vector element values to int16.\n //\n // Asm: VPMOVSXBW, CPU Feature: AVX\n-func (x Int8x16) ExtendLo8ToInt16x8() Int16x8\n+func (x Int8x16) ExtendLo8ToInt16() Int16x8\n \n-/* ExtendLo8ToInt32x8 */\n+/* ExtendLo8ToInt32 */\n \n-// ExtendLo8ToInt32x8 sign-extends 8 lowest vector element values to int32.\n+// ExtendLo8ToInt32 sign-extends 8 lowest vector element values to int32.\n //\n // Asm: VPMOVSXBD, CPU Feature: AVX2\n-func (x Int8x16) ExtendLo8ToInt32x8() Int32x8\n+func (x Int8x16) ExtendLo8ToInt32() Int32x8\n \n-/* ExtendLo8ToInt64x8 */\n+/* ExtendLo8ToInt64 */\n \n-// ExtendLo8ToInt64x8 sign-extends 8 lowest vector element values to int64.\n+// ExtendLo8ToInt64 sign-extends 8 lowest vector element values to int64.\n //\n // Asm: VPMOVSXBQ, CPU Feature: AVX512\n-func (x Int8x16) ExtendLo8ToInt64x8() Int64x8\n+func (x Int8x16) ExtendLo8ToInt64() Int64x8\n \n-/* ExtendLo8ToUint16x8 */\n+/* ExtendLo8ToUint16 */\n \n-// ExtendLo8ToUint16x8 zero-extends 8 lowest vector element values to uint16.\n+// ExtendLo8ToUint16 zero-extends 8 lowest vector element values to uint16.\n //\n // Asm: VPMOVZXBW, CPU Feature: AVX\n-func (x Uint8x16) ExtendLo8ToUint16x8() Uint16x8\n+func (x Uint8x16) ExtendLo8ToUint16() Uint16x8\n \n-/* ExtendLo8ToUint32x8 */\n+/* ExtendLo8ToUint32 */\n \n-// ExtendLo8ToUint32x8 zero-extends 8 lowest vector element values to uint32.\n+// ExtendLo8ToUint32 zero-extends 8 lowest vector element values to uint32.\n //\n // Asm: VPMOVZXBD, CPU Feature: AVX2\n-func (x Uint8x16) ExtendLo8ToUint32x8() Uint32x8\n+func (x Uint8x16) ExtendLo8ToUint32() Uint32x8\n \n-/* ExtendLo8ToUint64x8 */\n+/* ExtendLo8ToUint64 */\n \n-// ExtendLo8ToUint64x8 zero-extends 8 lowest vector element values to uint64.\n+// ExtendLo8ToUint64 zero-extends 8 lowest vector element values to uint64.\n //\n // Asm: VPMOVZXBQ, CPU Feature: AVX512\n-func (x Uint8x16) ExtendLo8ToUint64x8() Uint64x8\n+func (x Uint8x16) ExtendLo8ToUint64() Uint64x8\n \n /* ExtendToInt16 */\n ","output":"refactor(simd): simplify ExtendLo op names by removing output vector","metadata":{"id":"go-76dddce2","repository":"go","commit_hash":"76dddce29302681bdddafd4cbc27db66802414dd"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/simd/archsimd/internal/simd_test/unary_test.go | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\ndiff --git a/src/simd/archsimd/internal/simd_test/unary_test.go b/src/simd/archsimd/internal/simd_test/unary_test.go\nindex 32b4626f..b6d814a4 100644\n--- a/src/simd/archsimd/internal/simd_test/unary_test.go\n+++ b/src/simd/archsimd/internal/simd_test/unary_test.go\n@@ -117,16 +117,18 @@ func TestCeilScaledResidue(t *testing.T) {\n }\n \n func TestConvert(t *testing.T) {\n-\ttestFloat32x4ConvertToFloat64(t, archsimd.Float32x4.ConvertToFloat64, map1[float32](toFloat64))\n+\ttestFloat64x2ConvertToFloat32(t, archsimd.Float64x2.ConvertToFloat32, map1n[float64](toFloat32, 4))\n \ttestFloat64x4ConvertToFloat32(t, archsimd.Float64x4.ConvertToFloat32, map1[float64](toFloat32))\n+\ttestFloat32x4ConvertToFloat64(t, archsimd.Float32x4.ConvertToFloat64, map1[float32](toFloat64))\n \n \ttestFloat32x4ConvertToInt32(t, archsimd.Float32x4.ConvertToInt32, map1[float32](floatToInt32_x86))\n \ttestFloat32x8ConvertToInt32(t, archsimd.Float32x8.ConvertToInt32, map1[float32](floatToInt32_x86))\n+\ttestFloat64x2ConvertToInt32(t, archsimd.Float64x2.ConvertToInt32, map1n[float64](floatToInt32_x86, 4))\n \ttestFloat64x4ConvertToInt32(t, archsimd.Float64x4.ConvertToInt32, map1[float64](floatToInt32_x86))\n \n \ttestInt32x4ConvertToFloat32(t, archsimd.Int32x4.ConvertToFloat32, map1[int32](toFloat32))\n-\ttestInt32x4ConvertToFloat64(t, archsimd.Int32x4.ConvertToFloat64, map1[int32](toFloat64))\n \ttestInt32x8ConvertToFloat32(t, archsimd.Int32x8.ConvertToFloat32, map1[int32](toFloat32))\n+\ttestInt32x4ConvertToFloat64(t, archsimd.Int32x4.ConvertToFloat64, map1[int32](toFloat64))\n \n \tif archsimd.X86.AVX512() {\n \t\ttestFloat32x8ConvertToFloat64(t, archsimd.Float32x8.ConvertToFloat64, map1[float32](toFloat64))\n@@ -143,6 +145,7 @@ func TestConvert(t *testing.T) {\n \t\ttestFloat32x4ConvertToUint32(t, archsimd.Float32x4.ConvertToUint32, map1[float32](floatToUint32_x86))\n \t\ttestFloat32x8ConvertToUint32(t, archsimd.Float32x8.ConvertToUint32, map1[float32](floatToUint32_x86))\n \t\ttestFloat32x16ConvertToUint32(t, archsimd.Float32x16.ConvertToUint32, map1[float32](floatToUint32_x86))\n+\t\ttestFloat64x2ConvertToUint32(t, archsimd.Float64x2.ConvertToUint32, map1n[float64](floatToUint32_x86, 4))\n \t\ttestFloat64x4ConvertToUint32(t, archsimd.Float64x4.ConvertToUint32, map1[float64](floatToUint32_x86))\n \t\ttestFloat64x8ConvertToUint32(t, archsimd.Float64x8.ConvertToUint32, map1[float64](floatToUint32_x86))\n \t\ttestFloat32x4ConvertToUint64(t, archsimd.Float32x4.ConvertToUint64, map1[float32](floatToUint64_x86))\n@@ -152,6 +155,7 @@ func TestConvert(t *testing.T) {\n \t\ttestFloat64x8ConvertToUint64(t, archsimd.Float64x8.ConvertToUint64, map1[float64](floatToUint64_x86))\n \n \t\ttestInt32x16ConvertToFloat32(t, archsimd.Int32x16.ConvertToFloat32, map1[int32](toFloat32))\n+\t\ttestInt64x2ConvertToFloat32(t, archsimd.Int64x2.ConvertToFloat32, map1n[int64](toFloat32, 4))\n \t\ttestInt64x4ConvertToFloat32(t, archsimd.Int64x4.ConvertToFloat32, map1[int64](toFloat32))\n \t\ttestInt64x8ConvertToFloat32(t, archsimd.Int64x8.ConvertToFloat32, map1[int64](toFloat32))\n \t\ttestInt64x2ConvertToFloat64(t, archsimd.Int64x2.ConvertToFloat64, map1[int64](toFloat64))\n@@ -161,6 +165,7 @@ func TestConvert(t *testing.T) {\n \t\ttestUint32x4ConvertToFloat32(t, archsimd.Uint32x4.ConvertToFloat32, map1[uint32](toFloat32))\n \t\ttestUint32x8ConvertToFloat32(t, archsimd.Uint32x8.ConvertToFloat32, map1[uint32](toFloat32))\n \t\ttestUint32x16ConvertToFloat32(t, archsimd.Uint32x16.ConvertToFloat32, map1[uint32](toFloat32))\n+\t\ttestUint64x2ConvertToFloat32(t, archsimd.Uint64x2.ConvertToFloat32, map1n[uint64](toFloat32, 4))\n \t\ttestUint64x4ConvertToFloat32(t, archsimd.Uint64x4.ConvertToFloat32, map1[uint64](toFloat32))\n \t\ttestUint64x8ConvertToFloat32(t, archsimd.Uint64x8.ConvertToFloat32, map1[uint64](toFloat32))\n \t\ttestUint32x4ConvertToFloat64(t, archsimd.Uint32x4.ConvertToFloat64, map1[uint32](toFloat64))","output":"test(simd): add float64x2 and 64-bit conversion tests","metadata":{"id":"go-6ecdd2fc","repository":"go","commit_hash":"6ecdd2fc6e58c0cd2b788032a85f7845af10c922"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/reflect/value.go | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/src/reflect/value.go b/src/reflect/value.go\nindex 7f0ec2a3..8c8acbaa 100644\n--- a/src/reflect/value.go\n+++ b/src/reflect/value.go\n@@ -362,6 +362,7 @@ func (v Value) CanSet() bool {\n // type of the function's corresponding input parameter.\n // If v is a variadic function, Call creates the variadic slice parameter\n // itself, copying in the corresponding values.\n+// It panics if the Value was obtained by accessing unexported struct fields.\n func (v Value) Call(in []Value) []Value {\n \tv.mustBe(Func)\n \tv.mustBeExported()\n@@ -375,6 +376,7 @@ func (v Value) Call(in []Value) []Value {\n // It returns the output results as Values.\n // As in Go, each input argument must be assignable to the\n // type of the function's corresponding input parameter.\n+// It panics if the Value was obtained by accessing unexported struct fields.\n func (v Value) CallSlice(in []Value) []Value {\n \tv.mustBe(Func)\n \tv.mustBeExported()","output":"docs(reflect): add panic note for unexported struct fields","metadata":{"id":"go-08369369","repository":"go","commit_hash":"08369369e5a4b27d8f6d21ea571ea5027b9a2b46"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/internal/coverage/decodemeta/decodefile.go | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/internal/coverage/decodemeta/decodefile.go b/src/internal/coverage/decodemeta/decodefile.go\nindex 6f4dd1a3..474844bf 100644\n--- a/src/internal/coverage/decodemeta/decodefile.go\n+++ b/src/internal/coverage/decodemeta/decodefile.go\n@@ -75,7 +75,7 @@ func (r *CoverageMetaFileReader) readFileHeader() error {\n \t// Vet the version. If this is a meta-data file from the future,\n \t// we won't be able to read it.\n \tif r.hdr.Version > coverage.MetaFileVersion {\n-\t\treturn fmt.Errorf(\"meta-data file withn unknown version %d (expected %d)\", r.hdr.Version, coverage.MetaFileVersion)\n+\t\treturn fmt.Errorf(\"meta-data file with an unknown version %d (expected %d)\", r.hdr.Version, coverage.MetaFileVersion)\n \t}\n \n \t// Read package offsets for good measure","output":"fix(coverage): correct typo in error message","metadata":{"id":"go-ca8effbd","repository":"go","commit_hash":"ca8effbde150257847f90de220686786aa091f90"}}
{"instruction":"Generate a conventional commit message for the following git diff.\n\nFollow the conventional commit format: type(scope): description\n\nTypes: feat, fix, docs, style, refactor, test, chore, ci, build, perf\n\nRules:\n- Use lowercase for description\n- Use imperative mood (add, fix, update)\n- No period at end\n- Keep under 72 characters","input":" src/encoding/gob/doc.go | 20 ++++++++++----------\n 1 file changed, 10 insertions(+), 10 deletions(-)\n\ndiff --git a/src/encoding/gob/doc.go b/src/encoding/gob/doc.go\nindex c7468068..390f2508 100644\n--- a/src/encoding/gob/doc.go\n+++ b/src/encoding/gob/doc.go\n@@ -153,16 +153,16 @@ are transmitted, even if all the elements are zero.\n \n Structs are sent as a sequence of (field number, field value) pairs. The field\n value is sent using the standard gob encoding for its type, recursively. If a\n-field has the zero value for its type (except for arrays; see above), it is omitted\n-from the transmission. The field number is defined by the type of the encoded\n-struct: the first field of the encoded type is field 0, the second is field 1,\n-etc. When encoding a value, the field numbers are delta encoded for efficiency\n-and the fields are always sent in order of increasing field number; the deltas are\n-therefore unsigned. The initialization for the delta encoding sets the field\n-number to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned\n-delta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been\n-sent a terminating mark denotes the end of the struct. That mark is a delta=0\n-value, which has representation (00).\n+field has the zero value for its type (except for arrays; see above) or it's a\n+pointer to a zero value, it is omitted from the transmission. The field number\n+is defined by the type of the encoded struct: the first field of the encoded type\n+is field 0, the second is field 1, etc. When encoding a value, the field numbers\n+are delta encoded for efficiency and the fields are always sent in order of\n+increasing field number; the deltas are therefore unsigned. The initialization\n+for the delta encoding sets the field number to -1, so an unsigned integer field 0\n+with value 7 is transmitted as unsigned delta = 1, unsigned value = 7 or (01 07).\n+Finally, after all the fields have been sent a terminating mark denotes the end\n+of the struct. That mark is a delta=0 value, which has representation (00).\n \n Interface types are not checked for compatibility; all interface types are\n treated, for transmission, as members of a single \"interface\" type, analogous to","output":"docs(gob): clarify zero value pointer omission in encoding","metadata":{"id":"go-0b06b68e","repository":"go","commit_hash":"0b06b68e21a3fbc75b3dd87c644da94828483a36"}}
